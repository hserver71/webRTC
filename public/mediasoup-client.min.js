(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mediasoup = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var IDX = 256,
  HEX = [],
  BUFFER;
while (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);
function v4() {
  var i = 0,
    num,
    out = '';
  if (!BUFFER || IDX + 16 > 256) {
    BUFFER = Array(i = 256);
    while (i--) BUFFER[i] = 256 * Math.random() | 0;
    i = IDX = 0;
  }
  for (; i < 16; i++) {
    num = BUFFER[IDX + i];
    if (i == 6) out += HEX[num & 15 | 64];else if (i == 8) out += HEX[num & 63 | 128];else out += HEX[num];
    if (i & 1 && i > 1 && i < 11) out += '-';
  }
  IDX++;
  return out;
}
exports.v4 = v4;

},{}],2:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AwaitQueue = void 0;
var Logger_1 = require("./Logger");
var errors_1 = require("./errors");
var logger = new Logger_1.Logger('AwaitQueue');
var AwaitQueue = /*#__PURE__*/function () {
  function AwaitQueue() {
    _classCallCheck(this, AwaitQueue);
    // Queue of pending tasks (map of PendingTasks indexed by id).
    _defineProperty(this, "pendingTasks", new Map());
    // Incrementing PendingTask id.
    _defineProperty(this, "nextTaskId", 0);
    logger.debug('constructor()');
  }
  return _createClass(AwaitQueue, [{
    key: "size",
    get: function get() {
      return this.pendingTasks.size;
    }
  }, {
    key: "push",
    value: function () {
      var _push = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(task, name, options) {
        var _this = this;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              name = name !== null && name !== void 0 ? name : task.name;
              logger.debug("push() [name:".concat(name, ", options:%o]"), options);
              if (!(typeof task !== 'function')) {
                _context.n = 1;
                break;
              }
              throw new TypeError('given task is not a function');
            case 1:
              if (name) {
                try {
                  Object.defineProperty(task, 'name', {
                    value: name
                  });
                } catch (error) {}
              }
              return _context.a(2, new Promise(function (_resolve, _reject) {
                if (name && options !== null && options !== void 0 && options.removeOngoingTasksWithSameName) {
                  var _iterator = _createForOfIteratorHelper(_this.pendingTasks.values()),
                    _step;
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      var _pendingTask = _step.value;
                      if (_pendingTask.name === name) {
                        _pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError(), {
                          canExecuteNextTask: false
                        });
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                }
                var pendingTask = {
                  id: _this.nextTaskId++,
                  task: task,
                  name: name,
                  enqueuedAt: Date.now(),
                  executedAt: undefined,
                  completed: false,
                  resolve: function resolve(result) {
                    // pendingTask.resolve() can only be called in execute() method. Since
                    // resolve() was called it means that the task successfully completed.
                    // However the task may have been stopped before it completed (via
                    // stop() or remove()) so its completed flag was already set. If this
                    // is the case, abort here since next task (if any) is already being
                    // executed.
                    if (pendingTask.completed) {
                      return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    _this.pendingTasks["delete"](pendingTask.id);
                    logger.debug("resolving task [name:".concat(pendingTask.name, "]"));
                    // Resolve the task with the obtained result.
                    _resolve(result);
                    // Execute the next pending task (if any).
                    var _this$pendingTasks$va = _this.pendingTasks.values(),
                      _this$pendingTasks$va2 = _slicedToArray(_this$pendingTasks$va, 1),
                      nextPendingTask = _this$pendingTasks$va2[0];
                    // NOTE: During the resolve() callback the user app may have interacted
                    // with the queue. For instance, the app may have pushed a task while
                    // the queue was empty so such a task is already being executed. If so,
                    // don't execute it twice.
                    if (nextPendingTask && !nextPendingTask.executedAt) {
                      void _this.execute(nextPendingTask);
                    }
                  },
                  reject: function reject(error, _ref) {
                    var canExecuteNextTask = _ref.canExecuteNextTask;
                    // pendingTask.reject() can be called within execute() method if the
                    // task completed with error. However it may have also been called in
                    // stop() or remove() methods (before or while being executed) so its
                    // completed flag was already set. If so, abort here since next task
                    // (if any) is already being executed.
                    if (pendingTask.completed) {
                      return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    _this.pendingTasks["delete"](pendingTask.id);
                    logger.debug("rejecting task [name:".concat(pendingTask.name, "]: %s"), String(error));
                    // Reject the task with the obtained error.
                    _reject(error);
                    // May execute next pending task (if any).
                    if (canExecuteNextTask) {
                      var _this$pendingTasks$va3 = _this.pendingTasks.values(),
                        _this$pendingTasks$va4 = _slicedToArray(_this$pendingTasks$va3, 1),
                        nextPendingTask = _this$pendingTasks$va4[0];
                      // NOTE: During the reject() callback the user app may have interacted
                      // with the queue. For instance, the app may have pushed a task while
                      // the queue was empty so such a task is already being executed. If so,
                      // don't execute it twice.
                      if (nextPendingTask && !nextPendingTask.executedAt) {
                        void _this.execute(nextPendingTask);
                      }
                    }
                  }
                };
                // Append task to the queue.
                _this.pendingTasks.set(pendingTask.id, pendingTask);
                // And execute it if this is the only task in the queue.
                if (_this.pendingTasks.size === 1) {
                  void _this.execute(pendingTask);
                }
              }));
          }
        }, _callee);
      }));
      function push(_x, _x2, _x3) {
        return _push.apply(this, arguments);
      }
      return push;
    }()
  }, {
    key: "stop",
    value: function stop() {
      logger.debug('stop()');
      var _iterator2 = _createForOfIteratorHelper(this.pendingTasks.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var pendingTask = _step2.value;
          logger.debug("stop() | stopping task [name:".concat(pendingTask.name, "]"));
          pendingTask.reject(new errors_1.AwaitQueueStoppedError(), {
            canExecuteNextTask: false
          });
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "remove",
    value: function remove(taskIdx) {
      logger.debug("remove() [taskIdx:".concat(taskIdx, "]"));
      var pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
      if (!pendingTask) {
        logger.debug("stop() | no task with given idx [taskIdx:".concat(taskIdx, "]"));
        return;
      }
      pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError(), {
        canExecuteNextTask: true
      });
    }
  }, {
    key: "dump",
    value: function dump() {
      var now = Date.now();
      var idx = 0;
      return Array.from(this.pendingTasks.values()).map(function (pendingTask) {
        return {
          idx: idx++,
          task: pendingTask.task,
          name: pendingTask.name,
          enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
          executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
        };
      });
    }
  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(pendingTask) {
        var result, _t;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              logger.debug("execute() [name:".concat(pendingTask.name, "]"));
              if (!pendingTask.executedAt) {
                _context2.n = 1;
                break;
              }
              throw new Error('task already being executed');
            case 1:
              pendingTask.executedAt = Date.now();
              _context2.p = 2;
              _context2.n = 3;
              return pendingTask.task();
            case 3:
              result = _context2.v;
              // Resolve the task with its resolved result (if any).
              pendingTask.resolve(result);
              _context2.n = 5;
              break;
            case 4:
              _context2.p = 4;
              _t = _context2.v;
              // Reject the task with its rejected error.
              pendingTask.reject(_t, {
                canExecuteNextTask: true
              });
            case 5:
              return _context2.a(2);
          }
        }, _callee2, null, [[2, 4]]);
      }));
      function execute(_x4) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
  }]);
}();
exports.AwaitQueue = AwaitQueue;

},{"./Logger":3,"./errors":4}],3:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;
var debug = require("debug");
var LIB_NAME = 'awaitqueue';
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck(this, Logger);
    _defineProperty(this, "_debug", void 0);
    _defineProperty(this, "_warn", void 0);
    _defineProperty(this, "_error", void 0);
    if (prefix) {
      this._debug = debug("".concat(LIB_NAME, ":").concat(prefix));
      this._warn = debug("".concat(LIB_NAME, ":WARN:").concat(prefix));
      this._error = debug("".concat(LIB_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = debug(LIB_NAME);
      this._warn = debug("".concat(LIB_NAME, ":WARN"));
      this._error = debug("".concat(LIB_NAME, ":ERROR"));
    }
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  return _createClass(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
}();
exports.Logger = Logger;

},{"debug":6}],4:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
/**
 * Custom Error derived class used to reject pending tasks once stop() method
 * has been called.
 */
var AwaitQueueStoppedError = /*#__PURE__*/function (_Error) {
  function AwaitQueueStoppedError(message) {
    var _this;
    _classCallCheck(this, AwaitQueueStoppedError);
    _this = _callSuper(this, AwaitQueueStoppedError, [message !== null && message !== void 0 ? message : 'queue stopped']);
    _this.name = 'AwaitQueueStoppedError';
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_this, AwaitQueueStoppedError);
    }
    return _this;
  }
  _inherits(AwaitQueueStoppedError, _Error);
  return _createClass(AwaitQueueStoppedError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
/**
 * Custom Error derived class used to reject pending tasks once removeTask()
 * method has been called.
 */
var AwaitQueueRemovedTaskError = /*#__PURE__*/function (_Error2) {
  function AwaitQueueRemovedTaskError(message) {
    var _this2;
    _classCallCheck(this, AwaitQueueRemovedTaskError);
    _this2 = _callSuper(this, AwaitQueueRemovedTaskError, [message !== null && message !== void 0 ? message : 'queue task removed']);
    _this2.name = 'AwaitQueueRemovedTaskError';
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_this2, AwaitQueueRemovedTaskError);
    }
    return _this2;
  }
  _inherits(AwaitQueueRemovedTaskError, _Error2);
  return _createClass(AwaitQueueRemovedTaskError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = exports.AwaitQueue = void 0;
var AwaitQueue_1 = require("./AwaitQueue");
Object.defineProperty(exports, "AwaitQueue", {
  enumerable: true,
  get: function get() {
    return AwaitQueue_1.AwaitQueue;
  }
});
var errors_1 = require("./errors");
Object.defineProperty(exports, "AwaitQueueStoppedError", {
  enumerable: true,
  get: function get() {
    return errors_1.AwaitQueueStoppedError;
  }
});
Object.defineProperty(exports, "AwaitQueueRemovedTaskError", {
  enumerable: true,
  get: function get() {
    return errors_1.AwaitQueueRemovedTaskError;
  }
});

},{"./AwaitQueue":2,"./errors":4}],6:[function(require,module,exports){
(function (process){(function (){
"use strict";

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }
  var m;

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  // eslint-disable-next-line no-return-assign
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || function () {};

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  var r;
  try {
    r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = require('./common')(exports);
var formatters = module.exports.formatters;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

}).call(this)}).call(this,require('_process'))
},{"./common":7,"_process":43}],7:[function(require,module,exports){
"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    var hash = 0;
    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      var self = debug;

      // Set `diff` timestamp
      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        var formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
    var _iterator = _createForOfIteratorHelper(split),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var ns = _step.value;
        if (ns[0] === '-') {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  /**
   * Checks if the given string matches a namespace template, honoring
   * asterisks as wildcards.
   *
   * @param {String} search
   * @param {String} template
   * @return {Boolean}
   */
  function matchesTemplate(search, template) {
    var searchIndex = 0;
    var templateIndex = 0;
    var starIndex = -1;
    var matchIndex = 0;
    while (searchIndex < search.length) {
      if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
        // Match character or proceed with wildcard
        if (template[templateIndex] === '*') {
          starIndex = templateIndex;
          matchIndex = searchIndex;
          templateIndex++; // Skip the '*'
        } else {
          searchIndex++;
          templateIndex++;
        }
      } else if (starIndex !== -1) {
        // eslint-disable-line no-negated-condition
        // Backtrack to the last '*' and try to match more characters
        templateIndex = starIndex + 1;
        matchIndex++;
        searchIndex = matchIndex;
      } else {
        return false; // No match
      }
    }

    // Handle trailing '*' in template
    while (templateIndex < template.length && template[templateIndex] === '*') {
      templateIndex++;
    }
    return templateIndex === template.length;
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names), _toConsumableArray(createDebug.skips.map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    var _iterator2 = _createForOfIteratorHelper(createDebug.skips),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var skip = _step2.value;
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    var _iterator3 = _createForOfIteratorHelper(createDebug.names),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var ns = _step3.value;
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    return false;
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;

},{"ms":42}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }
  var handler = events[type];
  if (handler === undefined) return false;
  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== undefined) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

},{}],9:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeEvent = void 0;
// NOTE: Do not use our FakeEventTarget type inside this class, otherwise TS
// will complain because "Property 'listeners' is missing in type 'EventTarget'
// but required in type 'FakeEventTarget'".
var FakeEvent = /*#__PURE__*/function () {
  function FakeEvent(type) {
    var _options$bubbles, _options$cancelable;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, FakeEvent);
    /**
     * Constants.
     */
    _defineProperty(this, "NONE", 0);
    _defineProperty(this, "CAPTURING_PHASE", 1);
    _defineProperty(this, "AT_TARGET", 2);
    _defineProperty(this, "BUBBLING_PHASE", 3);
    /**
     * Members.
     */
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "bubbles", void 0);
    _defineProperty(this, "cancelable", void 0);
    _defineProperty(this, "defaultPrevented", false);
    _defineProperty(this, "composed", false);
    _defineProperty(this, "currentTarget", null);
    // Not implemented.
    _defineProperty(this, "eventPhase", this.NONE);
    _defineProperty(this, "isTrusted", true);
    _defineProperty(this, "target", null);
    _defineProperty(this, "timeStamp", 0);
    // Deprecated.
    _defineProperty(this, "cancelBubble", false);
    _defineProperty(this, "returnValue", true);
    _defineProperty(this, "srcElement", null);
    this.type = type;
    this.bubbles = (_options$bubbles = options.bubbles) !== null && _options$bubbles !== void 0 ? _options$bubbles : false;
    this.cancelable = (_options$cancelable = options.cancelable) !== null && _options$cancelable !== void 0 ? _options$cancelable : false;
  }
  return _createClass(FakeEvent, [{
    key: "preventDefault",
    value: function preventDefault() {
      if (this.cancelable) {
        this.defaultPrevented = true;
      }
    }
    /**
     * Not implemented.
     */
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {}
    /**
     * Not implemented.
     */
  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {}
    /**
     * Not implemented.
     */
  }, {
    key: "composedPath",
    value: function composedPath() {
      return [];
    }
    /**
     * Not implemented.
     * @deprecated
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "initEvent",
    value: function initEvent(type, bubbles, cancelable) {
      // Not implemented.
    }
  }]);
}();
exports.FakeEvent = FakeEvent;

},{}],10:[function(require,module,exports){
"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeEventTarget = void 0;
var FakeEventTarget = /*#__PURE__*/function () {
  function FakeEventTarget() {
    _classCallCheck(this, FakeEventTarget);
    _defineProperty(this, "listeners", {});
  }
  return _createClass(FakeEventTarget, [{
    key: "addEventListener",
    value: function addEventListener(type, callback, options) {
      var _this$listeners, _this$listeners$type;
      if (!callback) {
        return;
      }
      (_this$listeners$type = (_this$listeners = this.listeners)[type]) !== null && _this$listeners$type !== void 0 ? _this$listeners$type : _this$listeners[type] = [];
      this.listeners[type].push({
        callback:
        // eslint-disable-next-line @typescript-eslint/unbound-method
        typeof callback === 'function' ? callback : callback.handleEvent,
        once: _typeof(options) === 'object' && options.once === true
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, callback,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
      if (!this.listeners[type]) {
        return;
      }
      if (!callback) {
        return;
      }
      this.listeners[type] = this.listeners[type].filter(function (listener) {
        return listener.callback !== (
        // eslint-disable-next-line @typescript-eslint/unbound-method
        typeof callback === 'function' ? callback : callback.handleEvent);
      });
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      var _this = this;
      if (!event || typeof event.type !== 'string') {
        throw new Error('invalid event object');
      }
      var entries = this.listeners[event.type];
      if (!entries) {
        return true;
      }
      var _loop = function _loop() {
        var listener = _arr[_i];
        try {
          listener.callback.call(_this, event);
        } catch (error) {
          // Avoid that the error breaks the iteration.
          setTimeout(function () {
            throw error;
          }, 0);
        }
        if (listener.once) {
          _this.removeEventListener(event.type, listener.callback);
        }
      };
      for (var _i = 0, _arr = _toConsumableArray(entries); _i < _arr.length; _i++) {
        _loop();
      }
      return !event.defaultPrevented;
    }
  }]);
}();
exports.FakeEventTarget = FakeEventTarget;

},{}],11:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeMediaStreamTrack = void 0;
var uuid_1 = require("@lukeed/uuid");
var FakeEventTarget_1 = require("./fakeEvents/FakeEventTarget");
var FakeEvent_1 = require("./fakeEvents/FakeEvent");
var utils_1 = require("./utils");
var _id = /*#__PURE__*/new WeakMap();
var _kind = /*#__PURE__*/new WeakMap();
var _label = /*#__PURE__*/new WeakMap();
var _readyState = /*#__PURE__*/new WeakMap();
var _enabled = /*#__PURE__*/new WeakMap();
var _muted = /*#__PURE__*/new WeakMap();
var _contentHint = /*#__PURE__*/new WeakMap();
var _capabilities = /*#__PURE__*/new WeakMap();
var _constraints = /*#__PURE__*/new WeakMap();
var _settings = /*#__PURE__*/new WeakMap();
var _data = /*#__PURE__*/new WeakMap();
var _onmute = /*#__PURE__*/new WeakMap();
var _onunmute = /*#__PURE__*/new WeakMap();
var _onended = /*#__PURE__*/new WeakMap();
var _onenabledchange = /*#__PURE__*/new WeakMap();
var _onstopped = /*#__PURE__*/new WeakMap();
var FakeMediaStreamTrack = /*#__PURE__*/function (_FakeEventTarget_1$Fa) {
  function FakeMediaStreamTrack(_ref) {
    var _this;
    var kind = _ref.kind,
      id = _ref.id,
      label = _ref.label,
      contentHint = _ref.contentHint,
      enabled = _ref.enabled,
      muted = _ref.muted,
      readyState = _ref.readyState,
      capabilities = _ref.capabilities,
      constraints = _ref.constraints,
      settings = _ref.settings,
      data = _ref.data;
    _classCallCheck(this, FakeMediaStreamTrack);
    _this = _callSuper(this, FakeMediaStreamTrack);
    _classPrivateFieldInitSpec(_this, _id, void 0);
    _classPrivateFieldInitSpec(_this, _kind, void 0);
    _classPrivateFieldInitSpec(_this, _label, void 0);
    _classPrivateFieldInitSpec(_this, _readyState, void 0);
    _classPrivateFieldInitSpec(_this, _enabled, void 0);
    _classPrivateFieldInitSpec(_this, _muted, void 0);
    _classPrivateFieldInitSpec(_this, _contentHint, void 0);
    _classPrivateFieldInitSpec(_this, _capabilities, void 0);
    _classPrivateFieldInitSpec(_this, _constraints, void 0);
    _classPrivateFieldInitSpec(_this, _settings, void 0);
    _classPrivateFieldInitSpec(_this, _data, void 0);
    // Events.
    _classPrivateFieldInitSpec(_this, _onmute, null);
    _classPrivateFieldInitSpec(_this, _onunmute, null);
    _classPrivateFieldInitSpec(_this, _onended, null);
    // Custom events.
    _classPrivateFieldInitSpec(_this, _onenabledchange, null);
    _classPrivateFieldInitSpec(_this, _onstopped, null);
    _classPrivateFieldSet(_id, _this, id !== null && id !== void 0 ? id : (0, uuid_1.v4)());
    _classPrivateFieldSet(_kind, _this, kind);
    _classPrivateFieldSet(_label, _this, label !== null && label !== void 0 ? label : '');
    _classPrivateFieldSet(_contentHint, _this, contentHint !== null && contentHint !== void 0 ? contentHint : '');
    _classPrivateFieldSet(_enabled, _this, enabled !== null && enabled !== void 0 ? enabled : true);
    _classPrivateFieldSet(_muted, _this, muted !== null && muted !== void 0 ? muted : false);
    _classPrivateFieldSet(_readyState, _this, readyState !== null && readyState !== void 0 ? readyState : 'live');
    _classPrivateFieldSet(_capabilities, _this, capabilities !== null && capabilities !== void 0 ? capabilities : {});
    _classPrivateFieldSet(_constraints, _this, constraints !== null && constraints !== void 0 ? constraints : {});
    _classPrivateFieldSet(_settings, _this, settings !== null && settings !== void 0 ? settings : {});
    _classPrivateFieldSet(_data, _this, data !== null && data !== void 0 ? data : {});
    return _this;
  }
  _inherits(FakeMediaStreamTrack, _FakeEventTarget_1$Fa);
  return _createClass(FakeMediaStreamTrack, [{
    key: "id",
    get: function get() {
      return _classPrivateFieldGet(_id, this);
    }
  }, {
    key: "kind",
    get: function get() {
      return _classPrivateFieldGet(_kind, this);
    }
  }, {
    key: "label",
    get: function get() {
      return _classPrivateFieldGet(_label, this);
    }
  }, {
    key: "contentHint",
    get: function get() {
      return _classPrivateFieldGet(_contentHint, this);
    },
    set: function set(contentHint) {
      _classPrivateFieldSet(_contentHint, this, contentHint);
    }
  }, {
    key: "enabled",
    get: function get() {
      return _classPrivateFieldGet(_enabled, this);
    }
    /**
     * Changes `enabled` member value and fires a custom "enabledchange" event.
     */,
    set: function set(enabled) {
      var changed = _classPrivateFieldGet(_enabled, this) !== enabled;
      _classPrivateFieldSet(_enabled, this, enabled);
      if (changed) {
        this.dispatchEvent(new FakeEvent_1.FakeEvent('enabledchange'));
      }
    }
  }, {
    key: "muted",
    get: function get() {
      return _classPrivateFieldGet(_muted, this);
    }
  }, {
    key: "readyState",
    get: function get() {
      return _classPrivateFieldGet(_readyState, this);
    }
    /**
     * Application custom data getter.
     */
  }, {
    key: "data",
    get: function get() {
      return _classPrivateFieldGet(_data, this);
    }
    /**
     * Application custom data setter.
     */,
    set: function set(data) {
      _classPrivateFieldSet(_data, this, data);
    }
  }, {
    key: "onmute",
    get: function get() {
      return _classPrivateFieldGet(_onmute, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onmute, this)) {
        this.removeEventListener('mute', _classPrivateFieldGet(_onmute, this));
      }
      _classPrivateFieldSet(_onmute, this, handler);
      if (handler) {
        this.addEventListener('mute', handler);
      }
    }
  }, {
    key: "onunmute",
    get: function get() {
      return _classPrivateFieldGet(_onunmute, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onunmute, this)) {
        this.removeEventListener('unmute', _classPrivateFieldGet(_onunmute, this));
      }
      _classPrivateFieldSet(_onunmute, this, handler);
      if (handler) {
        this.addEventListener('unmute', handler);
      }
    }
  }, {
    key: "onended",
    get: function get() {
      return _classPrivateFieldGet(_onended, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onended, this)) {
        this.removeEventListener('ended', _classPrivateFieldGet(_onended, this));
      }
      _classPrivateFieldSet(_onended, this, handler);
      if (handler) {
        this.addEventListener('ended', handler);
      }
    }
  }, {
    key: "onenabledchange",
    get: function get() {
      return _classPrivateFieldGet(_onenabledchange, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onenabledchange, this)) {
        this.removeEventListener('enabledchange', _classPrivateFieldGet(_onenabledchange, this));
      }
      _classPrivateFieldSet(_onenabledchange, this, handler);
      if (handler) {
        this.addEventListener('enabledchange', handler);
      }
    }
  }, {
    key: "onstopped",
    get: function get() {
      return _classPrivateFieldGet(_onstopped, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onstopped, this)) {
        this.removeEventListener('stopped', _classPrivateFieldGet(_onstopped, this));
      }
      _classPrivateFieldSet(_onstopped, this, handler);
      if (handler) {
        this.addEventListener('stopped', handler);
      }
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      _superPropGet(FakeMediaStreamTrack, "addEventListener", this, 3)([type, listener, options]);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      _superPropGet(FakeMediaStreamTrack, "removeEventListener", this, 3)([type, listener, options]);
    }
    /**
     * Changes `readyState` member to "ended" and fires a custom "stopped" event
     * (if not already stopped).
     */
  }, {
    key: "stop",
    value: function stop() {
      if (_classPrivateFieldGet(_readyState, this) === 'ended') {
        return;
      }
      _classPrivateFieldSet(_readyState, this, 'ended');
      this.dispatchEvent(new FakeEvent_1.FakeEvent('stopped'));
    }
    /**
     * Clones current track into another FakeMediaStreamTrack. `id` and `data`
     * can be optionally given.
     */
  }, {
    key: "clone",
    value: function clone() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref2.id,
        data = _ref2.data;
      return new FakeMediaStreamTrack({
        id: id !== null && id !== void 0 ? id : (0, uuid_1.v4)(),
        kind: _classPrivateFieldGet(_kind, this),
        label: _classPrivateFieldGet(_label, this),
        contentHint: _classPrivateFieldGet(_contentHint, this),
        enabled: _classPrivateFieldGet(_enabled, this),
        muted: _classPrivateFieldGet(_muted, this),
        readyState: _classPrivateFieldGet(_readyState, this),
        capabilities: (0, utils_1.clone)(_classPrivateFieldGet(_capabilities, this)),
        constraints: (0, utils_1.clone)(_classPrivateFieldGet(_constraints, this)),
        settings: (0, utils_1.clone)(_classPrivateFieldGet(_settings, this)),
        data: data !== null && data !== void 0 ? data : (0, utils_1.clone)(_classPrivateFieldGet(_data, this))
      });
    }
  }, {
    key: "getCapabilities",
    value: function getCapabilities() {
      return _classPrivateFieldGet(_capabilities, this);
    }
  }, {
    key: "getConstraints",
    value: function getConstraints() {
      return _classPrivateFieldGet(_constraints, this);
    }
  }, {
    key: "applyConstraints",
    value: function () {
      var _applyConstraints = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var constraints,
          _args = arguments;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              constraints = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              _classPrivateFieldSet(_constraints, this, constraints);
              // To make it be "more" async so ESLint doesn't complain.
              return _context.a(2, Promise.resolve());
          }
        }, _callee, this);
      }));
      function applyConstraints() {
        return _applyConstraints.apply(this, arguments);
      }
      return applyConstraints;
    }()
  }, {
    key: "getSettings",
    value: function getSettings() {
      return _classPrivateFieldGet(_settings, this);
    }
    /**
     * Simulates a remotely triggered stop. It fires a custom "stopped" event and
     * the standard "ended" event (if the track was not already stopped).
     */
  }, {
    key: "remoteStop",
    value: function remoteStop() {
      if (_classPrivateFieldGet(_readyState, this) === 'ended') {
        return;
      }
      _classPrivateFieldSet(_readyState, this, 'ended');
      this.dispatchEvent(new FakeEvent_1.FakeEvent('stopped'));
      this.dispatchEvent(new FakeEvent_1.FakeEvent('ended'));
    }
    /**
     * Simulates a remotely triggered mute. It fires a "mute" event (if the track
     * was not already muted).
     */
  }, {
    key: "remoteMute",
    value: function remoteMute() {
      if (_classPrivateFieldGet(_muted, this)) {
        return;
      }
      _classPrivateFieldSet(_muted, this, true);
      this.dispatchEvent(new FakeEvent_1.FakeEvent('mute'));
    }
    /**
     * Simulates a remotely triggered unmute. It fires an "unmute" event (if the
     * track was muted).
     */
  }, {
    key: "remoteUnmute",
    value: function remoteUnmute() {
      if (!_classPrivateFieldGet(_muted, this)) {
        return;
      }
      _classPrivateFieldSet(_muted, this, false);
      this.dispatchEvent(new FakeEvent_1.FakeEvent('unmute'));
    }
  }]);
}(FakeEventTarget_1.FakeEventTarget);
exports.FakeMediaStreamTrack = FakeMediaStreamTrack;

},{"./fakeEvents/FakeEvent":9,"./fakeEvents/FakeEventTarget":10,"./utils":12,"@lukeed/uuid":1}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clone = clone;
/**
 * Clones the given value.
 */
function clone(value) {
  if (value === undefined) {
    return undefined;
  } else if (Number.isNaN(value)) {
    return NaN;
  } else if (typeof structuredClone === 'function') {
    // Available in Node >= 18.
    return structuredClone(value);
  } else {
    return JSON.parse(JSON.stringify(value));
  }
}

},{}],13:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;
var debug_1 = __importDefault(require("debug"));
var APP_NAME = 'h264-profile-level-id';
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck(this, Logger);
    if (prefix) {
      this._debug = (0, debug_1["default"])("".concat(APP_NAME, ":").concat(prefix));
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN:").concat(prefix));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = (0, debug_1["default"])(APP_NAME);
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN"));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR"));
    }
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  return _createClass(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
}();
exports.Logger = Logger;

},{"debug":6}],14:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
exports.parseProfileLevelId = parseProfileLevelId;
exports.profileLevelIdToString = profileLevelIdToString;
exports.profileToString = profileToString;
exports.levelToString = levelToString;
exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
exports.isSameProfile = isSameProfile;
exports.isSameProfileAndLevel = isSameProfileAndLevel;
exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
exports.supportedLevel = supportedLevel;
var Logger_1 = require("./Logger");
var logger = new Logger_1.Logger();
/**
 * Supported profiles.
 */
var Profile;
(function (Profile) {
  Profile[Profile["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
  Profile[Profile["Baseline"] = 2] = "Baseline";
  Profile[Profile["Main"] = 3] = "Main";
  Profile[Profile["ConstrainedHigh"] = 4] = "ConstrainedHigh";
  Profile[Profile["High"] = 5] = "High";
  Profile[Profile["PredictiveHigh444"] = 6] = "PredictiveHigh444";
})(Profile || (exports.Profile = Profile = {}));
/**
 * Supported levels.
 */
var Level;
(function (Level) {
  Level[Level["L1_b"] = 0] = "L1_b";
  Level[Level["L1"] = 10] = "L1";
  Level[Level["L1_1"] = 11] = "L1_1";
  Level[Level["L1_2"] = 12] = "L1_2";
  Level[Level["L1_3"] = 13] = "L1_3";
  Level[Level["L2"] = 20] = "L2";
  Level[Level["L2_1"] = 21] = "L2_1";
  Level[Level["L2_2"] = 22] = "L2_2";
  Level[Level["L3"] = 30] = "L3";
  Level[Level["L3_1"] = 31] = "L3_1";
  Level[Level["L3_2"] = 32] = "L3_2";
  Level[Level["L4"] = 40] = "L4";
  Level[Level["L4_1"] = 41] = "L4_1";
  Level[Level["L4_2"] = 42] = "L4_2";
  Level[Level["L5"] = 50] = "L5";
  Level[Level["L5_1"] = 51] = "L5_1";
  Level[Level["L5_2"] = 52] = "L5_2";
})(Level || (exports.Level = Level = {}));
/**
 * Represents a parsed h264 profile-level-id value.
 */
var ProfileLevelId = /*#__PURE__*/_createClass(function ProfileLevelId(profile, level) {
  _classCallCheck(this, ProfileLevelId);
  this.profile = profile;
  this.level = level;
});
exports.ProfileLevelId = ProfileLevelId;
// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
var DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
/**
 * Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to
 * be either 0 or 1.
 */
var BitPattern = /*#__PURE__*/function () {
  function BitPattern(str) {
    _classCallCheck(this, BitPattern);
    this.mask = ~byteMaskString('x', str);
    this.masked_value = byteMaskString('1', str);
  }
  return _createClass(BitPattern, [{
    key: "isMatch",
    value: function isMatch(value) {
      return this.masked_value === (value & this.mask);
    }
  }]);
}();
/**
 * Class for converting between profile_idc/profile_iop to Profile.
 */
var ProfilePattern = /*#__PURE__*/_createClass(function ProfilePattern(profile_idc, profile_iop, profile) {
  _classCallCheck(this, ProfilePattern);
  this.profile_idc = profile_idc;
  this.profile_iop = profile_iop;
  this.profile = profile;
}); // This is from https://tools.ietf.org/html/rfc6184#section-8.1.
var ProfilePatterns = [new ProfilePattern(0x42, new BitPattern('x1xx0000'), Profile.ConstrainedBaseline), new ProfilePattern(0x4d, new BitPattern('1xxx0000'), Profile.ConstrainedBaseline), new ProfilePattern(0x58, new BitPattern('11xx0000'), Profile.ConstrainedBaseline), new ProfilePattern(0x42, new BitPattern('x0xx0000'), Profile.Baseline), new ProfilePattern(0x58, new BitPattern('10xx0000'), Profile.Baseline), new ProfilePattern(0x4d, new BitPattern('0x0x0000'), Profile.Main), new ProfilePattern(0x64, new BitPattern('00000000'), Profile.High), new ProfilePattern(0x64, new BitPattern('00001100'), Profile.ConstrainedHigh), new ProfilePattern(0xf4, new BitPattern('00000000'), Profile.PredictiveHigh444)];
// This is from ITU-T H.264 (02/2016) Table A-1  Level limits.
var LevelConstraints = [{
  max_macroblocks_per_second: 1485,
  max_macroblock_frame_size: 99,
  level: Level.L1
}, {
  max_macroblocks_per_second: 1485,
  max_macroblock_frame_size: 99,
  level: Level.L1_b
}, {
  max_macroblocks_per_second: 3000,
  max_macroblock_frame_size: 396,
  level: Level.L1_1
}, {
  max_macroblocks_per_second: 6000,
  max_macroblock_frame_size: 396,
  level: Level.L1_2
}, {
  max_macroblocks_per_second: 11880,
  max_macroblock_frame_size: 396,
  level: Level.L1_3
}, {
  max_macroblocks_per_second: 11880,
  max_macroblock_frame_size: 396,
  level: Level.L2
}, {
  max_macroblocks_per_second: 19800,
  max_macroblock_frame_size: 792,
  level: Level.L2_1
}, {
  max_macroblocks_per_second: 20250,
  max_macroblock_frame_size: 1620,
  level: Level.L2_2
}, {
  max_macroblocks_per_second: 40500,
  max_macroblock_frame_size: 1620,
  level: Level.L3
}, {
  max_macroblocks_per_second: 108000,
  max_macroblock_frame_size: 3600,
  level: Level.L3_1
}, {
  max_macroblocks_per_second: 216000,
  max_macroblock_frame_size: 5120,
  level: Level.L3_2
}, {
  max_macroblocks_per_second: 245760,
  max_macroblock_frame_size: 8192,
  level: Level.L4
}, {
  max_macroblocks_per_second: 245760,
  max_macroblock_frame_size: 8192,
  level: Level.L4_1
}, {
  max_macroblocks_per_second: 522240,
  max_macroblock_frame_size: 8704,
  level: Level.L4_2
}, {
  max_macroblocks_per_second: 589824,
  max_macroblock_frame_size: 22080,
  level: Level.L5
}, {
  max_macroblocks_per_second: 983040,
  max_macroblock_frame_size: 36864,
  level: Level.L5_1
}, {
  max_macroblocks_per_second: 2073600,
  max_macroblock_frame_size: 36864,
  level: Level.L5_2
}];
/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 */
function parseProfileLevelId(str) {
  // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
  // flag specifies if level 1b or level 1.1 is used.
  var ConstraintSet3Flag = 0x10;
  // The string should consist of 3 bytes in hexadecimal format.
  if (typeof str !== 'string' || str.length !== 6) {
    return undefined;
  }
  var profile_level_id_numeric = parseInt(str, 16);
  if (profile_level_id_numeric === 0) {
    return undefined;
  }
  // Separate into three bytes.
  var level_idc = profile_level_id_numeric & 0xff;
  var profile_iop = profile_level_id_numeric >> 8 & 0xff;
  var profile_idc = profile_level_id_numeric >> 16 & 0xff;
  // Parse level based on level_idc and constraint set 3 flag.
  var level;
  switch (level_idc) {
    case Level.L1_1:
      {
        level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
        break;
      }
    case Level.L1:
    case Level.L1_2:
    case Level.L1_3:
    case Level.L2:
    case Level.L2_1:
    case Level.L2_2:
    case Level.L3:
    case Level.L3_1:
    case Level.L3_2:
    case Level.L4:
    case Level.L4_1:
    case Level.L4_2:
    case Level.L5:
    case Level.L5_1:
    case Level.L5_2:
      {
        level = level_idc;
        break;
      }
    // Unrecognized level_idc.
    default:
      {
        logger.warn("parseProfileLevelId() | unrecognized level_idc [str:".concat(str, ", level_idc:").concat(level_idc, "]"));
        return undefined;
      }
  }
  // Parse profile_idc/profile_iop into a Profile enum.
  var _iterator = _createForOfIteratorHelper(ProfilePatterns),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var pattern = _step.value;
      if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
        logger.debug("parseProfileLevelId() | result [str:".concat(str, ", profile:").concat(pattern.profile, ", level:").concat(level, "]"));
        return new ProfileLevelId(pattern.profile, level);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  logger.warn("parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:".concat(str, ", profile_idc:").concat(profile_idc, ", profile_iop:").concat(profile_iop, "]"));
  return undefined;
}
/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 */
function profileLevelIdToString(profile_level_id) {
  // Handle special case level == 1b.
  if (profile_level_id.level == Level.L1_b) {
    switch (profile_level_id.profile) {
      case Profile.ConstrainedBaseline:
        {
          return '42f00b';
        }
      case Profile.Baseline:
        {
          return '42100b';
        }
      case Profile.Main:
        {
          return '4d100b';
        }
      // Level 1_b is not allowed for other profiles.
      default:
        {
          logger.warn("profileLevelIdToString() | Level 1_b not is allowed for profile ".concat(profile_level_id.profile));
          return undefined;
        }
    }
  }
  var profile_idc_iop_string;
  switch (profile_level_id.profile) {
    case Profile.ConstrainedBaseline:
      {
        profile_idc_iop_string = '42e0';
        break;
      }
    case Profile.Baseline:
      {
        profile_idc_iop_string = '4200';
        break;
      }
    case Profile.Main:
      {
        profile_idc_iop_string = '4d00';
        break;
      }
    case Profile.ConstrainedHigh:
      {
        profile_idc_iop_string = '640c';
        break;
      }
    case Profile.High:
      {
        profile_idc_iop_string = '6400';
        break;
      }
    case Profile.PredictiveHigh444:
      {
        profile_idc_iop_string = 'f400';
        break;
      }
    default:
      {
        logger.warn("profileLevelIdToString() | unrecognized profile ".concat(profile_level_id.profile));
        return undefined;
      }
  }
  var levelStr = profile_level_id.level.toString(16);
  if (levelStr.length === 1) {
    levelStr = "0".concat(levelStr);
  }
  return "".concat(profile_idc_iop_string).concat(levelStr);
}
/**
 * Returns a human friendly name for the given profile.
 */
function profileToString(profile) {
  switch (profile) {
    case Profile.ConstrainedBaseline:
      {
        return 'ConstrainedBaseline';
      }
    case Profile.Baseline:
      {
        return 'Baseline';
      }
    case Profile.Main:
      {
        return 'Main';
      }
    case Profile.ConstrainedHigh:
      {
        return 'ConstrainedHigh';
      }
    case Profile.High:
      {
        return 'High';
      }
    case Profile.PredictiveHigh444:
      {
        return 'PredictiveHigh444';
      }
    default:
      {
        logger.warn("profileToString() | unrecognized profile ".concat(profile));
        return undefined;
      }
  }
}
/**
 * Returns a human friendly name for the given level.
 */
function levelToString(level) {
  switch (level) {
    case Level.L1_b:
      {
        return '1b';
      }
    case Level.L1:
      {
        return '1';
      }
    case Level.L1_1:
      {
        return '1.1';
      }
    case Level.L1_2:
      {
        return '1.2';
      }
    case Level.L1_3:
      {
        return '1.3';
      }
    case Level.L2:
      {
        return '2';
      }
    case Level.L2_1:
      {
        return '2.1';
      }
    case Level.L2_2:
      {
        return '2.2';
      }
    case Level.L3:
      {
        return '3';
      }
    case Level.L3_1:
      {
        return '3.1';
      }
    case Level.L3_2:
      {
        return '3.2';
      }
    case Level.L4:
      {
        return '4';
      }
    case Level.L4_1:
      {
        return '4.1';
      }
    case Level.L4_2:
      {
        return '4.2';
      }
    case Level.L5:
      {
        return '5';
      }
    case Level.L5_1:
      {
        return '5.1';
      }
    case Level.L5_2:
      {
        return '5.2';
      }
    default:
      {
        logger.warn("levelToString() | unrecognized level ".concat(level));
        return undefined;
      }
  }
}
/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned
 * if the key is present but the string is invalid.
 */
function parseSdpProfileLevelId() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var profile_level_id = params['profile-level-id'];
  return profile_level_id ? parseProfileLevelId(profile_level_id) : DefaultProfileLevelId;
}
/**
 * Returns true if the codec parameters have the same H264 profile, i.e. the
 * same H264 profile (Baseline, High, etc).
 */
function isSameProfile() {
  var params1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var profile_level_id_1 = parseSdpProfileLevelId(params1);
  var profile_level_id_2 = parseSdpProfileLevelId(params2);
  // Compare H264 profiles, but not levels.
  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
}
/**
 * Returns true if the codec parameters have the same H264 profile, i.e. the
 * same H264 profile (Baseline, High, etc) and same level.
 */
function isSameProfileAndLevel() {
  var params1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var profile_level_id_1 = parseSdpProfileLevelId(params1);
  var profile_level_id_2 = parseSdpProfileLevelId(params2);
  // Compare H264 profiles, but not levels.
  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile && profile_level_id_1.level == profile_level_id_2.level);
}
/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict
 * superset of the profile in remote_offered_params, we could limit the profile
 * in the answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and
 * level-asymmetry-allowed.
 */
function generateProfileLevelIdStringForAnswer() {
  var local_supported_params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var remote_offered_params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // If both local and remote params do not contain profile-level-id, they are
  // both using the default profile. In this case, don't return anything.
  if (!local_supported_params['profile-level-id'] && !remote_offered_params['profile-level-id']) {
    logger.warn('generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params');
    return undefined;
  }
  // Parse profile-level-ids.
  var local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
  var remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
  // The local and remote codec must have valid and equal H264 Profiles.
  if (!local_profile_level_id) {
    throw new TypeError('invalid local_profile_level_id');
  }
  if (!remote_profile_level_id) {
    throw new TypeError('invalid remote_profile_level_id');
  }
  if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
    throw new TypeError('H264 Profile mismatch');
  }
  // Parse level information.
  var level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
  var local_level = local_profile_level_id.level;
  var remote_level = remote_profile_level_id.level;
  var min_level = minLevel(local_level, remote_level);
  // Determine answer level. When level asymmetry is not allowed, level upgrade
  // is not allowed, i.e., the level in the answer must be equal to or lower
  // than the level in the offer.
  var answer_level = level_asymmetry_allowed ? local_level : min_level;
  logger.debug("generateProfileLevelIdStringForAnswer() | result [profile:".concat(local_profile_level_id.profile, ", level:").concat(answer_level, "]"));
  // Return the resulting profile-level-id for the answer parameters.
  return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
}
/**
 * Given that a decoder supports up to a given frame size (in pixels) at up to
 * a given number of frames per second, return the highest H264 level where it
 * can guarantee that it will be able to support all valid encoded streams that
 * are within that level.
 */
function supportedLevel(max_frame_pixel_count, max_fps) {
  var PixelsPerMacroblock = 16 * 16;
  for (var i = LevelConstraints.length - 1; i >= 0; --i) {
    var level_constraint = LevelConstraints[i];
    if (level_constraint.max_macroblock_frame_size * PixelsPerMacroblock <= max_frame_pixel_count && level_constraint.max_macroblocks_per_second <= max_fps * level_constraint.max_macroblock_frame_size) {
      logger.debug("supportedLevel() | result [max_frame_pixel_count:".concat(max_frame_pixel_count, ", max_fps:").concat(max_fps, ", level:").concat(level_constraint.level, "]"));
      return level_constraint.level;
    }
  }
  // No level supported.
  logger.warn("supportedLevel() | no level supported [max_frame_pixel_count:".concat(max_frame_pixel_count, ", max_fps:").concat(max_fps, "]"));
  return undefined;
}
/**
 * Convert a string of 8 characters into a byte where the positions containing
 * character c will have their bit set. For example, c = 'x', str = "x1xx0000"
 * will return 0b10110000.
 */
function byteMaskString(c, str) {
  return Number(str[0] === c) << 7 | Number(str[1] === c) << 6 | Number(str[2] === c) << 5 | Number(str[3] === c) << 4 | Number(str[4] === c) << 3 | Number(str[5] === c) << 2 | Number(str[6] === c) << 1 | Number(str[7] === c) << 0;
}
// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b) {
  if (a === Level.L1_b) {
    return b !== Level.L1 && b !== Level.L1_b;
  }
  if (b === Level.L1_b) {
    return a !== Level.L1;
  }
  return a < b;
}
function minLevel(a, b) {
  return isLessLevel(a, b) ? a : b;
}
function isLevelAsymmetryAllowed() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var level_asymmetry_allowed = params['level-asymmetry-allowed'];
  return level_asymmetry_allowed === true || level_asymmetry_allowed === 1 || level_asymmetry_allowed === '1';
}

},{"./Logger":13}],15:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Consumer = void 0;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var logger = new Logger_1.Logger('Consumer');
var Consumer = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Consumer(_ref) {
    var _this;
    var id = _ref.id,
      localId = _ref.localId,
      producerId = _ref.producerId,
      rtpReceiver = _ref.rtpReceiver,
      track = _ref.track,
      rtpParameters = _ref.rtpParameters,
      appData = _ref.appData;
    _classCallCheck(this, Consumer);
    _this = _callSuper(this, Consumer);
    // Id.
    _defineProperty(_this, "_id", void 0);
    // Local id.
    _defineProperty(_this, "_localId", void 0);
    // Associated Producer id.
    _defineProperty(_this, "_producerId", void 0);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Associated RTCRtpReceiver.
    _defineProperty(_this, "_rtpReceiver", void 0);
    // Remote track.
    _defineProperty(_this, "_track", void 0);
    // RTP parameters.
    _defineProperty(_this, "_rtpParameters", void 0);
    // Paused flag.
    _defineProperty(_this, "_paused", void 0);
    // App custom data.
    _defineProperty(_this, "_appData", void 0);
    // Observer instance.
    _defineProperty(_this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    _this._id = id;
    _this._localId = localId;
    _this._producerId = producerId;
    _this._rtpReceiver = rtpReceiver;
    _this._track = track;
    _this._rtpParameters = rtpParameters;
    _this._paused = !track.enabled;
    _this._appData = appData !== null && appData !== void 0 ? appData : {};
    _this.onTrackEnded = _this.onTrackEnded.bind(_this);
    _this.handleTrack();
    return _this;
  }
  /**
   * Consumer id.
   */
  _inherits(Consumer, _enhancedEvents_1$Enh);
  return _createClass(Consumer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Local id.
     */
  }, {
    key: "localId",
    get: function get() {
      return this._localId;
    }
    /**
     * Associated Producer id.
     */
  }, {
    key: "producerId",
    get: function get() {
      return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Media kind.
     */
  }, {
    key: "kind",
    get: function get() {
      return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */
  }, {
    key: "rtpReceiver",
    get: function get() {
      return this._rtpReceiver;
    }
    /**
     * The associated track.
     */
  }, {
    key: "track",
    get: function get() {
      return this._track;
    }
    /**
     * RTP parameters.
     */
  }, {
    key: "rtpParameters",
    get: function get() {
      return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */
  }, {
    key: "paused",
    get: function get() {
      return this._paused;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the Consumer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      this.destroyTrack();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(Consumer, "close", this, 3)([]);
      this._observer.close();
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug('transportClosed()');
      this._closed = true;
      this.destroyTrack();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
  }, {
    key: "getStats",
    value: (function () {
      var _getStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var _this2 = this;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!this._closed) {
                _context.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              return _context.a(2, new Promise(function (resolve, reject) {
                _this2.safeEmit('@getstats', resolve, reject);
              }));
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Pauses receiving media.
     */
    )
  }, {
    key: "pause",
    value: function pause() {
      logger.debug('pause()');
      if (this._closed) {
        logger.error('pause() | Consumer closed');
        return;
      }
      if (this._paused) {
        logger.debug('pause() | Consumer is already paused');
        return;
      }
      this._paused = true;
      this._track.enabled = false;
      this.emit('@pause');
      // Emit observer event.
      this._observer.safeEmit('pause');
    }
    /**
     * Resumes receiving media.
     */
  }, {
    key: "resume",
    value: function resume() {
      logger.debug('resume()');
      if (this._closed) {
        logger.error('resume() | Consumer closed');
        return;
      }
      if (!this._paused) {
        logger.debug('resume() | Consumer is already resumed');
        return;
      }
      this._paused = false;
      this._track.enabled = true;
      this.emit('@resume');
      // Emit observer event.
      this._observer.safeEmit('resume');
    }
  }, {
    key: "onTrackEnded",
    value: function onTrackEnded() {
      logger.debug('track "ended" event');
      this.safeEmit('trackended');
      // Emit observer event.
      this._observer.safeEmit('trackended');
    }
  }, {
    key: "handleTrack",
    value: function handleTrack() {
      this._track.addEventListener('ended', this.onTrackEnded);
    }
  }, {
    key: "destroyTrack",
    value: function destroyTrack() {
      try {
        this._track.removeEventListener('ended', this.onTrackEnded);
        this._track.stop();
      } catch (error) {}
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Consumer = Consumer;

},{"./Logger":19,"./enhancedEvents":22,"./errors":23}],16:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataConsumer = void 0;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var logger = new Logger_1.Logger('DataConsumer');
var DataConsumer = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function DataConsumer(_ref) {
    var _this;
    var id = _ref.id,
      dataProducerId = _ref.dataProducerId,
      dataChannel = _ref.dataChannel,
      sctpStreamParameters = _ref.sctpStreamParameters,
      appData = _ref.appData;
    _classCallCheck(this, DataConsumer);
    _this = _callSuper(this, DataConsumer);
    // Id.
    _defineProperty(_this, "_id", void 0);
    // Associated DataProducer Id.
    _defineProperty(_this, "_dataProducerId", void 0);
    // The underlying RTCDataChannel instance.
    _defineProperty(_this, "_dataChannel", void 0);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // SCTP stream parameters.
    _defineProperty(_this, "_sctpStreamParameters", void 0);
    // App custom data.
    _defineProperty(_this, "_appData", void 0);
    // Observer instance.
    _defineProperty(_this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    _this._id = id;
    _this._dataProducerId = dataProducerId;
    _this._dataChannel = dataChannel;
    _this._sctpStreamParameters = sctpStreamParameters;
    _this._appData = appData !== null && appData !== void 0 ? appData : {};
    _this.handleDataChannel();
    return _this;
  }
  /**
   * DataConsumer id.
   */
  _inherits(DataConsumer, _enhancedEvents_1$Enh);
  return _createClass(DataConsumer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Associated DataProducer id.
     */
  }, {
    key: "dataProducerId",
    get: function get() {
      return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
  }, {
    key: "sctpStreamParameters",
    get: function get() {
      return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
  }, {
    key: "readyState",
    get: function get() {
      return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
  }, {
    key: "label",
    get: function get() {
      return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
  }, {
    key: "protocol",
    get: function get() {
      return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */
  }, {
    key: "binaryType",
    get: function get() {
      return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */,
    set: function set(binaryType) {
      this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      this._dataChannel.close();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(DataConsumer, "close", this, 3)([]);
      this._observer.close();
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug('transportClosed()');
      this._closed = true;
      this._dataChannel.close();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
  }, {
    key: "handleDataChannel",
    value: function handleDataChannel() {
      var _this2 = this;
      this._dataChannel.addEventListener('open', function () {
        if (_this2._closed) {
          return;
        }
        logger.debug('DataChannel "open" event');
        _this2.safeEmit('open');
      });
      this._dataChannel.addEventListener('error', function (event) {
        var _event$error, _event$error2;
        if (_this2._closed) {
          return;
        }
        var error = (_event$error = event.error) !== null && _event$error !== void 0 ? _event$error : new Error('unknown DataChannel error');
        if (((_event$error2 = event.error) === null || _event$error2 === void 0 ? void 0 : _event$error2.errorDetail) === 'sctp-failure') {
          var _event$error3;
          logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', (_event$error3 = event.error) === null || _event$error3 === void 0 ? void 0 : _event$error3.sctpCauseCode, event.error.message);
        } else {
          logger.error('DataChannel "error" event: %o', error);
        }
        _this2.safeEmit('error', error);
      });
      this._dataChannel.addEventListener('close', function () {
        if (_this2._closed) {
          return;
        }
        logger.warn('DataChannel "close" event');
        _this2._closed = true;
        _this2.emit('@close');
        _this2.safeEmit('close');
        // Emit observer event.
        _this2._observer.safeEmit('close');
      });
      this._dataChannel.addEventListener('message', function (event) {
        if (_this2._closed) {
          return;
        }
        _this2.safeEmit('message', event.data);
      });
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.DataConsumer = DataConsumer;

},{"./Logger":19,"./enhancedEvents":22}],17:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataProducer = void 0;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var logger = new Logger_1.Logger('DataProducer');
var DataProducer = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function DataProducer(_ref) {
    var _this;
    var id = _ref.id,
      dataChannel = _ref.dataChannel,
      sctpStreamParameters = _ref.sctpStreamParameters,
      appData = _ref.appData;
    _classCallCheck(this, DataProducer);
    _this = _callSuper(this, DataProducer);
    // Id.
    _defineProperty(_this, "_id", void 0);
    // The underlying RTCDataChannel instance.
    _defineProperty(_this, "_dataChannel", void 0);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // SCTP stream parameters.
    _defineProperty(_this, "_sctpStreamParameters", void 0);
    // App custom data.
    _defineProperty(_this, "_appData", void 0);
    // Observer instance.
    _defineProperty(_this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    _this._id = id;
    _this._dataChannel = dataChannel;
    _this._sctpStreamParameters = sctpStreamParameters;
    _this._appData = appData !== null && appData !== void 0 ? appData : {};
    _this.handleDataChannel();
    return _this;
  }
  /**
   * DataProducer id.
   */
  _inherits(DataProducer, _enhancedEvents_1$Enh);
  return _createClass(DataProducer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
  }, {
    key: "sctpStreamParameters",
    get: function get() {
      return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
  }, {
    key: "readyState",
    get: function get() {
      return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
  }, {
    key: "label",
    get: function get() {
      return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
  }, {
    key: "protocol",
    get: function get() {
      return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */
  }, {
    key: "bufferedAmount",
    get: function get() {
      return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */
  }, {
    key: "bufferedAmountLowThreshold",
    get: function get() {
      return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */,
    set: function set(bufferedAmountLowThreshold) {
      this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the DataProducer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      this._dataChannel.close();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(DataProducer, "close", this, 3)([]);
      this._observer.close();
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug('transportClosed()');
      this._closed = true;
      this._dataChannel.close();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "send",
    value: function send(data) {
      logger.debug('send()');
      if (this._closed) {
        throw new errors_1.InvalidStateError('closed');
      }
      this._dataChannel.send(data);
    }
  }, {
    key: "handleDataChannel",
    value: function handleDataChannel() {
      var _this2 = this;
      this._dataChannel.addEventListener('open', function () {
        if (_this2._closed) {
          return;
        }
        logger.debug('DataChannel "open" event');
        _this2.safeEmit('open');
      });
      this._dataChannel.addEventListener('error', function (event) {
        var _event$error, _event$error2;
        if (_this2._closed) {
          return;
        }
        var error = (_event$error = event.error) !== null && _event$error !== void 0 ? _event$error : new Error('unknown DataChannel error');
        if (((_event$error2 = event.error) === null || _event$error2 === void 0 ? void 0 : _event$error2.errorDetail) === 'sctp-failure') {
          var _event$error3;
          logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', (_event$error3 = event.error) === null || _event$error3 === void 0 ? void 0 : _event$error3.sctpCauseCode, event.error.message);
        } else {
          logger.error('DataChannel "error" event: %o', error);
        }
        _this2.safeEmit('error', error);
      });
      this._dataChannel.addEventListener('close', function () {
        if (_this2._closed) {
          return;
        }
        logger.warn('DataChannel "close" event');
        _this2._closed = true;
        _this2.emit('@close');
        _this2.safeEmit('close');
        // Emit observer event.
        _this2._observer.safeEmit('close');
      });
      this._dataChannel.addEventListener('message', function () {
        if (_this2._closed) {
          return;
        }
        logger.warn('DataChannel "message" event in a DataProducer, message discarded');
      });
      this._dataChannel.addEventListener('bufferedamountlow', function () {
        if (_this2._closed) {
          return;
        }
        _this2.safeEmit('bufferedamountlow');
      });
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.DataProducer = DataProducer;

},{"./Logger":19,"./enhancedEvents":22,"./errors":23}],18:[function(require,module,exports){
"use strict";

function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Device = void 0;
exports.detectDevice = detectDevice;
exports.detectDeviceAsync = detectDeviceAsync;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var utils = require("./utils");
var ortc = require("./ortc");
var Transport_1 = require("./Transport");
var Chrome111_1 = require("./handlers/Chrome111");
var Chrome74_1 = require("./handlers/Chrome74");
var Firefox120_1 = require("./handlers/Firefox120");
var Safari12_1 = require("./handlers/Safari12");
var ReactNative106_1 = require("./handlers/ReactNative106");
var logger = new Logger_1.Logger('Device');
/**
 * Sync mediasoup-client Handler detection.
 */
function detectDevice(userAgent, userAgentData) {
  logger.debug('detectDevice()');
  if (!userAgent && (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') {
    userAgent = navigator.userAgent;
  }
  if (!userAgentData && (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') {
    userAgentData = navigator.userAgentData;
  }
  return detectDeviceImpl(userAgent, userAgentData);
}
/**
 * Async mediasoup-client Handler detection.
 *
 * @remarks
 * - Currently it runs same logic than `detectDevice()`.
 * - In the future this function could give better results than
 *   `detectDevice()`.
 */
function detectDeviceAsync(_x, _x2) {
  return _detectDeviceAsync.apply(this, arguments);
}
function _detectDeviceAsync() {
  _detectDeviceAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(userAgent, userAgentData) {
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          logger.debug('detectDeviceAsync()');
          if (!userAgent && (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') {
            userAgent = navigator.userAgent;
          }
          if (!userAgentData && (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') {
            userAgentData = navigator.userAgentData;
          }
          return _context3.a(2, detectDeviceImpl(userAgent, userAgentData));
      }
    }, _callee3);
  }));
  return _detectDeviceAsync.apply(this, arguments);
}
var Device = /*#__PURE__*/function () {
  /**
   * Create a new Device to connect to mediasoup server.
   *
   * @throws {UnsupportedError} if device is not supported.
   */
  function Device() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      handlerName = _ref.handlerName,
      handlerFactory = _ref.handlerFactory;
    _classCallCheck(this, Device);
    // RTC handler factory.
    _defineProperty(this, "_handlerFactory", void 0);
    // Handler name.
    _defineProperty(this, "_handlerName", void 0);
    // Loaded flag.
    _defineProperty(this, "_loaded", false);
    // Callback for sending Transports to request sending extended RTP capabilities
    // on demand.
    _defineProperty(this, "_getSendExtendedRtpCapabilities", void 0);
    // Local RTP capabilities for receiving media.
    _defineProperty(this, "_recvRtpCapabilities", void 0);
    // Whether we can produce audio/video based on remote RTP capabilities.
    _defineProperty(this, "_canProduceByKind", {
      audio: false,
      video: false
    });
    // Local SCTP capabilities.
    _defineProperty(this, "_sctpCapabilities", void 0);
    // Observer instance.
    _defineProperty(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    if (handlerName && handlerFactory) {
      throw new TypeError('just one of handlerName or handlerInterface can be given');
    }
    if (handlerFactory) {
      this._handlerFactory = handlerFactory;
    } else {
      if (handlerName) {
        logger.debug('constructor() | handler given: %s', handlerName);
      } else {
        handlerName = detectDevice();
        if (handlerName) {
          logger.debug('constructor() | detected handler: %s', handlerName);
        } else {
          throw new errors_1.UnsupportedError('device not supported');
        }
      }
      switch (handlerName) {
        case 'Chrome111':
          {
            this._handlerFactory = Chrome111_1.Chrome111.createFactory();
            break;
          }
        case 'Chrome74':
          {
            this._handlerFactory = Chrome74_1.Chrome74.createFactory();
            break;
          }
        case 'Firefox120':
          {
            this._handlerFactory = Firefox120_1.Firefox120.createFactory();
            break;
          }
        case 'Safari12':
          {
            this._handlerFactory = Safari12_1.Safari12.createFactory();
            break;
          }
        case 'ReactNative106':
          {
            this._handlerFactory = ReactNative106_1.ReactNative106.createFactory();
            break;
          }
        default:
          {
            throw new TypeError("unknown handlerName \"".concat(handlerName, "\""));
          }
      }
    }
    this._handlerName = this._handlerFactory.name;
  }
  /**
   * The RTC handler name.
   */
  return _createClass(Device, [{
    key: "handlerName",
    get: function get() {
      return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */
  }, {
    key: "loaded",
    get: function get() {
      return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */
  }, {
    key: "rtpCapabilities",
    get: function get() {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError('not loaded');
      }
      return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */
  }, {
    key: "sctpCapabilities",
    get: function get() {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError('not loaded');
      }
      return this._sctpCapabilities;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Initialize the Device.
     */
  }, {
    key: "load",
    value: (function () {
      var _load = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref2) {
        var routerRtpCapabilities, _ref2$preferLocalCode, preferLocalCodecsOrder, clonedRouterRtpCapabilities, _this$_handlerFactory, getNativeRtpCapabilities, getNativeSctpCapabilities, clonedNativeRtpCapabilities, recvExtendedRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              routerRtpCapabilities = _ref2.routerRtpCapabilities, _ref2$preferLocalCode = _ref2.preferLocalCodecsOrder, preferLocalCodecsOrder = _ref2$preferLocalCode === void 0 ? false : _ref2$preferLocalCode;
              logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);
              if (!this._loaded) {
                _context.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('already loaded');
            case 1:
              // Clone given router RTP capabilities to not modify input data.
              clonedRouterRtpCapabilities = utils.clone(routerRtpCapabilities); // This may throw.
              ortc.validateAndNormalizeRtpCapabilities(clonedRouterRtpCapabilities);
              _this$_handlerFactory = this._handlerFactory, getNativeRtpCapabilities = _this$_handlerFactory.getNativeRtpCapabilities, getNativeSctpCapabilities = _this$_handlerFactory.getNativeSctpCapabilities;
              _t = utils;
              _context.n = 2;
              return getNativeRtpCapabilities();
            case 2:
              clonedNativeRtpCapabilities = _t.clone.call(_t, _context.v);
              // This may throw.
              ortc.validateAndNormalizeRtpCapabilities(clonedNativeRtpCapabilities);
              logger.debug('load() | got native RTP capabilities:%o', clonedNativeRtpCapabilities);
              this._getSendExtendedRtpCapabilities = function (nativeRtpCapabilities) {
                return utils.clone(ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, clonedRouterRtpCapabilities, preferLocalCodecsOrder));
              };
              recvExtendedRtpCapabilities = ortc.getExtendedRtpCapabilities(clonedNativeRtpCapabilities, clonedRouterRtpCapabilities, /* preferLocalCodecsOrder */false); // Generate our receiving RTP capabilities for receiving media.
              this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(recvExtendedRtpCapabilities);
              // This may throw.
              ortc.validateAndNormalizeRtpCapabilities(this._recvRtpCapabilities);
              logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);
              // Check whether we can produce audio/video.
              this._canProduceByKind.audio = ortc.canSend('audio', this._recvRtpCapabilities);
              this._canProduceByKind.video = ortc.canSend('video', this._recvRtpCapabilities);
              // Generate our SCTP capabilities.
              _context.n = 3;
              return getNativeSctpCapabilities();
            case 3:
              this._sctpCapabilities = _context.v;
              // This may throw.
              ortc.validateSctpCapabilities(this._sctpCapabilities);
              logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);
              logger.debug('load() succeeded');
              this._loaded = true;
            case 4:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function load(_x3) {
        return _load.apply(this, arguments);
      }
      return load;
    }()
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    )
  }, {
    key: "canProduce",
    value: function canProduce(kind) {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError('not loaded');
      } else if (kind !== 'audio' && kind !== 'video') {
        throw new TypeError("invalid kind \"".concat(kind, "\""));
      }
      return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
  }, {
    key: "createSendTransport",
    value: function createSendTransport(_ref3) {
      var id = _ref3.id,
        iceParameters = _ref3.iceParameters,
        iceCandidates = _ref3.iceCandidates,
        dtlsParameters = _ref3.dtlsParameters,
        sctpParameters = _ref3.sctpParameters,
        iceServers = _ref3.iceServers,
        iceTransportPolicy = _ref3.iceTransportPolicy,
        additionalSettings = _ref3.additionalSettings,
        appData = _ref3.appData;
      logger.debug('createSendTransport()');
      return this.createTransport({
        direction: 'send',
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        appData: appData
      });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
  }, {
    key: "createRecvTransport",
    value: function createRecvTransport(_ref4) {
      var id = _ref4.id,
        iceParameters = _ref4.iceParameters,
        iceCandidates = _ref4.iceCandidates,
        dtlsParameters = _ref4.dtlsParameters,
        sctpParameters = _ref4.sctpParameters,
        iceServers = _ref4.iceServers,
        iceTransportPolicy = _ref4.iceTransportPolicy,
        additionalSettings = _ref4.additionalSettings,
        appData = _ref4.appData;
      logger.debug('createRecvTransport()');
      return this.createTransport({
        direction: 'recv',
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        appData: appData
      });
    }
  }, {
    key: "createTransport",
    value: function createTransport(_ref5) {
      var direction = _ref5.direction,
        id = _ref5.id,
        iceParameters = _ref5.iceParameters,
        iceCandidates = _ref5.iceCandidates,
        dtlsParameters = _ref5.dtlsParameters,
        sctpParameters = _ref5.sctpParameters,
        iceServers = _ref5.iceServers,
        iceTransportPolicy = _ref5.iceTransportPolicy,
        additionalSettings = _ref5.additionalSettings,
        appData = _ref5.appData;
      if (!this._loaded) {
        throw new errors_1.InvalidStateError('not loaded');
      } else if (typeof id !== 'string') {
        throw new TypeError('missing id');
      } else if (_typeof(iceParameters) !== 'object') {
        throw new TypeError('missing iceParameters');
      } else if (!Array.isArray(iceCandidates)) {
        throw new TypeError('missing iceCandidates');
      } else if (_typeof(dtlsParameters) !== 'object') {
        throw new TypeError('missing dtlsParameters');
      } else if (sctpParameters && _typeof(sctpParameters) !== 'object') {
        throw new TypeError('wrong sctpParameters');
      } else if (appData && _typeof(appData) !== 'object') {
        throw new TypeError('if given, appData must be an object');
      }
      // Create a new Transport.
      var transport = new Transport_1.Transport({
        direction: direction,
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        appData: appData,
        handlerFactory: this._handlerFactory,
        getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities,
        recvRtpCapabilities: this._recvRtpCapabilities,
        canProduceByKind: this._canProduceByKind
      });
      // Emit observer event.
      this._observer.safeEmit('newtransport', transport);
      return transport;
    }
  }], [{
    key: "factory",
    value: (
    /**
     * Create a new Device to connect to mediasoup server. It uses a more advanced
     * device detection.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    function () {
      var _factory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var _ref6,
          handlerName,
          handlerFactory,
          _args2 = arguments;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _ref6 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, handlerName = _ref6.handlerName, handlerFactory = _ref6.handlerFactory;
              logger.debug('factory()');
              if (!(handlerName && handlerFactory)) {
                _context2.n = 1;
                break;
              }
              throw new TypeError('just one of handlerName or handlerInterface can be given');
            case 1:
              if (!(!handlerName && !handlerFactory)) {
                _context2.n = 3;
                break;
              }
              _context2.n = 2;
              return detectDeviceAsync();
            case 2:
              handlerName = _context2.v;
              if (handlerName) {
                _context2.n = 3;
                break;
              }
              throw new errors_1.UnsupportedError('device not supported');
            case 3:
              return _context2.a(2, new Device({
                handlerName: handlerName,
                handlerFactory: handlerFactory
              }));
          }
        }, _callee2);
      }));
      function factory() {
        return _factory.apply(this, arguments);
      }
      return factory;
    }())
  }]);
}();
exports.Device = Device;
function detectDeviceImpl(userAgent, userAgentData) {
  logger.debug('detectDeviceImpl() [userAgent:"%s", userAgentData:%o]', userAgent, userAgentData);
  var chromiumMajorVersion = getChromiumMajorVersion(userAgent, userAgentData);
  if (chromiumMajorVersion) {
    if (chromiumMajorVersion >= 111) {
      logger.debug('detectDeviceImpl() | using Chrome111 handler');
      return 'Chrome111';
    } else if (chromiumMajorVersion >= 74) {
      logger.debug('detectDeviceImpl() | using Chrome74 handler');
      return 'Chrome74';
    } else {
      logger.warn('detectDeviceImpl() | unsupported Chromium based browser/version');
      return undefined;
    }
  }
  var firefoxMajorVersion = getFirefoxMajorVersion(userAgent);
  if (firefoxMajorVersion) {
    if (firefoxMajorVersion >= 120) {
      logger.debug('detectDeviceImpl() | using Firefox120 handler');
      return 'Firefox120';
    } else {
      logger.warn('detectDeviceImpl() | unsupported Firefox browser/version');
      return undefined;
    }
  }
  var macOSWebKitMajorVersion = getMacOSWebKitMajorVersion(userAgent);
  if (macOSWebKitMajorVersion) {
    if (macOSWebKitMajorVersion >= 605) {
      logger.debug('detectDeviceImpl() | using Safari12 handler');
      return 'Safari12';
    } else {
      logger.warn('detectDeviceImpl() | unsupported desktop Safari browser/version');
      return undefined;
    }
  }
  var iOSWebKitMajorVersion = getIOSWebKitMajorVersion(userAgent);
  if (iOSWebKitMajorVersion) {
    if (iOSWebKitMajorVersion >= 605) {
      logger.debug('detectDeviceImpl() | using Safari12 handler');
      return 'Safari12';
    } else {
      logger.warn('detectDeviceImpl() | unsupported iOS Safari based browser/version');
      return undefined;
    }
  }
  if (isReactNative()) {
    if (typeof RTCPeerConnection !== 'undefined' && typeof RTCRtpTransceiver !== 'undefined') {
      logger.debug('detectDeviceImpl() | using ReactNative106 handler');
      return 'ReactNative106';
    } else {
      logger.warn('detectDeviceImpl() | unsupported react-native-webrtc version without RTCPeerConnection or RTCRtpTransceiver, forgot to call registerGlobals() on it?');
      return undefined;
    }
  }
  logger.warn('detectDeviceImpl() | device not supported [userAgent:"%s", userAgentData:%o]', userAgent, userAgentData);
  return undefined;
}
function getChromiumMajorVersion(userAgent, userAgentData) {
  if (isIOS(userAgent, userAgentData)) {
    logger.debug('getChromiumMajorVersion() | this is iOS => undefined');
    return undefined;
  }
  if (isReactNative()) {
    logger.debug('getChromiumMajorVersion() | this is React-Native => undefined');
    return undefined;
  }
  if (userAgentData) {
    var _userAgentData$brands;
    // Some nasty browser extensions define their own custom
    // navigator.userAgentData without mandatory `brands` field, so let's be
    // ready for it.
    var chromiumBrand = ((_userAgentData$brands = userAgentData.brands) !== null && _userAgentData$brands !== void 0 ? _userAgentData$brands : []).find(function (b) {
      return b.brand === 'Chromium';
    });
    if (chromiumBrand) {
      var majorVersion = Number(chromiumBrand.version);
      logger.debug("getChromiumMajorVersion() | Chromium major version based on NavigatorUAData => ".concat(majorVersion));
      return majorVersion;
    }
  }
  var match = userAgent === null || userAgent === void 0 ? void 0 : userAgent.match(/\b(?:Chrome|Chromium)\/(\w+)/i);
  if (match !== null && match !== void 0 && match[1]) {
    var _majorVersion = Number(match[1]);
    logger.debug("getChromiumMajorVersion() | Chromium major version based on User-Agent => ".concat(_majorVersion));
    return _majorVersion;
  }
  logger.debug('getChromiumMajorVersion() | this is not Chromium => undefined');
  return undefined;
}
function getFirefoxMajorVersion(userAgent) {
  if (isIOS(userAgent)) {
    logger.debug('getFirefoxMajorVersion() | this is iOS => undefined');
    return undefined;
  }
  if (isReactNative()) {
    logger.debug('getFirefoxMajorVersion() | this is React-Native => undefined');
    return undefined;
  }
  var match = userAgent === null || userAgent === void 0 ? void 0 : userAgent.match(/\bFirefox\/(\w+)/i);
  if (match !== null && match !== void 0 && match[1]) {
    var majorVersion = Number(match[1]);
    logger.debug("getFirefoxMajorVersion() | Firefox major version based on User-Agent => ".concat(majorVersion));
    return majorVersion;
  }
  logger.debug('getFirefoxMajorVersion() | this is not Firefox => undefined');
  return undefined;
}
function getMacOSWebKitMajorVersion(userAgent) {
  if (isIOS(userAgent)) {
    logger.debug('getMacOSWebKitMajorVersion() | this is iOS => undefined');
    return undefined;
  }
  if (isReactNative()) {
    logger.debug('getMacOSWebKitMajorVersion() | this is React-Native => undefined');
    return undefined;
  }
  var isSafari = userAgent && /\bSafari\b/i.test(userAgent) && !/\bChrome\b/i.test(userAgent) && !/\bChromium\b/i.test(userAgent) && !/\bFirefox\b/i.test(userAgent);
  if (!isSafari) {
    logger.debug('getMacOSWebKitMajorVersion() | this is not Safari => undefined');
    return undefined;
  }
  var match = userAgent.match(/AppleWebKit\/(\w+)/i);
  if (match !== null && match !== void 0 && match[1]) {
    var majorVersion = Number(match[1]);
    logger.debug("getMacOSWebKitMajorVersion() | WebKit major version based on User-Agent => ".concat(majorVersion));
    return majorVersion;
  }
  logger.debug('getMacOSWebKitMajorVersion() | this is not WebKit => undefined');
  return undefined;
}
function getIOSWebKitMajorVersion(userAgent) {
  if (!isIOS(userAgent)) {
    logger.debug('getIOSWebKitMajorVersion() | this is not iOS => undefined');
    return undefined;
  }
  if (isReactNative()) {
    logger.debug('getIOSWebKitMajorVersion() | this is React-Native => undefined');
    return undefined;
  }
  var match = userAgent === null || userAgent === void 0 ? void 0 : userAgent.match(/AppleWebKit\/(\w+)/i);
  if (match !== null && match !== void 0 && match[1]) {
    var majorVersion = Number(match[1]);
    logger.debug("getIOSWebKitMajorVersion() | WebKit major version based on User-Agent => ".concat(majorVersion));
    return majorVersion;
  }
  logger.debug('getIOSWebKitMajorVersion() | this is not WebKit => undefined');
  return undefined;
}
function isIOS(userAgent, userAgentData) {
  if ((userAgentData === null || userAgentData === void 0 ? void 0 : userAgentData.platform) === 'iOS') {
    logger.debug('isIOS() | this is iOS based on NavigatorUAData.platform => true');
    return true;
  }
  if (userAgentData !== null && userAgentData !== void 0 && userAgentData.platform) {
    logger.debug('isIOS() | this is not iOS based on NavigatorUAData.platform => false');
    return false;
  }
  if (userAgent && /iPad|iPhone|iPod/.test(userAgent)) {
    logger.debug('isIOS() | this is iOS based on User-Agent => true');
    return true;
  }
  // iPadOS 13+ identifies itself as Mac (to force desktop view mode in some
  // websites) but we know it's iOS if it has touch screen.
  if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) {
    logger.debug('isIOS() | this is iPadOS 13+ based on User-Agent => true');
    return true;
  }
  logger.debug('isIOS() | this is not iOS => false');
  return false;
}
function isReactNative() {
  if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && navigator.product === 'ReactNative') {
    logger.debug('isReactNative() | this is React-Native based on navigator.product');
    return true;
  }
  logger.debug('isReactNative() | this is not React-Native => false');
  return false;
}

},{"./Logger":19,"./Transport":21,"./enhancedEvents":22,"./errors":23,"./handlers/Chrome111":24,"./handlers/Chrome74":25,"./handlers/Firefox120":27,"./handlers/ReactNative106":28,"./handlers/Safari12":29,"./ortc":37,"./utils":41}],19:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;
var debug_1 = require("debug");
var APP_NAME = 'mediasoup-client';
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck(this, Logger);
    _defineProperty(this, "_debug", void 0);
    _defineProperty(this, "_warn", void 0);
    _defineProperty(this, "_error", void 0);
    if (prefix) {
      this._debug = (0, debug_1["default"])("".concat(APP_NAME, ":").concat(prefix));
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN:").concat(prefix));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = (0, debug_1["default"])(APP_NAME);
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN"));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR"));
    }
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  return _createClass(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
}();
exports.Logger = Logger;

},{"debug":6}],20:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Producer = void 0;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var logger = new Logger_1.Logger('Producer');
var Producer = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Producer(_ref) {
    var _this;
    var id = _ref.id,
      localId = _ref.localId,
      rtpSender = _ref.rtpSender,
      track = _ref.track,
      rtpParameters = _ref.rtpParameters,
      stopTracks = _ref.stopTracks,
      disableTrackOnPause = _ref.disableTrackOnPause,
      zeroRtpOnPause = _ref.zeroRtpOnPause,
      appData = _ref.appData;
    _classCallCheck(this, Producer);
    _this = _callSuper(this, Producer);
    // Id.
    _defineProperty(_this, "_id", void 0);
    // Local id.
    _defineProperty(_this, "_localId", void 0);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Associated RTCRtpSender.
    _defineProperty(_this, "_rtpSender", void 0);
    // Local track.
    _defineProperty(_this, "_track", void 0);
    // Producer kind.
    _defineProperty(_this, "_kind", void 0);
    // RTP parameters.
    _defineProperty(_this, "_rtpParameters", void 0);
    // Paused flag.
    _defineProperty(_this, "_paused", void 0);
    // Video max spatial layer.
    _defineProperty(_this, "_maxSpatialLayer", void 0);
    // Whether the Producer should call stop() in given tracks.
    _defineProperty(_this, "_stopTracks", void 0);
    // Whether the Producer should set track.enabled = false when paused.
    _defineProperty(_this, "_disableTrackOnPause", void 0);
    // Whether we should replace the RTCRtpSender.track with null when paused.
    _defineProperty(_this, "_zeroRtpOnPause", void 0);
    // App custom data.
    _defineProperty(_this, "_appData", void 0);
    // Observer instance.
    _defineProperty(_this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    _this._id = id;
    _this._localId = localId;
    _this._rtpSender = rtpSender;
    _this._track = track;
    _this._kind = track.kind;
    _this._rtpParameters = rtpParameters;
    _this._paused = disableTrackOnPause ? !track.enabled : false;
    _this._maxSpatialLayer = undefined;
    _this._stopTracks = stopTracks;
    _this._disableTrackOnPause = disableTrackOnPause;
    _this._zeroRtpOnPause = zeroRtpOnPause;
    _this._appData = appData !== null && appData !== void 0 ? appData : {};
    _this.onTrackEnded = _this.onTrackEnded.bind(_this);
    // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
    // '@replacetrack' event here, so RTCRtpSender.track won't be null.
    _this.handleTrack();
    return _this;
  }
  /**
   * Producer id.
   */
  _inherits(Producer, _enhancedEvents_1$Enh);
  return _createClass(Producer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Local id.
     */
  }, {
    key: "localId",
    get: function get() {
      return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Media kind.
     */
  }, {
    key: "kind",
    get: function get() {
      return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */
  }, {
    key: "rtpSender",
    get: function get() {
      return this._rtpSender;
    }
    /**
     * The associated track.
     */
  }, {
    key: "track",
    get: function get() {
      return this._track;
    }
    /**
     * RTP parameters.
     */
  }, {
    key: "rtpParameters",
    get: function get() {
      return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
  }, {
    key: "paused",
    get: function get() {
      return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
  }, {
    key: "maxSpatialLayer",
    get: function get() {
      return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the Producer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      this.destroyTrack();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(Producer, "close", this, 3)([]);
      this._observer.close();
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug('transportClosed()');
      this._closed = true;
      this.destroyTrack();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpSender stats.
     */
  }, {
    key: "getStats",
    value: (function () {
      var _getStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var _this2 = this;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!this._closed) {
                _context.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              return _context.a(2, new Promise(function (resolve, reject) {
                _this2.safeEmit('@getstats', resolve, reject);
              }));
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Pauses sending media.
     */
    )
  }, {
    key: "pause",
    value: function pause() {
      var _this3 = this;
      logger.debug('pause()');
      if (this._closed) {
        logger.error('pause() | Producer closed');
        return;
      }
      this._paused = true;
      if (this._track && this._disableTrackOnPause) {
        this._track.enabled = false;
      }
      if (this._zeroRtpOnPause) {
        new Promise(function (resolve, reject) {
          _this3.safeEmit('@pause', resolve, reject);
        })["catch"](function () {});
      }
      // Emit observer event.
      this._observer.safeEmit('pause');
    }
    /**
     * Resumes sending media.
     */
  }, {
    key: "resume",
    value: function resume() {
      var _this4 = this;
      logger.debug('resume()');
      if (this._closed) {
        logger.error('resume() | Producer closed');
        return;
      }
      this._paused = false;
      if (this._track && this._disableTrackOnPause) {
        this._track.enabled = true;
      }
      if (this._zeroRtpOnPause) {
        new Promise(function (resolve, reject) {
          _this4.safeEmit('@resume', resolve, reject);
        })["catch"](function () {});
      }
      // Emit observer event.
      this._observer.safeEmit('resume');
    }
    /**
     * Replaces the current track with a new one or null.
     */
  }, {
    key: "replaceTrack",
    value: (function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref2) {
        var _this5 = this;
        var track;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              track = _ref2.track;
              logger.debug('replaceTrack() [track:%o]', track);
              if (!this._closed) {
                _context2.n = 1;
                break;
              }
              // This must be done here. Otherwise there is no chance to stop the given
              // track.
              if (track && this._stopTracks) {
                try {
                  track.stop();
                } catch (error) {}
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(track && track.readyState === 'ended')) {
                _context2.n = 2;
                break;
              }
              throw new errors_1.InvalidStateError('track ended');
            case 2:
              if (!(track === this._track)) {
                _context2.n = 3;
                break;
              }
              logger.debug('replaceTrack() | same track, ignored');
              return _context2.a(2);
            case 3:
              _context2.n = 4;
              return new Promise(function (resolve, reject) {
                _this5.safeEmit('@replacetrack', track, resolve, reject);
              });
            case 4:
              // Destroy the previous track.
              this.destroyTrack();
              // Set the new track.
              this._track = track;
              // If this Producer was paused/resumed and the state of the new
              // track does not match, fix it.
              if (this._track && this._disableTrackOnPause) {
                if (!this._paused) {
                  this._track.enabled = true;
                } else if (this._paused) {
                  this._track.enabled = false;
                }
              }
              // Handle the effective track.
              this.handleTrack();
            case 5:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function replaceTrack(_x) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
    /**
     * Sets the video max spatial layer to be sent.
     */
    )
  }, {
    key: "setMaxSpatialLayer",
    value: (function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(spatialLayer) {
        var _this6 = this;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              if (!this._closed) {
                _context3.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(this._kind !== 'video')) {
                _context3.n = 2;
                break;
              }
              throw new errors_1.UnsupportedError('not a video Producer');
            case 2:
              if (!(typeof spatialLayer !== 'number')) {
                _context3.n = 3;
                break;
              }
              throw new TypeError('invalid spatialLayer');
            case 3:
              if (!(spatialLayer === this._maxSpatialLayer)) {
                _context3.n = 4;
                break;
              }
              return _context3.a(2);
            case 4:
              _context3.n = 5;
              return new Promise(function (resolve, reject) {
                _this6.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);
              })["catch"](function () {});
            case 5:
              this._maxSpatialLayer = spatialLayer;
            case 6:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function setMaxSpatialLayer(_x2) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }())
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(params) {
        var _this7 = this;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              if (!this._closed) {
                _context4.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(_typeof(params) !== 'object')) {
                _context4.n = 2;
                break;
              }
              throw new TypeError('invalid params');
            case 2:
              _context4.n = 3;
              return new Promise(function (resolve, reject) {
                _this7.safeEmit('@setrtpencodingparameters', params, resolve, reject);
              });
            case 3:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function setRtpEncodingParameters(_x3) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "onTrackEnded",
    value: function onTrackEnded() {
      logger.debug('track "ended" event');
      this.safeEmit('trackended');
      // Emit observer event.
      this._observer.safeEmit('trackended');
    }
  }, {
    key: "handleTrack",
    value: function handleTrack() {
      if (!this._track) {
        return;
      }
      this._track.addEventListener('ended', this.onTrackEnded);
    }
  }, {
    key: "destroyTrack",
    value: function destroyTrack() {
      if (!this._track) {
        return;
      }
      try {
        this._track.removeEventListener('ended', this.onTrackEnded);
        // Just stop the track unless the app set stopTracks: false.
        if (this._stopTracks) {
          this._track.stop();
        }
      } catch (error) {}
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Producer = Producer;

},{"./Logger":19,"./enhancedEvents":22,"./errors":23}],21:[function(require,module,exports){
"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transport = void 0;
var awaitqueue_1 = require("awaitqueue");
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var utils = require("./utils");
var ortc = require("./ortc");
var Producer_1 = require("./Producer");
var Consumer_1 = require("./Consumer");
var DataProducer_1 = require("./DataProducer");
var DataConsumer_1 = require("./DataConsumer");
var logger = new Logger_1.Logger('Transport');
var ConsumerCreationTask = /*#__PURE__*/_createClass(function ConsumerCreationTask(consumerOptions) {
  var _this = this;
  _classCallCheck(this, ConsumerCreationTask);
  _defineProperty(this, "consumerOptions", void 0);
  _defineProperty(this, "promise", void 0);
  _defineProperty(this, "resolve", void 0);
  _defineProperty(this, "reject", void 0);
  this.consumerOptions = consumerOptions;
  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
});
var Transport = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Transport(_ref) {
    var _utils$clone;
    var _this2;
    var direction = _ref.direction,
      id = _ref.id,
      iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      iceServers = _ref.iceServers,
      iceTransportPolicy = _ref.iceTransportPolicy,
      additionalSettings = _ref.additionalSettings,
      appData = _ref.appData,
      handlerFactory = _ref.handlerFactory,
      getSendExtendedRtpCapabilities = _ref.getSendExtendedRtpCapabilities,
      recvRtpCapabilities = _ref.recvRtpCapabilities,
      canProduceByKind = _ref.canProduceByKind;
    _classCallCheck(this, Transport);
    _this2 = _callSuper(this, Transport);
    // Id.
    _defineProperty(_this2, "_id", void 0);
    // Closed flag.
    _defineProperty(_this2, "_closed", false);
    // Direction.
    _defineProperty(_this2, "_direction", void 0);
    // Callback for sending Transports to request sending extended RTP capabilities
    // on demand.
    _defineProperty(_this2, "_getSendExtendedRtpCapabilities", void 0);
    // Recv RTP capabilities.
    _defineProperty(_this2, "_recvRtpCapabilities", void 0);
    // Whether we can produce audio/video based on computed extended RTP
    // capabilities.
    _defineProperty(_this2, "_canProduceByKind", void 0);
    // SCTP max message size if enabled, null otherwise.
    _defineProperty(_this2, "_maxSctpMessageSize", void 0);
    // RTC handler isntance.
    _defineProperty(_this2, "_handler", void 0);
    // Transport ICE gathering state.
    _defineProperty(_this2, "_iceGatheringState", 'new');
    // Transport connection state.
    _defineProperty(_this2, "_connectionState", 'new');
    // App custom data.
    _defineProperty(_this2, "_appData", void 0);
    // Map of Producers indexed by id.
    _defineProperty(_this2, "_producers", new Map());
    // Map of Consumers indexed by id.
    _defineProperty(_this2, "_consumers", new Map());
    // Map of DataProducers indexed by id.
    _defineProperty(_this2, "_dataProducers", new Map());
    // Map of DataConsumers indexed by id.
    _defineProperty(_this2, "_dataConsumers", new Map());
    // Whether the Consumer for RTP probation has been created.
    _defineProperty(_this2, "_probatorConsumerCreated", false);
    // AwaitQueue instance to make async tasks happen sequentially.
    _defineProperty(_this2, "_awaitQueue", new awaitqueue_1.AwaitQueue());
    // Consumer creation tasks awaiting to be processed.
    _defineProperty(_this2, "_pendingConsumerTasks", []);
    // Consumer creation in progress flag.
    _defineProperty(_this2, "_consumerCreationInProgress", false);
    // Consumers pending to be paused.
    _defineProperty(_this2, "_pendingPauseConsumers", new Map());
    // Consumer pause in progress flag.
    _defineProperty(_this2, "_consumerPauseInProgress", false);
    // Consumers pending to be resumed.
    _defineProperty(_this2, "_pendingResumeConsumers", new Map());
    // Consumer resume in progress flag.
    _defineProperty(_this2, "_consumerResumeInProgress", false);
    // Consumers pending to be closed.
    _defineProperty(_this2, "_pendingCloseConsumers", new Map());
    // Consumer close in progress flag.
    _defineProperty(_this2, "_consumerCloseInProgress", false);
    // Observer instance.
    _defineProperty(_this2, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor() [id:%s, direction:%s]', id, direction);
    _this2._id = id;
    _this2._direction = direction;
    _this2._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
    _this2._recvRtpCapabilities = recvRtpCapabilities;
    _this2._canProduceByKind = canProduceByKind;
    _this2._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
    // Clone and sanitize additionalSettings.
    var clonedAdditionalSettings = (_utils$clone = utils.clone(additionalSettings)) !== null && _utils$clone !== void 0 ? _utils$clone : {};
    delete clonedAdditionalSettings.iceServers;
    delete clonedAdditionalSettings.iceTransportPolicy;
    delete clonedAdditionalSettings.bundlePolicy;
    delete clonedAdditionalSettings.rtcpMuxPolicy;
    _this2._handler = handlerFactory.factory({
      direction: direction,
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      sctpParameters: sctpParameters,
      iceServers: iceServers,
      iceTransportPolicy: iceTransportPolicy,
      additionalSettings: clonedAdditionalSettings,
      getSendExtendedRtpCapabilities: _this2._getSendExtendedRtpCapabilities
    });
    _this2._appData = appData !== null && appData !== void 0 ? appData : {};
    _this2.handleHandler();
    return _this2;
  }
  /**
   * Transport id.
   */
  _inherits(Transport, _enhancedEvents_1$Enh);
  return _createClass(Transport, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Whether the Transport is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Transport direction.
     */
  }, {
    key: "direction",
    get: function get() {
      return this._direction;
    }
    /**
     * RTC handler instance.
     */
  }, {
    key: "handler",
    get: function get() {
      return this._handler;
    }
    /**
     * ICE gathering state.
     */
  }, {
    key: "iceGatheringState",
    get: function get() {
      return this._iceGatheringState;
    }
    /**
     * Connection state.
     */
  }, {
    key: "connectionState",
    get: function get() {
      return this._connectionState;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Close the Transport.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      // Stop the AwaitQueue.
      this._awaitQueue.stop();
      // Close the handler.
      this._handler.close();
      // Change connection state to 'closed' since the handler may not emit
      // '@connectionstatechange' event.
      this._connectionState = 'closed';
      // Close all Producers.
      var _iterator = _createForOfIteratorHelper(this._producers.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var producer = _step.value;
          producer.transportClosed();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this._producers.clear();
      // Close all Consumers.
      var _iterator2 = _createForOfIteratorHelper(this._consumers.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var consumer = _step2.value;
          consumer.transportClosed();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this._consumers.clear();
      // Close all DataProducers.
      var _iterator3 = _createForOfIteratorHelper(this._dataProducers.values()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var dataProducer = _step3.value;
          dataProducer.transportClosed();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      this._dataProducers.clear();
      // Close all DataConsumers.
      var _iterator4 = _createForOfIteratorHelper(this._dataConsumers.values()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var dataConsumer = _step4.value;
          dataConsumer.transportClosed();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      this._dataConsumers.clear();
      // Emit observer event.
      this._observer.safeEmit('close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(Transport, "close", this, 3)([]);
      this._observer.close();
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
  }, {
    key: "getStats",
    value: (function () {
      var _getStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!this._closed) {
                _context.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              return _context.a(2, this._handler.getTransportStats());
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Restart ICE connection.
     */
    )
  }, {
    key: "restartIce",
    value: (function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(_ref2) {
        var _this3 = this;
        var iceParameters;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              iceParameters = _ref2.iceParameters;
              logger.debug('restartIce()');
              if (!this._closed) {
                _context3.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (iceParameters) {
                _context3.n = 2;
                break;
              }
              throw new TypeError('missing iceParameters');
            case 2:
              return _context3.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
                return _regenerator().w(function (_context2) {
                  while (1) switch (_context2.n) {
                    case 0:
                      _context2.n = 1;
                      return _this3._handler.restartIce(iceParameters);
                    case 1:
                      return _context2.a(2, _context2.v);
                  }
                }, _callee2);
              })), 'transport.restartIce()'));
          }
        }, _callee3, this);
      }));
      function restartIce(_x) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
    /**
     * Update ICE servers.
     */
    )
  }, {
    key: "updateIceServers",
    value: (function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var _this4 = this;
        var _ref4,
          iceServers,
          _args5 = arguments;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _ref4 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, iceServers = _ref4.iceServers;
              logger.debug('updateIceServers()');
              if (!this._closed) {
                _context5.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (Array.isArray(iceServers)) {
                _context5.n = 2;
                break;
              }
              throw new TypeError('missing iceServers');
            case 2:
              return _context5.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
                return _regenerator().w(function (_context4) {
                  while (1) switch (_context4.n) {
                    case 0:
                      return _context4.a(2, _this4._handler.updateIceServers(iceServers));
                  }
                }, _callee4);
              })), 'transport.updateIceServers()'));
          }
        }, _callee5, this);
      }));
      function updateIceServers() {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
    /**
     * Create a Producer.
     */
    )
  }, {
    key: "produce",
    value: (function () {
      var _produce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
        var _this5 = this;
        var _ref6,
          track,
          encodings,
          codecOptions,
          codec,
          _ref6$stopTracks,
          stopTracks,
          _ref6$disableTrackOnP,
          disableTrackOnPause,
          _ref6$zeroRtpOnPause,
          zeroRtpOnPause,
          onRtpSender,
          _ref6$appData,
          appData,
          _args7 = arguments;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              _ref6 = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {}, track = _ref6.track, encodings = _ref6.encodings, codecOptions = _ref6.codecOptions, codec = _ref6.codec, _ref6$stopTracks = _ref6.stopTracks, stopTracks = _ref6$stopTracks === void 0 ? true : _ref6$stopTracks, _ref6$disableTrackOnP = _ref6.disableTrackOnPause, disableTrackOnPause = _ref6$disableTrackOnP === void 0 ? true : _ref6$disableTrackOnP, _ref6$zeroRtpOnPause = _ref6.zeroRtpOnPause, zeroRtpOnPause = _ref6$zeroRtpOnPause === void 0 ? false : _ref6$zeroRtpOnPause, onRtpSender = _ref6.onRtpSender, _ref6$appData = _ref6.appData, appData = _ref6$appData === void 0 ? {} : _ref6$appData;
              logger.debug('produce() [track:%o]', track);
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (track) {
                _context7.n = 2;
                break;
              }
              throw new TypeError('missing track');
            case 2:
              if (!(this._direction !== 'send')) {
                _context7.n = 3;
                break;
              }
              throw new errors_1.UnsupportedError('not a sending Transport');
            case 3:
              if (this._canProduceByKind[track.kind]) {
                _context7.n = 4;
                break;
              }
              throw new errors_1.UnsupportedError("cannot produce ".concat(track.kind));
            case 4:
              if (!(track.readyState === 'ended')) {
                _context7.n = 5;
                break;
              }
              throw new errors_1.InvalidStateError('track ended');
            case 5:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context7.n = 6;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 6:
              if (!(this.listenerCount('produce') === 0)) {
                _context7.n = 7;
                break;
              }
              throw new TypeError('no "produce" listener set into this transport');
            case 7:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context7.n = 8;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 8:
              return _context7.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
                var normalizedEncodings, _yield$_this5$_handle, localId, rtpParameters, rtpSender, _yield$Promise, id, producer, _t;
                return _regenerator().w(function (_context6) {
                  while (1) switch (_context6.p = _context6.n) {
                    case 0:
                      if (!(encodings && !Array.isArray(encodings))) {
                        _context6.n = 1;
                        break;
                      }
                      throw TypeError('encodings must be an array');
                    case 1:
                      if (encodings && encodings.length === 0) {
                        normalizedEncodings = undefined;
                      } else if (encodings) {
                        normalizedEncodings = encodings.map(function (encoding) {
                          var normalizedEncoding = {
                            active: true
                          };
                          if (encoding.active === false) {
                            normalizedEncoding.active = false;
                          }
                          if (typeof encoding.dtx === 'boolean') {
                            normalizedEncoding.dtx = encoding.dtx;
                          }
                          if (typeof encoding.scalabilityMode === 'string') {
                            normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                          }
                          if (typeof encoding.scaleResolutionDownBy === 'number') {
                            normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                          }
                          if (typeof encoding.maxBitrate === 'number') {
                            normalizedEncoding.maxBitrate = encoding.maxBitrate;
                          }
                          if (typeof encoding.maxFramerate === 'number') {
                            normalizedEncoding.maxFramerate = encoding.maxFramerate;
                          }
                          if (typeof encoding.adaptivePtime === 'boolean') {
                            normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                          }
                          if (typeof encoding.priority === 'string') {
                            normalizedEncoding.priority = encoding.priority;
                          }
                          if (typeof encoding.networkPriority === 'string') {
                            normalizedEncoding.networkPriority = encoding.networkPriority;
                          }
                          return normalizedEncoding;
                        });
                      }
                    case 2:
                      _context6.n = 3;
                      return _this5._handler.send({
                        track: track,
                        encodings: normalizedEncodings,
                        codecOptions: codecOptions,
                        codec: codec,
                        onRtpSender: onRtpSender
                      });
                    case 3:
                      _yield$_this5$_handle = _context6.v;
                      localId = _yield$_this5$_handle.localId;
                      rtpParameters = _yield$_this5$_handle.rtpParameters;
                      rtpSender = _yield$_this5$_handle.rtpSender;
                      _context6.p = 4;
                      // This will fill rtpParameters's missing fields with default values.
                      ortc.validateAndNormalizeRtpParameters(rtpParameters);
                      _context6.n = 5;
                      return new Promise(function (resolve, reject) {
                        _this5.safeEmit('produce', {
                          kind: track.kind,
                          rtpParameters: rtpParameters,
                          appData: appData
                        }, resolve, reject);
                      });
                    case 5:
                      _yield$Promise = _context6.v;
                      id = _yield$Promise.id;
                      producer = new Producer_1.Producer({
                        id: id,
                        localId: localId,
                        rtpSender: rtpSender,
                        track: track,
                        rtpParameters: rtpParameters,
                        stopTracks: stopTracks,
                        disableTrackOnPause: disableTrackOnPause,
                        zeroRtpOnPause: zeroRtpOnPause,
                        appData: appData
                      });
                      _this5._producers.set(producer.id, producer);
                      _this5.handleProducer(producer);
                      // Emit observer event.
                      _this5._observer.safeEmit('newproducer', producer);
                      return _context6.a(2, producer);
                    case 6:
                      _context6.p = 6;
                      _t = _context6.v;
                      _this5._handler.stopSending(localId)["catch"](function () {});
                      throw _t;
                    case 7:
                      return _context6.a(2);
                  }
                }, _callee6, null, [[4, 6]]);
              })), 'transport.produce()')
              // This catch is needed to stop the given track if the command above
              // failed due to closed Transport.
              ["catch"](function (error) {
                if (stopTracks) {
                  try {
                    track.stop();
                  } catch (error2) {}
                }
                throw error;
              }));
          }
        }, _callee7, this);
      }));
      function produce() {
        return _produce.apply(this, arguments);
      }
      return produce;
    }()
    /**
     * Create a Consumer to consume a remote Producer.
     */
    )
  }, {
    key: "consume",
    value: (function () {
      var _consume = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(_ref8) {
        var _this6 = this;
        var id, producerId, kind, rtpParameters, streamId, onRtpReceiver, _ref8$appData, appData, clonedRtpParameters, canConsume, consumerCreationTask;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              id = _ref8.id, producerId = _ref8.producerId, kind = _ref8.kind, rtpParameters = _ref8.rtpParameters, streamId = _ref8.streamId, onRtpReceiver = _ref8.onRtpReceiver, _ref8$appData = _ref8.appData, appData = _ref8$appData === void 0 ? {} : _ref8$appData;
              logger.debug('consume()');
              if (!this._closed) {
                _context8.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(this._direction !== 'recv')) {
                _context8.n = 2;
                break;
              }
              throw new errors_1.UnsupportedError('not a receiving Transport');
            case 2:
              if (!(typeof id !== 'string')) {
                _context8.n = 3;
                break;
              }
              throw new TypeError('missing id');
            case 3:
              if (!(typeof producerId !== 'string')) {
                _context8.n = 4;
                break;
              }
              throw new TypeError('missing producerId');
            case 4:
              if (!(kind !== 'audio' && kind !== 'video')) {
                _context8.n = 5;
                break;
              }
              throw new TypeError("invalid kind '".concat(kind, "'"));
            case 5:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context8.n = 6;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 6:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context8.n = 7;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 7:
              // Clone given RTP parameters to not modify input data.
              clonedRtpParameters = utils.clone(rtpParameters); // Ensure the device can consume it.
              canConsume = ortc.canReceive(clonedRtpParameters, this._recvRtpCapabilities);
              if (canConsume) {
                _context8.n = 8;
                break;
              }
              throw new errors_1.UnsupportedError('cannot consume this Producer');
            case 8:
              consumerCreationTask = new ConsumerCreationTask({
                id: id,
                producerId: producerId,
                kind: kind,
                rtpParameters: clonedRtpParameters,
                streamId: streamId,
                onRtpReceiver: onRtpReceiver,
                appData: appData
              }); // Store the Consumer creation task.
              this._pendingConsumerTasks.push(consumerCreationTask);
              // There is no Consumer creation in progress, create it now.
              queueMicrotask(function () {
                if (_this6._closed) {
                  return;
                }
                if (_this6._consumerCreationInProgress === false) {
                  _this6.createPendingConsumers();
                }
              });
              return _context8.a(2, consumerCreationTask.promise);
          }
        }, _callee8, this);
      }));
      function consume(_x2) {
        return _consume.apply(this, arguments);
      }
      return consume;
    }()
    /**
     * Create a DataProducer
     */
    )
  }, {
    key: "produceData",
    value: (function () {
      var _produceData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {
        var _this7 = this;
        var _ref9,
          _ref9$ordered,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          _ref9$label,
          label,
          _ref9$protocol,
          protocol,
          _ref9$appData,
          appData,
          _args0 = arguments;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              _ref9 = _args0.length > 0 && _args0[0] !== undefined ? _args0[0] : {}, _ref9$ordered = _ref9.ordered, ordered = _ref9$ordered === void 0 ? true : _ref9$ordered, maxPacketLifeTime = _ref9.maxPacketLifeTime, maxRetransmits = _ref9.maxRetransmits, _ref9$label = _ref9.label, label = _ref9$label === void 0 ? '' : _ref9$label, _ref9$protocol = _ref9.protocol, protocol = _ref9$protocol === void 0 ? '' : _ref9$protocol, _ref9$appData = _ref9.appData, appData = _ref9$appData === void 0 ? {} : _ref9$appData;
              logger.debug('produceData()');
              if (!this._closed) {
                _context0.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(this._direction !== 'send')) {
                _context0.n = 2;
                break;
              }
              throw new errors_1.UnsupportedError('not a sending Transport');
            case 2:
              if (this._maxSctpMessageSize) {
                _context0.n = 3;
                break;
              }
              throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
            case 3:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context0.n = 4;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 4:
              if (!(this.listenerCount('producedata') === 0)) {
                _context0.n = 5;
                break;
              }
              throw new TypeError('no "producedata" listener set into this transport');
            case 5:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context0.n = 6;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 6:
              if (maxPacketLifeTime || maxRetransmits) {
                ordered = false;
              }
              // Enqueue command.
              return _context0.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
                var _yield$_this7$_handle, dataChannel, sctpStreamParameters, _yield$Promise2, id, dataProducer;
                return _regenerator().w(function (_context9) {
                  while (1) switch (_context9.n) {
                    case 0:
                      _context9.n = 1;
                      return _this7._handler.sendDataChannel({
                        ordered: ordered,
                        maxPacketLifeTime: maxPacketLifeTime,
                        maxRetransmits: maxRetransmits,
                        label: label,
                        protocol: protocol
                      });
                    case 1:
                      _yield$_this7$_handle = _context9.v;
                      dataChannel = _yield$_this7$_handle.dataChannel;
                      sctpStreamParameters = _yield$_this7$_handle.sctpStreamParameters;
                      // This will fill sctpStreamParameters's missing fields with default values.
                      ortc.validateAndNormalizeSctpStreamParameters(sctpStreamParameters);
                      _context9.n = 2;
                      return new Promise(function (resolve, reject) {
                        _this7.safeEmit('producedata', {
                          sctpStreamParameters: sctpStreamParameters,
                          label: label,
                          protocol: protocol,
                          appData: appData
                        }, resolve, reject);
                      });
                    case 2:
                      _yield$Promise2 = _context9.v;
                      id = _yield$Promise2.id;
                      dataProducer = new DataProducer_1.DataProducer({
                        id: id,
                        dataChannel: dataChannel,
                        sctpStreamParameters: sctpStreamParameters,
                        appData: appData
                      });
                      _this7._dataProducers.set(dataProducer.id, dataProducer);
                      _this7.handleDataProducer(dataProducer);
                      // Emit observer event.
                      _this7._observer.safeEmit('newdataproducer', dataProducer);
                      return _context9.a(2, dataProducer);
                  }
                }, _callee9);
              })), 'transport.produceData()'));
          }
        }, _callee0, this);
      }));
      function produceData() {
        return _produceData.apply(this, arguments);
      }
      return produceData;
    }()
    /**
     * Create a DataConsumer
     */
    )
  }, {
    key: "consumeData",
    value: (function () {
      var _consumeData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref1) {
        var _this8 = this;
        var id, dataProducerId, sctpStreamParameters, _ref1$label, label, _ref1$protocol, protocol, _ref1$appData, appData, clonedSctpStreamParameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              id = _ref1.id, dataProducerId = _ref1.dataProducerId, sctpStreamParameters = _ref1.sctpStreamParameters, _ref1$label = _ref1.label, label = _ref1$label === void 0 ? '' : _ref1$label, _ref1$protocol = _ref1.protocol, protocol = _ref1$protocol === void 0 ? '' : _ref1$protocol, _ref1$appData = _ref1.appData, appData = _ref1$appData === void 0 ? {} : _ref1$appData;
              logger.debug('consumeData()');
              if (!this._closed) {
                _context10.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(this._direction !== 'recv')) {
                _context10.n = 2;
                break;
              }
              throw new errors_1.UnsupportedError('not a receiving Transport');
            case 2:
              if (this._maxSctpMessageSize) {
                _context10.n = 3;
                break;
              }
              throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
            case 3:
              if (!(typeof id !== 'string')) {
                _context10.n = 4;
                break;
              }
              throw new TypeError('missing id');
            case 4:
              if (!(typeof dataProducerId !== 'string')) {
                _context10.n = 5;
                break;
              }
              throw new TypeError('missing dataProducerId');
            case 5:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context10.n = 6;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 6:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context10.n = 7;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 7:
              // Clone given SCTP stream parameters to not modify input data.
              clonedSctpStreamParameters = utils.clone(sctpStreamParameters); // This may throw.
              ortc.validateAndNormalizeSctpStreamParameters(clonedSctpStreamParameters);
              // Enqueue command.
              return _context10.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1() {
                var _yield$_this8$_handle, dataChannel, dataConsumer;
                return _regenerator().w(function (_context1) {
                  while (1) switch (_context1.n) {
                    case 0:
                      _context1.n = 1;
                      return _this8._handler.receiveDataChannel({
                        sctpStreamParameters: clonedSctpStreamParameters,
                        label: label,
                        protocol: protocol
                      });
                    case 1:
                      _yield$_this8$_handle = _context1.v;
                      dataChannel = _yield$_this8$_handle.dataChannel;
                      dataConsumer = new DataConsumer_1.DataConsumer({
                        id: id,
                        dataProducerId: dataProducerId,
                        dataChannel: dataChannel,
                        sctpStreamParameters: clonedSctpStreamParameters,
                        appData: appData
                      });
                      _this8._dataConsumers.set(dataConsumer.id, dataConsumer);
                      _this8.handleDataConsumer(dataConsumer);
                      // Emit observer event.
                      _this8._observer.safeEmit('newdataconsumer', dataConsumer);
                      return _context1.a(2, dataConsumer);
                  }
                }, _callee1);
              })), 'transport.consumeData()'));
          }
        }, _callee10, this);
      }));
      function consumeData(_x3) {
        return _consumeData.apply(this, arguments);
      }
      return consumeData;
    }() // This method is guaranteed to never throw.
    )
  }, {
    key: "createPendingConsumers",
    value: function createPendingConsumers() {
      var _this9 = this;
      this._consumerCreationInProgress = true;
      this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
        var pendingConsumerTasks, videoConsumerForProbator, optionsList, _iterator5, _step5, _task2, _task2$consumerOption, _id, _kind, _rtpParameters, streamId, onRtpReceiver, results, idx, task, result, _task$consumerOptions, id, producerId, kind, rtpParameters, appData, localId, rtpReceiver, track, consumer, _iterator6, _step6, _task, probatorRtpParameters, _t2, _t3;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              if (!(_this9._pendingConsumerTasks.length === 0)) {
                _context11.n = 1;
                break;
              }
              logger.debug('createPendingConsumers() | there is no Consumer to be created');
              return _context11.a(2);
            case 1:
              pendingConsumerTasks = _toConsumableArray(_this9._pendingConsumerTasks); // Clear pending Consumer tasks.
              _this9._pendingConsumerTasks = [];
              // Video Consumer in order to create the probator.
              videoConsumerForProbator = undefined; // Fill options list.
              optionsList = [];
              _iterator5 = _createForOfIteratorHelper(pendingConsumerTasks);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  _task2 = _step5.value;
                  _task2$consumerOption = _task2.consumerOptions, _id = _task2$consumerOption.id, _kind = _task2$consumerOption.kind, _rtpParameters = _task2$consumerOption.rtpParameters, streamId = _task2$consumerOption.streamId, onRtpReceiver = _task2$consumerOption.onRtpReceiver;
                  optionsList.push({
                    trackId: _id,
                    kind: _kind,
                    rtpParameters: _rtpParameters,
                    streamId: streamId,
                    onRtpReceiver: onRtpReceiver
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              _context11.p = 2;
              _context11.n = 3;
              return _this9._handler.receive(optionsList);
            case 3:
              results = _context11.v;
              for (idx = 0; idx < results.length; ++idx) {
                task = pendingConsumerTasks[idx];
                result = results[idx];
                _task$consumerOptions = task.consumerOptions, id = _task$consumerOptions.id, producerId = _task$consumerOptions.producerId, kind = _task$consumerOptions.kind, rtpParameters = _task$consumerOptions.rtpParameters, appData = _task$consumerOptions.appData;
                localId = result.localId, rtpReceiver = result.rtpReceiver, track = result.track;
                consumer = new Consumer_1.Consumer({
                  id: id,
                  localId: localId,
                  producerId: producerId,
                  rtpReceiver: rtpReceiver,
                  track: track,
                  rtpParameters: rtpParameters,
                  appData: appData
                });
                _this9._consumers.set(consumer.id, consumer);
                _this9.handleConsumer(consumer);
                // If this is the first video Consumer and the Consumer for RTP probation
                // has not yet been created, it's time to create it.
                if (!_this9._probatorConsumerCreated && !videoConsumerForProbator && kind === 'video') {
                  videoConsumerForProbator = consumer;
                }
                // Emit observer event.
                _this9._observer.safeEmit('newconsumer', consumer);
                task.resolve(consumer);
              }
              _context11.n = 5;
              break;
            case 4:
              _context11.p = 4;
              _t2 = _context11.v;
              _iterator6 = _createForOfIteratorHelper(pendingConsumerTasks);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _task = _step6.value;
                  _task.reject(_t2);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 5:
              if (!videoConsumerForProbator) {
                _context11.n = 9;
                break;
              }
              _context11.p = 6;
              probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
              _context11.n = 7;
              return _this9._handler.receive([{
                trackId: 'probator',
                kind: 'video',
                rtpParameters: probatorRtpParameters
              }]);
            case 7:
              logger.debug('createPendingConsumers() | Consumer for RTP probation created');
              _this9._probatorConsumerCreated = true;
              _context11.n = 9;
              break;
            case 8:
              _context11.p = 8;
              _t3 = _context11.v;
              logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', _t3);
            case 9:
              return _context11.a(2);
          }
        }, _callee11, null, [[6, 8], [2, 4]]);
      })), 'transport.createPendingConsumers()').then(function () {
        _this9._consumerCreationInProgress = false;
        // There are pending Consumer tasks, enqueue their creation.
        if (_this9._pendingConsumerTasks.length > 0) {
          _this9.createPendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "pausePendingConsumers",
    value: function pausePendingConsumers() {
      var _this0 = this;
      this._consumerPauseInProgress = true;
      this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {
        var pendingPauseConsumers, localIds, _t4;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.p = _context12.n) {
            case 0:
              if (!(_this0._pendingPauseConsumers.size === 0)) {
                _context12.n = 1;
                break;
              }
              logger.debug('pausePendingConsumers() | there is no Consumer to be paused');
              return _context12.a(2);
            case 1:
              pendingPauseConsumers = Array.from(_this0._pendingPauseConsumers.values()); // Clear pending pause Consumer map.
              _this0._pendingPauseConsumers.clear();
              _context12.p = 2;
              localIds = pendingPauseConsumers.map(function (consumer) {
                return consumer.localId;
              });
              _context12.n = 3;
              return _this0._handler.pauseReceiving(localIds);
            case 3:
              _context12.n = 5;
              break;
            case 4:
              _context12.p = 4;
              _t4 = _context12.v;
              logger.error('pausePendingConsumers() | failed to pause Consumers:', _t4);
            case 5:
              return _context12.a(2);
          }
        }, _callee12, null, [[2, 4]]);
      })), 'transport.pausePendingConsumers').then(function () {
        _this0._consumerPauseInProgress = false;
        // There are pending Consumers to be paused, do it.
        if (_this0._pendingPauseConsumers.size > 0) {
          _this0.pausePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "resumePendingConsumers",
    value: function resumePendingConsumers() {
      var _this1 = this;
      this._consumerResumeInProgress = true;
      this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13() {
        var pendingResumeConsumers, localIds, _t5;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.p = _context13.n) {
            case 0:
              if (!(_this1._pendingResumeConsumers.size === 0)) {
                _context13.n = 1;
                break;
              }
              logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');
              return _context13.a(2);
            case 1:
              pendingResumeConsumers = Array.from(_this1._pendingResumeConsumers.values()); // Clear pending resume Consumer map.
              _this1._pendingResumeConsumers.clear();
              _context13.p = 2;
              localIds = pendingResumeConsumers.map(function (consumer) {
                return consumer.localId;
              });
              _context13.n = 3;
              return _this1._handler.resumeReceiving(localIds);
            case 3:
              _context13.n = 5;
              break;
            case 4:
              _context13.p = 4;
              _t5 = _context13.v;
              logger.error('resumePendingConsumers() | failed to resume Consumers:', _t5);
            case 5:
              return _context13.a(2);
          }
        }, _callee13, null, [[2, 4]]);
      })), 'transport.resumePendingConsumers').then(function () {
        _this1._consumerResumeInProgress = false;
        // There are pending Consumer to be resumed, do it.
        if (_this1._pendingResumeConsumers.size > 0) {
          _this1.resumePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "closePendingConsumers",
    value: function closePendingConsumers() {
      var _this10 = this;
      this._consumerCloseInProgress = true;
      this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14() {
        var pendingCloseConsumers, _t6;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              if (!(_this10._pendingCloseConsumers.size === 0)) {
                _context14.n = 1;
                break;
              }
              logger.debug('closePendingConsumers() | there is no Consumer to be closed');
              return _context14.a(2);
            case 1:
              pendingCloseConsumers = Array.from(_this10._pendingCloseConsumers.values()); // Clear pending close Consumer map.
              _this10._pendingCloseConsumers.clear();
              _context14.p = 2;
              _context14.n = 3;
              return _this10._handler.stopReceiving(pendingCloseConsumers.map(function (consumer) {
                return consumer.localId;
              }));
            case 3:
              _context14.n = 5;
              break;
            case 4:
              _context14.p = 4;
              _t6 = _context14.v;
              logger.error('closePendingConsumers() | failed to close Consumers:', _t6);
            case 5:
              return _context14.a(2);
          }
        }, _callee14, null, [[2, 4]]);
      })), 'transport.closePendingConsumers').then(function () {
        _this10._consumerCloseInProgress = false;
        // There are pending Consumer to be resumed, do it.
        if (_this10._pendingCloseConsumers.size > 0) {
          _this10.closePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "handleHandler",
    value: function handleHandler() {
      var _this11 = this;
      var handler = this._handler;
      handler.on('@connect', function (_ref15, callback, errback) {
        var dtlsParameters = _ref15.dtlsParameters;
        if (_this11._closed) {
          errback(new errors_1.InvalidStateError('closed'));
          return;
        }
        _this11.safeEmit('connect', {
          dtlsParameters: dtlsParameters
        }, callback, errback);
      });
      handler.on('@icegatheringstatechange', function (iceGatheringState) {
        if (iceGatheringState === _this11._iceGatheringState) {
          return;
        }
        logger.debug('ICE gathering state changed to %s', iceGatheringState);
        _this11._iceGatheringState = iceGatheringState;
        if (!_this11._closed) {
          _this11.safeEmit('icegatheringstatechange', iceGatheringState);
        }
      });
      handler.on('@icecandidateerror', function (event) {
        logger.warn("ICE candidate error [url:".concat(event.url, ", localAddress:").concat(event.address, ", localPort:").concat(event.port, "]: ").concat(event.errorCode, " \"").concat(event.errorText, "\""));
        _this11.safeEmit('icecandidateerror', event);
      });
      handler.on('@connectionstatechange', function (connectionState) {
        if (connectionState === _this11._connectionState) {
          return;
        }
        logger.debug('connection state changed to %s', connectionState);
        _this11._connectionState = connectionState;
        if (!_this11._closed) {
          _this11.safeEmit('connectionstatechange', connectionState);
        }
      });
    }
  }, {
    key: "handleProducer",
    value: function handleProducer(producer) {
      var _this12 = this;
      producer.on('@close', function () {
        _this12._producers["delete"](producer.id);
        if (_this12._closed) {
          return;
        }
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {
          return _regenerator().w(function (_context15) {
            while (1) switch (_context15.n) {
              case 0:
                _context15.n = 1;
                return _this12._handler.stopSending(producer.localId);
              case 1:
                return _context15.a(2, _context15.v);
            }
          }, _callee15);
        })), 'producer @close event')["catch"](function (error) {
          return logger.warn('producer.close() failed:%o', error);
        });
      });
      producer.on('@pause', function (callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16() {
          return _regenerator().w(function (_context16) {
            while (1) switch (_context16.n) {
              case 0:
                _context16.n = 1;
                return _this12._handler.pauseSending(producer.localId);
              case 1:
                return _context16.a(2, _context16.v);
            }
          }, _callee16);
        })), 'producer @pause event').then(callback)["catch"](errback);
      });
      producer.on('@resume', function (callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17() {
          return _regenerator().w(function (_context17) {
            while (1) switch (_context17.n) {
              case 0:
                _context17.n = 1;
                return _this12._handler.resumeSending(producer.localId);
              case 1:
                return _context17.a(2, _context17.v);
            }
          }, _callee17);
        })), 'producer @resume event').then(callback)["catch"](errback);
      });
      producer.on('@replacetrack', function (track, callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
          return _regenerator().w(function (_context18) {
            while (1) switch (_context18.n) {
              case 0:
                _context18.n = 1;
                return _this12._handler.replaceTrack(producer.localId, track);
              case 1:
                return _context18.a(2, _context18.v);
            }
          }, _callee18);
        })), 'producer @replacetrack event').then(callback)["catch"](errback);
      });
      producer.on('@setmaxspatiallayer', function (spatialLayer, callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
          return _regenerator().w(function (_context19) {
            while (1) switch (_context19.n) {
              case 0:
                _context19.n = 1;
                return _this12._handler.setMaxSpatialLayer(producer.localId, spatialLayer);
              case 1:
                return _context19.a(2, _context19.v);
            }
          }, _callee19);
        })), 'producer @setmaxspatiallayer event').then(callback)["catch"](errback);
      });
      producer.on('@setrtpencodingparameters', function (params, callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20() {
          return _regenerator().w(function (_context20) {
            while (1) switch (_context20.n) {
              case 0:
                _context20.n = 1;
                return _this12._handler.setRtpEncodingParameters(producer.localId, params);
              case 1:
                return _context20.a(2, _context20.v);
            }
          }, _callee20);
        })), 'producer @setrtpencodingparameters event').then(callback)["catch"](errback);
      });
      producer.on('@getstats', function (callback, errback) {
        if (_this12._closed) {
          return errback(new errors_1.InvalidStateError('closed'));
        }
        _this12._handler.getSenderStats(producer.localId).then(callback)["catch"](errback);
      });
    }
  }, {
    key: "handleConsumer",
    value: function handleConsumer(consumer) {
      var _this13 = this;
      consumer.on('@close', function () {
        _this13._consumers["delete"](consumer.id);
        _this13._pendingPauseConsumers["delete"](consumer.id);
        _this13._pendingResumeConsumers["delete"](consumer.id);
        if (_this13._closed) {
          return;
        }
        // Store the Consumer into the close list.
        _this13._pendingCloseConsumers.set(consumer.id, consumer);
        // There is no Consumer close in progress, do it now.
        if (_this13._consumerCloseInProgress === false) {
          _this13.closePendingConsumers();
        }
      });
      consumer.on('@pause', function () {
        // If Consumer is pending to be resumed, remove from pending resume list.
        if (_this13._pendingResumeConsumers.has(consumer.id)) {
          _this13._pendingResumeConsumers["delete"](consumer.id);
        }
        // Store the Consumer into the pending list.
        _this13._pendingPauseConsumers.set(consumer.id, consumer);
        // There is no Consumer pause in progress, do it now.
        queueMicrotask(function () {
          if (_this13._closed) {
            return;
          }
          if (_this13._consumerPauseInProgress === false) {
            _this13.pausePendingConsumers();
          }
        });
      });
      consumer.on('@resume', function () {
        // If Consumer is pending to be paused, remove from pending pause list.
        if (_this13._pendingPauseConsumers.has(consumer.id)) {
          _this13._pendingPauseConsumers["delete"](consumer.id);
        }
        // Store the Consumer into the pending list.
        _this13._pendingResumeConsumers.set(consumer.id, consumer);
        // There is no Consumer resume in progress, do it now.
        queueMicrotask(function () {
          if (_this13._closed) {
            return;
          }
          if (_this13._consumerResumeInProgress === false) {
            _this13.resumePendingConsumers();
          }
        });
      });
      consumer.on('@getstats', function (callback, errback) {
        if (_this13._closed) {
          return errback(new errors_1.InvalidStateError('closed'));
        }
        _this13._handler.getReceiverStats(consumer.localId).then(callback)["catch"](errback);
      });
    }
  }, {
    key: "handleDataProducer",
    value: function handleDataProducer(dataProducer) {
      var _this14 = this;
      dataProducer.on('@close', function () {
        _this14._dataProducers["delete"](dataProducer.id);
      });
    }
  }, {
    key: "handleDataConsumer",
    value: function handleDataConsumer(dataConsumer) {
      var _this15 = this;
      dataConsumer.on('@close', function () {
        _this15._dataConsumers["delete"](dataConsumer.id);
      });
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Transport = Transport;

},{"./Consumer":15,"./DataConsumer":16,"./DataProducer":17,"./Logger":19,"./Producer":20,"./enhancedEvents":22,"./errors":23,"./ortc":37,"./utils":41,"awaitqueue":5}],22:[function(require,module,exports){
"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnhancedEventEmitter = void 0;
var events_alias_1 = require("events-alias");
var Logger_1 = require("./Logger");
var enhancedEventEmitterLogger = new Logger_1.Logger('EnhancedEventEmitter');
var EnhancedEventEmitter = /*#__PURE__*/function (_events_alias_1$Event) {
  function EnhancedEventEmitter() {
    var _this;
    _classCallCheck(this, EnhancedEventEmitter);
    _this = _callSuper(this, EnhancedEventEmitter);
    _this.setMaxListeners(Infinity);
    return _this;
  }
  /**
   * Empties all stored event listeners.
   */
  _inherits(EnhancedEventEmitter, _events_alias_1$Event);
  return _createClass(EnhancedEventEmitter, [{
    key: "close",
    value: function close() {
      _superPropGet(EnhancedEventEmitter, "removeAllListeners", this, 3)([]);
    }
  }, {
    key: "emit",
    value: function emit(eventName) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return _superPropGet(EnhancedEventEmitter, "emit", this, 3)([eventName].concat(args));
    }
    /**
     * Special addition to the EventEmitter API.
     */
  }, {
    key: "safeEmit",
    value: function safeEmit(eventName) {
      try {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return _superPropGet(EnhancedEventEmitter, "emit", this, 3)([eventName].concat(args));
      } catch (error) {
        enhancedEventEmitterLogger.error('safeEmit() | event listener threw an error [eventName:%s]:%o', eventName, error);
        try {
          _superPropGet(EnhancedEventEmitter, "emit", this, 3)(['listenererror', eventName, error]);
        } catch (error2) {
          // Ignore it.
        }
        return Boolean(_superPropGet(EnhancedEventEmitter, "listenerCount", this, 3)([eventName]));
      }
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "on", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "off",
    value: function off(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "off", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "addListener",
    value: function addListener(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "on", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "prependListener",
    value: function prependListener(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "prependListener", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "once",
    value: function once(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "once", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "prependOnceListener",
    value: function prependOnceListener(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "prependOnceListener", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "off", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(eventName) {
      _superPropGet(EnhancedEventEmitter, "removeAllListeners", this, 3)([eventName]);
      return this;
    }
  }, {
    key: "listenerCount",
    value: function listenerCount(eventName) {
      return _superPropGet(EnhancedEventEmitter, "listenerCount", this, 3)([eventName]);
    }
  }, {
    key: "listeners",
    value: function listeners(eventName) {
      return _superPropGet(EnhancedEventEmitter, "listeners", this, 3)([eventName]);
    }
  }, {
    key: "rawListeners",
    value: function rawListeners(eventName) {
      return _superPropGet(EnhancedEventEmitter, "rawListeners", this, 3)([eventName]);
    }
  }]);
}(events_alias_1.EventEmitter);
exports.EnhancedEventEmitter = EnhancedEventEmitter;

},{"./Logger":19,"events-alias":8}],23:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */
var UnsupportedError = /*#__PURE__*/function (_Error) {
  function UnsupportedError(message) {
    var _this;
    _classCallCheck(this, UnsupportedError);
    _this = _callSuper(this, UnsupportedError, [message]);
    _this.name = 'UnsupportedError';
    if (Error.hasOwnProperty('captureStackTrace')) {
      Error.captureStackTrace(_this, UnsupportedError);
    } else {
      _this.stack = new Error(message).stack;
    }
    return _this;
  }
  _inherits(UnsupportedError, _Error);
  return _createClass(UnsupportedError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */
var InvalidStateError = /*#__PURE__*/function (_Error2) {
  function InvalidStateError(message) {
    var _this2;
    _classCallCheck(this, InvalidStateError);
    _this2 = _callSuper(this, InvalidStateError, [message]);
    _this2.name = 'InvalidStateError';
    if (Error.hasOwnProperty('captureStackTrace')) {
      // Just in V8.
      Error.captureStackTrace(_this2, InvalidStateError);
    } else {
      _this2.stack = new Error(message).stack;
    }
    return _this2;
  }
  _inherits(InvalidStateError, _Error2);
  return _createClass(InvalidStateError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.InvalidStateError = InvalidStateError;

},{}],24:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome111 = void 0;
var sdpTransform = require("sdp-transform");
var enhancedEvents_1 = require("../enhancedEvents");
var Logger_1 = require("../Logger");
var ortc = require("../ortc");
var errors_1 = require("../errors");
var scalabilityModes_1 = require("../scalabilityModes");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var ortcUtils = require("./ortc/utils");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var logger = new Logger_1.Logger('Chrome111');
var NAME = 'Chrome111';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome111 = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Chrome111(_ref) {
    var _this;
    var direction = _ref.direction,
      iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      iceServers = _ref.iceServers,
      iceTransportPolicy = _ref.iceTransportPolicy,
      additionalSettings = _ref.additionalSettings,
      getSendExtendedRtpCapabilities = _ref.getSendExtendedRtpCapabilities;
    _classCallCheck(this, Chrome111);
    _this = _callSuper(this, Chrome111);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Callback to request sending extended RTP capabilities on demand.
    _defineProperty(_this, "_getSendExtendedRtpCapabilities", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    _defineProperty(_this, "onIceGatheringStateChange", function () {
      _this.emit('@icegatheringstatechange', _this._pc.iceGatheringState);
    });
    _defineProperty(_this, "onIceCandidateError", function (event) {
      _this.emit('@icecandidateerror', event);
    });
    _defineProperty(_this, "onConnectionStateChange", function () {
      _this.emit('@connectionstatechange', _this._pc.connectionState);
    });
    _defineProperty(_this, "onIceConnectionStateChange", function () {
      switch (_this._pc.iceConnectionState) {
        case 'checking':
          {
            _this.emit('@connectionstatechange', 'connecting');
            break;
          }
        case 'connected':
        case 'completed':
          {
            _this.emit('@connectionstatechange', 'connected');
            break;
          }
        case 'failed':
          {
            _this.emit('@connectionstatechange', 'failed');
            break;
          }
        case 'disconnected':
          {
            _this.emit('@connectionstatechange', 'disconnected');
            break;
          }
        case 'closed':
          {
            _this.emit('@connectionstatechange', 'closed');
            break;
          }
      }
    });
    logger.debug('constructor()');
    _this._direction = direction;
    _this._remoteSdp = new RemoteSdp_1.RemoteSdp({
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      sctpParameters: sctpParameters
    });
    _this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
    if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
      _this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
    }
    _this._pc = new RTCPeerConnection(_objectSpread({
      iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
      iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    }, additionalSettings));
    _this._pc.addEventListener('icegatheringstatechange', _this.onIceGatheringStateChange);
    _this._pc.addEventListener('icecandidateerror', _this.onIceCandidateError);
    if (_this._pc.connectionState) {
      _this._pc.addEventListener('connectionstatechange', _this.onConnectionStateChange);
    } else {
      logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
      _this._pc.addEventListener('iceconnectionstatechange', _this.onIceConnectionStateChange);
    }
    return _this;
  }
  _inherits(Chrome111, _enhancedEvents_1$Enh);
  return _createClass(Chrome111, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      try {
        this._pc.close();
      } catch (error) {}
      this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
      this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
      this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
      this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
      this.emit('@close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(Chrome111, "close", this, 3)([]);
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(iceServers) {
        var configuration;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context2.n = 5;
                break;
              }
              _context2.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context2.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context2.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context2.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context2.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context2.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context2.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              return _context3.a(2, this._pc.getStats());
          }
        }, _callee3, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref2) {
        var track, encodings, codecOptions, codec, onRtpSender, maxTemporalLayers, _iterator, _step, encoding, temporalLayers, mediaSectionIdx, transceiver, offer, localSdpObject, nativeRtpCapabilities, sendExtendedRtpCapabilities, sendingRtpParameters, sendingRemoteRtpParameters, _this$_forcedLocalDtl, localId, offerMediaObject, newEncodings, answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec, onRtpSender = _ref2.onRtpSender;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                // Set rid and verify scalabilityMode in each encoding.
                // NOTE: Even if WebRTC allows different scalabilityMode (different number
                // of temporal layers) per simulcast stream, we need that those are the
                // same in all them, so let's pick up the highest value.
                // NOTE: If scalabilityMode is not given, Chrome will use L1T3.
                maxTemporalLayers = 1;
                _iterator = _createForOfIteratorHelper(encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
                    if (temporalLayers > maxTemporalLayers) {
                      maxTemporalLayers = temporalLayers;
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                  encoding.scalabilityMode = "L1T".concat(maxTemporalLayers);
                });
              }
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              if (onRtpSender) {
                onRtpSender(transceiver.sender);
              }
              _context4.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context4.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              nativeRtpCapabilities = Chrome111.getLocalRtpCapabilities(localSdpObject);
              sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities); // Generic sending RTP parameters.
              sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              // Generic sending RTP parameters suitable for the SDP remote answer.
              sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              if (this._transportReady) {
                _context4.n = 2;
                break;
              }
              _context4.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx]; // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context4.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee4, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context5.n = 2;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context5.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context5.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context5.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context5.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context6.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context6.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context6.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              this._remoteSdp.resumeSendingMediaSection(localId);
              if (transceiver) {
                _context7.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context8.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context9.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context9.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context9.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context0.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context0.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context0.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context0.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context0.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId) {
        var transceiver;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context1.a(2, transceiver.sender.getStats());
          }
        }, _callee1, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context10.n = 5;
                break;
              }
              _context10.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context10.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context10.n = 2;
                break;
              }
              _context10.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context10.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee10, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(optionsList) {
        var _this2 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, _iterator3, _step3, _loop, answer, localSdpObject, _iterator4, _step4, _loop2, _this$_forcedLocalDtl3, _iterator5, _step5, _loop3, _t, _t2, _t3;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context14.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context14.p = 2;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, onRtpReceiver, _localId, transceiver;
                return _regenerator().w(function (_context11) {
                  while (1) switch (_context11.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, onRtpReceiver = options.onRtpReceiver;
                      if (!onRtpReceiver) {
                        _context11.n = 2;
                        break;
                      }
                      _localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === _localId;
                      });
                      if (transceiver) {
                        _context11.n = 1;
                        break;
                      }
                      throw new Error('transceiver not found');
                    case 1:
                      onRtpReceiver(transceiver.receiver);
                    case 2:
                      return _context11.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context14.n = 5;
                break;
              }
              return _context14.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context14.n = 3;
              break;
            case 5:
              _context14.n = 7;
              break;
            case 6:
              _context14.p = 6;
              _t = _context14.v;
              _iterator3.e(_t);
            case 7:
              _context14.p = 7;
              _iterator3.f();
              return _context14.f(7);
            case 8:
              _context14.n = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context14.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context14.p = 10;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context12) {
                  while (1) switch (_context12.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context12.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 11:
              if ((_step4 = _iterator4.n()).done) {
                _context14.n = 13;
                break;
              }
              return _context14.d(_regeneratorValues(_loop2()), 12);
            case 12:
              _context14.n = 11;
              break;
            case 13:
              _context14.n = 15;
              break;
            case 14:
              _context14.p = 14;
              _t2 = _context14.v;
              _iterator4.e(_t2);
            case 15:
              _context14.p = 15;
              _iterator4.f();
              return _context14.f(15);
            case 16:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context14.n = 17;
                break;
              }
              _context14.n = 17;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context14.n = 18;
              return this._pc.setLocalDescription(answer);
            case 18:
              _iterator5 = _createForOfIteratorHelper(optionsList);
              _context14.p = 19;
              _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step5.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context13.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this2._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context13.a(2);
                  }
                }, _loop3);
              });
              _iterator5.s();
            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context14.n = 22;
                break;
              }
              return _context14.d(_regeneratorValues(_loop3()), 21);
            case 21:
              _context14.n = 20;
              break;
            case 22:
              _context14.n = 24;
              break;
            case 23:
              _context14.p = 23;
              _t3 = _context14.v;
              _iterator5.e(_t3);
            case 24:
              _context14.p = 24;
              _iterator5.f();
              return _context14.f(24);
            case 25:
              return _context14.a(2, results);
          }
        }, _callee11, this, [[19, 23, 24, 25], [10, 14, 15, 16], [2, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(localIds) {
        var _iterator6, _step6, localId, transceiver, offer, answer, _iterator7, _step7, _localId2, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.p = _context15.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context15.n = 1;
                break;
              }
              return _context15.a(2);
            case 1:
              _iterator6 = _createForOfIteratorHelper(localIds);
              _context15.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context15.n = 6;
                break;
              }
              localId = _step6.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context15.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context15.n = 3;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t4 = _context15.v;
              _iterator6.e(_t4);
            case 8:
              _context15.p = 8;
              _iterator6.f();
              return _context15.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context15.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context15.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator7 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _localId2 = _step7.value;
                  this._mapMidTransceiver["delete"](_localId2);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            case 13:
              return _context15.a(2);
          }
        }, _callee12, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t5;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.p = _context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context16.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context16.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context16.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context16.n = 2;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t5 = _context16.v;
              _iterator8.e(_t5);
            case 7:
              _context16.p = 7;
              _iterator8.f();
              return _context16.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context16.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context16.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context16.a(2);
          }
        }, _callee13, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator9, _step9, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.p = _context17.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator9 = _createForOfIteratorHelper(localIds);
              _context17.p = 1;
              _iterator9.s();
            case 2:
              if ((_step9 = _iterator9.n()).done) {
                _context17.n = 5;
                break;
              }
              localId = _step9.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context17.n = 2;
              break;
            case 5:
              _context17.n = 7;
              break;
            case 6:
              _context17.p = 6;
              _t6 = _context17.v;
              _iterator9.e(_t6);
            case 7:
              _context17.p = 7;
              _iterator9.f();
              return _context17.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context17.a(2);
          }
        }, _callee14, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localId) {
        var transceiver;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context18.a(2, transceiver.receiver.getStats());
          }
        }, _callee15, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context19.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context19.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context19.v;
              if (this._transportReady) {
                _context19.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context19.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context19.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context19.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee16, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(_ref5) {
        var _this3 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context20.n = 1;
              return new Promise(function (resolve, reject) {
                _this3.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context20.a(2);
          }
        }, _callee17, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return {
        name: NAME,
        factory: function factory(options) {
          return new Chrome111(options);
        },
        getNativeRtpCapabilities: function () {
          var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
            var pc, offer, sdpObject, nativeRtpCapabilities, _pc, _t7;
            return _regenerator().w(function (_context21) {
              while (1) switch (_context21.p = _context21.n) {
                case 0:
                  logger.debug('getNativeRtpCapabilities()');
                  pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                  });
                  _context21.p = 1;
                  pc.addTransceiver('audio');
                  // Create video transceiver with scalability mode in order to retrieve
                  // Dependency Descriptor header extension.
                  pc.addTransceiver('video', {
                    sendEncodings: [{
                      scalabilityMode: 'L3T3'
                    }]
                  });
                  _context21.n = 2;
                  return pc.createOffer();
                case 2:
                  offer = _context21.v;
                  try {
                    pc.close();
                  } catch (error) {}
                  pc = undefined;
                  sdpObject = sdpTransform.parse(offer.sdp);
                  nativeRtpCapabilities = Chrome111.getLocalRtpCapabilities(sdpObject);
                  return _context21.a(2, nativeRtpCapabilities);
                case 3:
                  _context21.p = 3;
                  _t7 = _context21.v;
                  try {
                    (_pc = pc) === null || _pc === void 0 || _pc.close();
                  } catch (error2) {}
                  pc = undefined;
                  throw _t7;
                case 4:
                  return _context21.a(2);
              }
            }, _callee18, null, [[1, 3]]);
          }));
          function getNativeRtpCapabilities() {
            return _getNativeRtpCapabilities.apply(this, arguments);
          }
          return getNativeRtpCapabilities;
        }(),
        getNativeSctpCapabilities: function () {
          var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
            return _regenerator().w(function (_context22) {
              while (1) switch (_context22.n) {
                case 0:
                  logger.debug('getNativeSctpCapabilities()');
                  return _context22.a(2, {
                    numStreams: SCTP_NUM_STREAMS
                  });
              }
            }, _callee19);
          }));
          function getNativeSctpCapabilities() {
            return _getNativeSctpCapabilities.apply(this, arguments);
          }
          return getNativeSctpCapabilities;
        }()
      };
    }
  }, {
    key: "getLocalRtpCapabilities",
    value: function getLocalRtpCapabilities(localSdpObject) {
      var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      // Need to validate and normalize native RTP capabilities.
      ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      // libwebrtc supports NACK for OPUS but doesn't announce it.
      ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Chrome111 = Chrome111;

},{"../Logger":19,"../enhancedEvents":22,"../errors":23,"../ortc":37,"../scalabilityModes":38,"./ortc/utils":31,"./sdp/RemoteSdp":33,"./sdp/commonUtils":34,"./sdp/unifiedPlanUtils":35,"sdp-transform":45}],25:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome74 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var enhancedEvents_1 = require("../enhancedEvents");
var ortc = require("../ortc");
var errors_1 = require("../errors");
var scalabilityModes_1 = require("../scalabilityModes");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var ortcUtils = require("./ortc/utils");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var logger = new Logger_1.Logger('Chrome74');
var NAME = 'Chrome74';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome74 = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Chrome74(_ref) {
    var _this;
    var direction = _ref.direction,
      iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      iceServers = _ref.iceServers,
      iceTransportPolicy = _ref.iceTransportPolicy,
      additionalSettings = _ref.additionalSettings,
      getSendExtendedRtpCapabilities = _ref.getSendExtendedRtpCapabilities;
    _classCallCheck(this, Chrome74);
    _this = _callSuper(this, Chrome74);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Callback to request sending extended RTP capabilities on demand.
    _defineProperty(_this, "_getSendExtendedRtpCapabilities", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    _defineProperty(_this, "onIceGatheringStateChange", function () {
      _this.emit('@icegatheringstatechange', _this._pc.iceGatheringState);
    });
    _defineProperty(_this, "onIceCandidateError", function (event) {
      _this.emit('@icecandidateerror', event);
    });
    _defineProperty(_this, "onConnectionStateChange", function () {
      _this.emit('@connectionstatechange', _this._pc.connectionState);
    });
    _defineProperty(_this, "onIceConnectionStateChange", function () {
      switch (_this._pc.iceConnectionState) {
        case 'checking':
          {
            _this.emit('@connectionstatechange', 'connecting');
            break;
          }
        case 'connected':
        case 'completed':
          {
            _this.emit('@connectionstatechange', 'connected');
            break;
          }
        case 'failed':
          {
            _this.emit('@connectionstatechange', 'failed');
            break;
          }
        case 'disconnected':
          {
            _this.emit('@connectionstatechange', 'disconnected');
            break;
          }
        case 'closed':
          {
            _this.emit('@connectionstatechange', 'closed');
            break;
          }
      }
    });
    logger.debug('constructor()');
    _this._direction = direction;
    _this._remoteSdp = new RemoteSdp_1.RemoteSdp({
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      sctpParameters: sctpParameters
    });
    _this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
    if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
      _this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
    }
    _this._pc = new RTCPeerConnection(_objectSpread({
      iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
      iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    }, additionalSettings));
    _this._pc.addEventListener('icegatheringstatechange', _this.onIceGatheringStateChange);
    _this._pc.addEventListener('icecandidateerror', _this.onIceCandidateError);
    if (_this._pc.connectionState) {
      _this._pc.addEventListener('connectionstatechange', _this.onConnectionStateChange);
    } else {
      logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
      _this._pc.addEventListener('iceconnectionstatechange', _this.onIceConnectionStateChange);
    }
    return _this;
  }
  _inherits(Chrome74, _enhancedEvents_1$Enh);
  return _createClass(Chrome74, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      try {
        this._pc.close();
      } catch (error) {}
      this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
      this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
      this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
      this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
      this.emit('@close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(Chrome74, "close", this, 3)([]);
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(iceServers) {
        var configuration;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context2.n = 5;
                break;
              }
              _context2.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context2.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context2.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context2.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context2.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context2.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context2.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              return _context3.a(2, this._pc.getStats());
          }
        }, _callee3, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref2) {
        var track, encodings, codecOptions, codec, mediaSectionIdx, transceiver, offer, localSdpObject, nativeRtpCapabilities, sendExtendedRtpCapabilities, sendingRtpParameters, sendingRemoteRtpParameters, _this$_forcedLocalDtl, hackVp9Svc, layers, offerMediaObject, localId, newEncodings, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
              }
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              _context4.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context4.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              nativeRtpCapabilities = Chrome74.getLocalRtpCapabilities(localSdpObject);
              sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities); // Generic sending RTP parameters.
              sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              // Generic sending RTP parameters suitable for the SDP remote answer.
              sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              if (this._transportReady) {
                _context4.n = 2;
                break;
              }
              _context4.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              // Special case for VP9 with SVC.
              hackVp9Svc = false;
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
                logger.debug('send() | enabling legacy simulcast for VP9 SVC');
                hackVp9Svc = true;
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: layers.spatialLayers
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                // Hack for VP9 SVC.
                if (hackVp9Svc) {
                  newEncodings = [newEncodings[0]];
                }
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context4.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee4, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context5.n = 2;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context5.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context5.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context5.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context5.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context6.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context6.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context6.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              this._remoteSdp.resumeSendingMediaSection(localId);
              if (transceiver) {
                _context7.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context8.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context9.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context9.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context9.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context0.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context0.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context0.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context0.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context0.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId) {
        var transceiver;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context1.a(2, transceiver.sender.getStats());
          }
        }, _callee1, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context10.n = 5;
                break;
              }
              _context10.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context10.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context10.n = 2;
                break;
              }
              _context10.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context10.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee10, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(optionsList) {
        var _this2 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _this$_forcedLocalDtl3, _iterator4, _step4, _loop2, _t, _t2;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.p = _context13.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context13.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context13.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context13.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context13.p = 3;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context11) {
                  while (1) switch (_context11.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context11.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context13.n = 6;
                break;
              }
              return _context13.d(_regeneratorValues(_loop()), 5);
            case 5:
              _context13.n = 4;
              break;
            case 6:
              _context13.n = 8;
              break;
            case 7:
              _context13.p = 7;
              _t = _context13.v;
              _iterator3.e(_t);
            case 8:
              _context13.p = 8;
              _iterator3.f();
              return _context13.f(8);
            case 9:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context13.n = 10;
                break;
              }
              _context13.n = 10;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 10:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context13.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context13.p = 12;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context12) {
                  while (1) switch (_context12.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context12.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this2._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context12.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 13:
              if ((_step4 = _iterator4.n()).done) {
                _context13.n = 15;
                break;
              }
              return _context13.d(_regeneratorValues(_loop2()), 14);
            case 14:
              _context13.n = 13;
              break;
            case 15:
              _context13.n = 17;
              break;
            case 16:
              _context13.p = 16;
              _t2 = _context13.v;
              _iterator4.e(_t2);
            case 17:
              _context13.p = 17;
              _iterator4.f();
              return _context13.f(17);
            case 18:
              return _context13.a(2, results);
          }
        }, _callee11, this, [[12, 16, 17, 18], [3, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId, _t3;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context14.n = 1;
                break;
              }
              return _context14.a(2);
            case 1:
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context14.p = 2;
              _iterator5.s();
            case 3:
              if ((_step5 = _iterator5.n()).done) {
                _context14.n = 6;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context14.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context14.n = 3;
              break;
            case 6:
              _context14.n = 8;
              break;
            case 7:
              _context14.p = 7;
              _t3 = _context14.v;
              _iterator5.e(_t3);
            case 8:
              _context14.p = 8;
              _iterator5.f();
              return _context14.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context14.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context14.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context14.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context14.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 13:
              return _context14.a(2);
          }
        }, _callee12, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(localIds) {
        var _iterator7, _step7, localId, transceiver, offer, answer, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.p = _context15.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context15.p = 1;
              _iterator7.s();
            case 2:
              if ((_step7 = _iterator7.n()).done) {
                _context15.n = 5;
                break;
              }
              localId = _step7.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context15.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context15.n = 2;
              break;
            case 5:
              _context15.n = 7;
              break;
            case 6:
              _context15.p = 6;
              _t4 = _context15.v;
              _iterator7.e(_t4);
            case 7:
              _context15.p = 7;
              _iterator7.f();
              return _context15.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context15.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context15.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context15.a(2);
          }
        }, _callee13, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t5;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.p = _context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context16.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context16.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context16.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context16.n = 2;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t5 = _context16.v;
              _iterator8.e(_t5);
            case 7:
              _context16.p = 7;
              _iterator8.f();
              return _context16.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context16.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context16.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context16.a(2);
          }
        }, _callee14, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localId) {
        var transceiver;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context17.a(2, transceiver.receiver.getStats());
          }
        }, _callee15, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context18.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context18.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context18.v;
              if (this._transportReady) {
                _context18.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context18.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context18.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context18.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee16, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(_ref5) {
        var _this3 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context19.n = 1;
              return new Promise(function (resolve, reject) {
                _this3.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context19.a(2);
          }
        }, _callee17, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return {
        name: NAME,
        factory: function factory(options) {
          return new Chrome74(options);
        },
        getNativeRtpCapabilities: function () {
          var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
            var pc, offer, sdpObject, nativeRtpCapabilities, _pc, _t6;
            return _regenerator().w(function (_context20) {
              while (1) switch (_context20.p = _context20.n) {
                case 0:
                  logger.debug('getNativeRtpCapabilities()');
                  pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                  });
                  _context20.p = 1;
                  pc.addTransceiver('audio');
                  pc.addTransceiver('video');
                  _context20.n = 2;
                  return pc.createOffer();
                case 2:
                  offer = _context20.v;
                  try {
                    pc.close();
                  } catch (error) {}
                  pc = undefined;
                  sdpObject = sdpTransform.parse(offer.sdp);
                  nativeRtpCapabilities = Chrome74.getLocalRtpCapabilities(sdpObject);
                  return _context20.a(2, nativeRtpCapabilities);
                case 3:
                  _context20.p = 3;
                  _t6 = _context20.v;
                  try {
                    (_pc = pc) === null || _pc === void 0 || _pc.close();
                  } catch (error2) {}
                  pc = undefined;
                  throw _t6;
                case 4:
                  return _context20.a(2);
              }
            }, _callee18, null, [[1, 3]]);
          }));
          function getNativeRtpCapabilities() {
            return _getNativeRtpCapabilities.apply(this, arguments);
          }
          return getNativeRtpCapabilities;
        }(),
        getNativeSctpCapabilities: function () {
          var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
            return _regenerator().w(function (_context21) {
              while (1) switch (_context21.n) {
                case 0:
                  logger.debug('getNativeSctpCapabilities()');
                  return _context21.a(2, {
                    numStreams: SCTP_NUM_STREAMS
                  });
              }
            }, _callee19);
          }));
          function getNativeSctpCapabilities() {
            return _getNativeSctpCapabilities.apply(this, arguments);
          }
          return getNativeSctpCapabilities;
        }()
      };
    }
  }, {
    key: "getLocalRtpCapabilities",
    value: function getLocalRtpCapabilities(localSdpObject) {
      var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      // Need to validate and normalize native RTP capabilities.
      ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      // libwebrtc supports NACK for OPUS but doesn't announce it.
      ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Chrome74 = Chrome74;

},{"../Logger":19,"../enhancedEvents":22,"../errors":23,"../ortc":37,"../scalabilityModes":38,"./ortc/utils":31,"./sdp/RemoteSdp":33,"./sdp/commonUtils":34,"./sdp/unifiedPlanUtils":35,"sdp-transform":45}],26:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeHandler = void 0;
var fake_mediastreamtrack_1 = require("fake-mediastreamtrack");
var enhancedEvents_1 = require("../enhancedEvents");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var errors_1 = require("../errors");
var FakeEventTarget_1 = require("./fakeEvents/FakeEventTarget");
var logger = new Logger_1.Logger('FakeHandler');
var NAME = 'FakeHandler';
var FakeHandler = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function FakeHandler(_ref, fakeParameters) {
    var _this;
    var getSendExtendedRtpCapabilities = _ref.getSendExtendedRtpCapabilities;
    _classCallCheck(this, FakeHandler);
    _this = _callSuper(this, FakeHandler);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Fake parameters source of RTP and SCTP parameters and capabilities.
    _defineProperty(_this, "_fakeParameters", void 0);
    // Callback to request sending extended RTP capabilities on demand.
    _defineProperty(_this, "_getSendExtendedRtpCapabilities", void 0);
    // Local RTCP CNAME.
    _defineProperty(_this, "_cname", "CNAME-".concat(utils.generateRandomNumber()));
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    // Next localId.
    _defineProperty(_this, "_nextLocalId", 1);
    // Sending and receiving tracks indexed by localId.
    _defineProperty(_this, "_tracks", new Map());
    // DataChannel id value counter. It must be incremented for each new DataChannel.
    _defineProperty(_this, "_nextSctpStreamId", 0);
    logger.debug('constructor()');
    _this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
    _this._fakeParameters = fakeParameters;
    return _this;
  }
  _inherits(FakeHandler, _enhancedEvents_1$Enh);
  return _createClass(FakeHandler, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(FakeHandler, "close", this, 3)([]);
    }
    // NOTE: Custom method for simulation purposes.
  }, {
    key: "setIceGatheringState",
    value: function setIceGatheringState(iceGatheringState) {
      this.emit('@icegatheringstatechange', iceGatheringState);
    }
    // NOTE: Custom method for simulation purposes.
  }, {
    key: "setConnectionState",
    value: function setConnectionState(connectionState) {
      this.emit('@connectionstatechange', connectionState);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(iceServers) {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(iceParameters) {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
            case 1:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              return _context3.a(2, new Map());
          }
        }, _callee3, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(// eslint-disable-next-line @typescript-eslint/no-unused-vars
      _ref2) {
        var track, encodings, codecOptions, codec, nativeRtpCapabilities, sendExtendedRtpCapabilities, sendingRtpParameters, useRtx, _iterator, _step, encoding, localId;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertNotClosed();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              _context4.n = 1;
              return this.setupTransport({
                localDtlsRole: 'server'
              });
            case 1:
              nativeRtpCapabilities = FakeHandler.getLocalRtpCapabilities(this._fakeParameters);
              sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities); // Generic sending RTP parameters.
              sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              useRtx = sendingRtpParameters.codecs.some(function (_codec) {
                return /.+\/rtx$/i.test(_codec.mimeType);
              });
              sendingRtpParameters.mid = "mid-".concat(utils.generateRandomNumber());
              if (!encodings) {
                encodings = [{}];
              }
              _iterator = _createForOfIteratorHelper(encodings);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  encoding = _step.value;
                  encoding.ssrc = utils.generateRandomNumber();
                  if (useRtx) {
                    encoding.rtx = {
                      ssrc: utils.generateRandomNumber()
                    };
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              sendingRtpParameters.encodings = encodings;
              // Fill RTCRtpParameters.rtcp.
              sendingRtpParameters.rtcp = {
                cname: this._cname,
                reducedSize: true,
                mux: true
              };
              localId = this._nextLocalId++;
              this._tracks.set(localId, track);
              return _context4.a(2, {
                localId: String(localId),
                rtpParameters: sendingRtpParameters
              });
          }
        }, _callee4, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(localId) {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              if (this._tracks.has(Number(localId))) {
                _context5.n = 2;
                break;
              }
              throw new Error('local track not found');
            case 2:
              this._tracks["delete"](Number(localId));
            case 3:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(localId) {
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              this.assertNotClosed();
              // Unimplemented.
            case 1:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertNotClosed();
              // Unimplemented.
            case 1:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId, track) {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              this._tracks["delete"](Number(localId));
              this._tracks.set(Number(localId), track);
            case 1:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId, spatialLayer) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
            case 1:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, params) {
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
            case 1:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId) {
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              return _context1.a(2, new Map());
          }
        }, _callee1, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, dataChannel, sctpStreamParameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              if (this._transportReady) {
                _context10.n = 1;
                break;
              }
              _context10.n = 1;
              return this.setupTransport({
                localDtlsRole: 'server'
              });
            case 1:
              logger.debug('sendDataChannel()');
              dataChannel = new FakeRTCDataChannel({
                id: this._nextSctpStreamId++,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                label: label,
                protocol: protocol
              });
              sctpStreamParameters = {
                streamId: this._nextSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits
              };
              return _context10.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee10, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(optionsList) {
        var results, _iterator2, _step2, options, trackId, kind, localId, track, _t;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              this.assertNotClosed();
              results = [];
              _iterator2 = _createForOfIteratorHelper(optionsList);
              _context11.p = 1;
              _iterator2.s();
            case 2:
              if ((_step2 = _iterator2.n()).done) {
                _context11.n = 5;
                break;
              }
              options = _step2.value;
              trackId = options.trackId, kind = options.kind;
              if (this._transportReady) {
                _context11.n = 3;
                break;
              }
              _context11.n = 3;
              return this.setupTransport({
                localDtlsRole: 'client'
              });
            case 3:
              logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
              localId = this._nextLocalId++;
              track = new fake_mediastreamtrack_1.FakeMediaStreamTrack({
                kind: kind
              });
              this._tracks.set(localId, track);
              results.push({
                localId: String(localId),
                track: track
              });
            case 4:
              _context11.n = 2;
              break;
            case 5:
              _context11.n = 7;
              break;
            case 6:
              _context11.p = 6;
              _t = _context11.v;
              _iterator2.e(_t);
            case 7:
              _context11.p = 7;
              _iterator2.f();
              return _context11.f(7);
            case 8:
              return _context11.a(2, results);
          }
        }, _callee11, this, [[1, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(localIds) {
        var _iterator3, _step3, localId;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              if (!this._closed) {
                _context12.n = 1;
                break;
              }
              return _context12.a(2);
            case 1:
              _iterator3 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  localId = _step3.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  this._tracks["delete"](Number(localId));
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            case 2:
              return _context12.a(2);
          }
        }, _callee12, this);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.n) {
            case 0:
              this.assertNotClosed();
              // Unimplemented.
            case 1:
              return _context13.a(2);
          }
        }, _callee13, this);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.n) {
            case 0:
              this.assertNotClosed();
              // Unimplemented.
            case 1:
              return _context14.a(2);
          }
        }, _callee14, this);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localId) {
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertNotClosed();
              return _context15.a(2, new Map());
          }
        }, _callee15, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(_ref4) {
        var sctpStreamParameters, label, protocol, dataChannel;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              if (this._transportReady) {
                _context16.n = 1;
                break;
              }
              _context16.n = 1;
              return this.setupTransport({
                localDtlsRole: 'client'
              });
            case 1:
              logger.debug('receiveDataChannel()');
              dataChannel = new FakeRTCDataChannel({
                id: sctpStreamParameters.streamId,
                ordered: sctpStreamParameters.ordered,
                maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime,
                maxRetransmits: sctpStreamParameters.maxRetransmits,
                label: label,
                protocol: protocol
              });
              return _context16.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee16, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(_ref5) {
        var _this2 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              dtlsParameters = utils.clone(this._fakeParameters.generateLocalDtlsParameters()); // Set our DTLS role.
              if (localDtlsRole) {
                dtlsParameters.role = localDtlsRole;
              }
              // Assume we are connecting now.
              this.emit('@connectionstatechange', 'connecting');
              // Need to tell the remote transport about our parameters.
              _context17.n = 1;
              return new Promise(function (resolve, reject) {
                return _this2.emit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context17.a(2);
          }
        }, _callee17, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory(fakeParameters) {
      return {
        name: NAME,
        factory: function factory(options) {
          return new FakeHandler(options, fakeParameters);
        },
        getNativeRtpCapabilities: function () {
          var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
            return _regenerator().w(function (_context18) {
              while (1) switch (_context18.n) {
                case 0:
                  logger.debug('getNativeRtpCapabilities()');
                  return _context18.a(2, FakeHandler.getLocalRtpCapabilities(fakeParameters));
              }
            }, _callee18);
          }));
          function getNativeRtpCapabilities() {
            return _getNativeRtpCapabilities.apply(this, arguments);
          }
          return getNativeRtpCapabilities;
        }(),
        getNativeSctpCapabilities: function () {
          var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
            return _regenerator().w(function (_context19) {
              while (1) switch (_context19.n) {
                case 0:
                  logger.debug('getNativeSctpCapabilities()');
                  return _context19.a(2, fakeParameters.generateNativeSctpCapabilities());
              }
            }, _callee19);
          }));
          function getNativeSctpCapabilities() {
            return _getNativeSctpCapabilities.apply(this, arguments);
          }
          return getNativeSctpCapabilities;
        }()
      };
    }
  }, {
    key: "getLocalRtpCapabilities",
    value: function getLocalRtpCapabilities(fakeParameters) {
      var nativeRtpCapabilities = fakeParameters.generateNativeRtpCapabilities();
      // Need to validate and normalize native RTP capabilities.
      ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.FakeHandler = FakeHandler;
/**
 * @remarks
 * - We use a custom FakeEventTarget class because Hermes JS engine in
 *   React-Native doesn't implement EventListener.
 */
var FakeRTCDataChannel = /*#__PURE__*/function (_FakeEventTarget_1$Fa) {
  function FakeRTCDataChannel(_ref6) {
    var _this3;
    var id = _ref6.id,
      _ref6$ordered = _ref6.ordered,
      ordered = _ref6$ordered === void 0 ? true : _ref6$ordered,
      _ref6$maxPacketLifeTi = _ref6.maxPacketLifeTime,
      maxPacketLifeTime = _ref6$maxPacketLifeTi === void 0 ? null : _ref6$maxPacketLifeTi,
      _ref6$maxRetransmits = _ref6.maxRetransmits,
      maxRetransmits = _ref6$maxRetransmits === void 0 ? null : _ref6$maxRetransmits,
      _ref6$label = _ref6.label,
      label = _ref6$label === void 0 ? '' : _ref6$label,
      _ref6$protocol = _ref6.protocol,
      protocol = _ref6$protocol === void 0 ? '' : _ref6$protocol;
    _classCallCheck(this, FakeRTCDataChannel);
    _this3 = _callSuper(this, FakeRTCDataChannel);
    // Members for RTCDataChannel standard public getters/setters.
    _defineProperty(_this3, "_id", void 0);
    _defineProperty(_this3, "_negotiated", true);
    // mediasoup just uses negotiated DataChannels.
    _defineProperty(_this3, "_ordered", void 0);
    _defineProperty(_this3, "_maxPacketLifeTime", void 0);
    _defineProperty(_this3, "_maxRetransmits", void 0);
    _defineProperty(_this3, "_label", void 0);
    _defineProperty(_this3, "_protocol", void 0);
    _defineProperty(_this3, "_readyState", 'connecting');
    _defineProperty(_this3, "_bufferedAmount", 0);
    _defineProperty(_this3, "_bufferedAmountLowThreshold", 0);
    _defineProperty(_this3, "_binaryType", 'arraybuffer');
    // Events.
    _defineProperty(_this3, "_onopen", null);
    _defineProperty(_this3, "_onclosing", null);
    _defineProperty(_this3, "_onclose", null);
    _defineProperty(_this3, "_onmessage", null);
    _defineProperty(_this3, "_onbufferedamountlow", null);
    _defineProperty(_this3, "_onerror", null);
    logger.debug("constructor() [id:".concat(id, ", ordered:").concat(ordered, ", maxPacketLifeTime:").concat(maxPacketLifeTime, ", maxRetransmits:").concat(maxRetransmits, ", label:").concat(label, ", protocol:").concat(protocol));
    _this3._id = id;
    _this3._ordered = ordered;
    _this3._maxPacketLifeTime = maxPacketLifeTime;
    _this3._maxRetransmits = maxRetransmits;
    _this3._label = label;
    _this3._protocol = protocol;
    return _this3;
  }
  _inherits(FakeRTCDataChannel, _FakeEventTarget_1$Fa);
  return _createClass(FakeRTCDataChannel, [{
    key: "id",
    get: function get() {
      return this._id;
    }
  }, {
    key: "negotiated",
    get: function get() {
      return this._negotiated;
    }
  }, {
    key: "ordered",
    get: function get() {
      return this._ordered;
    }
  }, {
    key: "maxPacketLifeTime",
    get: function get() {
      return this._maxPacketLifeTime;
    }
  }, {
    key: "maxRetransmits",
    get: function get() {
      return this._maxRetransmits;
    }
  }, {
    key: "label",
    get: function get() {
      return this._label;
    }
  }, {
    key: "protocol",
    get: function get() {
      return this._protocol;
    }
  }, {
    key: "readyState",
    get: function get() {
      return this._readyState;
    }
  }, {
    key: "bufferedAmount",
    get: function get() {
      return this._bufferedAmount;
    }
  }, {
    key: "bufferedAmountLowThreshold",
    get: function get() {
      return this._bufferedAmountLowThreshold;
    },
    set: function set(value) {
      this._bufferedAmountLowThreshold = value;
    }
  }, {
    key: "binaryType",
    get: function get() {
      return this._binaryType;
    },
    set: function set(binaryType) {
      this._binaryType = binaryType;
    }
  }, {
    key: "onopen",
    get: function get() {
      return this._onopen;
    },
    set: function set(handler) {
      if (this._onopen) {
        this.removeEventListener('open', this._onopen);
      }
      this._onopen = handler;
      if (handler) {
        this.addEventListener('open', handler);
      }
    }
  }, {
    key: "onclosing",
    get: function get() {
      return this._onclosing;
    },
    set: function set(handler) {
      if (this._onclosing) {
        this.removeEventListener('closing', this._onclosing);
      }
      this._onclosing = handler;
      if (handler) {
        this.addEventListener('closing', handler);
      }
    }
  }, {
    key: "onclose",
    get: function get() {
      return this._onclose;
    },
    set: function set(handler) {
      if (this._onclose) {
        this.removeEventListener('close', this._onclose);
      }
      this._onclose = handler;
      if (handler) {
        this.addEventListener('close', handler);
      }
    }
  }, {
    key: "onmessage",
    get: function get() {
      return this._onmessage;
    },
    set: function set(handler) {
      if (this._onmessage) {
        this.removeEventListener('message', this._onmessage);
      }
      this._onmessage = handler;
      if (handler) {
        this.addEventListener('message', handler);
      }
    }
  }, {
    key: "onbufferedamountlow",
    get: function get() {
      return this._onbufferedamountlow;
    },
    set: function set(handler) {
      if (this._onbufferedamountlow) {
        this.removeEventListener('bufferedamountlow', this._onbufferedamountlow);
      }
      this._onbufferedamountlow = handler;
      if (handler) {
        this.addEventListener('bufferedamountlow', handler);
      }
    }
  }, {
    key: "onerror",
    get: function get() {
      return this._onerror;
    },
    set: function set(handler) {
      if (this._onerror) {
        this.removeEventListener('error', this._onerror);
      }
      this._onerror = handler;
      if (handler) {
        this.addEventListener('error', handler);
      }
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      _superPropGet(FakeRTCDataChannel, "addEventListener", this, 3)([type, listener, options]);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      _superPropGet(FakeRTCDataChannel, "removeEventListener", this, 3)([type, listener, options]);
    }
  }, {
    key: "close",
    value: function close() {
      if (['closing', 'closed'].includes(this._readyState)) {
        return;
      }
      this._readyState = 'closed';
    }
    /**
     * We extend the definition of send() to allow Node Buffer. However
     * ArrayBufferView and Blob do not exist in Node.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "send",
    value: function send(data) {
      if (this._readyState !== 'open') {
        throw new errors_1.InvalidStateError('not open');
      }
    }
  }]);
}(FakeEventTarget_1.FakeEventTarget);

},{"../Logger":19,"../enhancedEvents":22,"../errors":23,"../ortc":37,"../utils":41,"./fakeEvents/FakeEventTarget":30,"fake-mediastreamtrack":11}],27:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Firefox120 = void 0;
var sdpTransform = require("sdp-transform");
var enhancedEvents_1 = require("../enhancedEvents");
var Logger_1 = require("../Logger");
var errors_1 = require("../errors");
var ortc = require("../ortc");
var scalabilityModes_1 = require("../scalabilityModes");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var logger = new Logger_1.Logger('Firefox120');
var NAME = 'Firefox120';
var SCTP_NUM_STREAMS = {
  OS: 16,
  MIS: 2048
};
var Firefox120 = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Firefox120(_ref) {
    var _this;
    var direction = _ref.direction,
      iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      iceServers = _ref.iceServers,
      iceTransportPolicy = _ref.iceTransportPolicy,
      additionalSettings = _ref.additionalSettings,
      getSendExtendedRtpCapabilities = _ref.getSendExtendedRtpCapabilities;
    _classCallCheck(this, Firefox120);
    _this = _callSuper(this, Firefox120);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Callback to request sending extended RTP capabilities on demand.
    _defineProperty(_this, "_getSendExtendedRtpCapabilities", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    _defineProperty(_this, "onIceGatheringStateChange", function () {
      _this.emit('@icegatheringstatechange', _this._pc.iceGatheringState);
    });
    _defineProperty(_this, "onIceCandidateError", function (event) {
      _this.emit('@icecandidateerror', event);
    });
    _defineProperty(_this, "onConnectionStateChange", function () {
      _this.emit('@connectionstatechange', _this._pc.connectionState);
    });
    _defineProperty(_this, "onIceConnectionStateChange", function () {
      switch (_this._pc.iceConnectionState) {
        case 'checking':
          {
            _this.emit('@connectionstatechange', 'connecting');
            break;
          }
        case 'connected':
        case 'completed':
          {
            _this.emit('@connectionstatechange', 'connected');
            break;
          }
        case 'failed':
          {
            _this.emit('@connectionstatechange', 'failed');
            break;
          }
        case 'disconnected':
          {
            _this.emit('@connectionstatechange', 'disconnected');
            break;
          }
        case 'closed':
          {
            _this.emit('@connectionstatechange', 'closed');
            break;
          }
      }
    });
    logger.debug('constructor()');
    _this._direction = direction;
    _this._remoteSdp = new RemoteSdp_1.RemoteSdp({
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      sctpParameters: sctpParameters
    });
    _this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
    _this._pc = new RTCPeerConnection(_objectSpread({
      iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
      iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    }, additionalSettings));
    _this._pc.addEventListener('icegatheringstatechange', _this.onIceGatheringStateChange);
    _this._pc.addEventListener('icecandidateerror', _this.onIceCandidateError);
    if (_this._pc.connectionState) {
      _this._pc.addEventListener('connectionstatechange', _this.onConnectionStateChange);
    } else {
      logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
      _this._pc.addEventListener('iceconnectionstatechange', _this.onIceConnectionStateChange);
    }
    return _this;
  }
  _inherits(Firefox120, _enhancedEvents_1$Enh);
  return _createClass(Firefox120, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      try {
        this._pc.close();
      } catch (error) {}
      this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
      this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
      this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
      this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
      this.emit('@close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(Firefox120, "close", this, 3)([]);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(iceServers) {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              this.assertNotClosed();
              // NOTE: Firefox does not implement pc.setConfiguration().
              throw new errors_1.UnsupportedError('not supported');
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context2.n = 5;
                break;
              }
              _context2.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context2.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context2.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context2.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context2.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context2.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context2.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              return _context3.a(2, this._pc.getStats());
          }
        }, _callee3, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref2) {
        var track, encodings, codecOptions, codec, onRtpSender, transceiver, offer, localSdpObject, nativeRtpCapabilities, sendExtendedRtpCapabilities, sendingRtpParameters, sendingRemoteRtpParameters, layers, localId, offerMediaObject, newEncodings, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec, onRtpSender = _ref2.onRtpSender;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
              }
              // NOTE: Firefox fails sometimes to properly anticipate the closed media
              // section that it should use, so don't reuse closed media sections.
              //   https://github.com/versatica/mediasoup-client/issues/104
              //
              // const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              if (onRtpSender) {
                onRtpSender(transceiver.sender);
              }
              _context4.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context4.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              nativeRtpCapabilities = Firefox120.getLocalRtpCapabilities(localSdpObject);
              sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities); // Generic sending RTP parameters.
              sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              // Generic sending RTP parameters suitable for the SDP remote answer.
              sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              // In Firefox use DTLS role client even if we are the "offerer" since
              // Firefox does not respect ICE-Lite.
              if (this._transportReady) {
                _context4.n = 2;
                break;
              }
              _context4.n = 2;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1]; // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context4.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee4, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context5.n = 2;
                break;
              }
              throw new Error('associated transceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              // NOTE: Cannot use stop() the transceiver due to the the note above in
              // send() method.
              // try
              // {
              // 	transceiver.stop();
              // }
              // catch (error)
              // {}
              this._pc.removeTrack(transceiver.sender);
              // NOTE: Cannot use closeMediaSection() due to the the note above in send()
              // method.
              // this._remoteSdp.closeMediaSection(transceiver.mid);
              this._remoteSdp.disableMediaSection(transceiver.mid);
              _context5.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context5.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context5.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context5.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context6.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context6.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context6.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              this._remoteSdp.resumeSendingMediaSection(localId);
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context8.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated transceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context9.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context9.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context9.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context0.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context0.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context0.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context0.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context0.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId) {
        var transceiver;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context1.a(2, transceiver.sender.getStats());
          }
        }, _callee1, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context10.n = 5;
                break;
              }
              _context10.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context10.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context10.n = 2;
                break;
              }
              _context10.n = 2;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context10.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee10, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(optionsList) {
        var _this2 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, _iterator3, _step3, _loop, answer, localSdpObject, _iterator4, _step4, _loop2, _iterator5, _step5, _loop3, _t, _t2, _t3;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context14.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context14.p = 2;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, onRtpReceiver, _localId, transceiver;
                return _regenerator().w(function (_context11) {
                  while (1) switch (_context11.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, onRtpReceiver = options.onRtpReceiver;
                      if (!onRtpReceiver) {
                        _context11.n = 2;
                        break;
                      }
                      _localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === _localId;
                      });
                      if (transceiver) {
                        _context11.n = 1;
                        break;
                      }
                      throw new Error('transceiver not found');
                    case 1:
                      onRtpReceiver(transceiver.receiver);
                    case 2:
                      return _context11.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context14.n = 5;
                break;
              }
              return _context14.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context14.n = 3;
              break;
            case 5:
              _context14.n = 7;
              break;
            case 6:
              _context14.p = 6;
              _t = _context14.v;
              _iterator3.e(_t);
            case 7:
              _context14.p = 7;
              _iterator3.f();
              return _context14.f(7);
            case 8:
              _context14.n = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context14.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context14.p = 10;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context12) {
                  while (1) switch (_context12.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                      answer = {
                        type: 'answer',
                        sdp: sdpTransform.write(localSdpObject)
                      };
                    case 1:
                      return _context12.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 11:
              if ((_step4 = _iterator4.n()).done) {
                _context14.n = 13;
                break;
              }
              return _context14.d(_regeneratorValues(_loop2()), 12);
            case 12:
              _context14.n = 11;
              break;
            case 13:
              _context14.n = 15;
              break;
            case 14:
              _context14.p = 14;
              _t2 = _context14.v;
              _iterator4.e(_t2);
            case 15:
              _context14.p = 15;
              _iterator4.f();
              return _context14.f(15);
            case 16:
              if (this._transportReady) {
                _context14.n = 17;
                break;
              }
              _context14.n = 17;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context14.n = 18;
              return this._pc.setLocalDescription(answer);
            case 18:
              _iterator5 = _createForOfIteratorHelper(optionsList);
              _context14.p = 19;
              _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step5.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context13.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this2._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context13.a(2);
                  }
                }, _loop3);
              });
              _iterator5.s();
            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context14.n = 22;
                break;
              }
              return _context14.d(_regeneratorValues(_loop3()), 21);
            case 21:
              _context14.n = 20;
              break;
            case 22:
              _context14.n = 24;
              break;
            case 23:
              _context14.p = 23;
              _t3 = _context14.v;
              _iterator5.e(_t3);
            case 24:
              _context14.p = 24;
              _iterator5.f();
              return _context14.f(24);
            case 25:
              return _context14.a(2, results);
          }
        }, _callee11, this, [[19, 23, 24, 25], [10, 14, 15, 16], [2, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(localIds) {
        var _iterator6, _step6, localId, transceiver, offer, answer, _iterator7, _step7, _localId2, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.p = _context15.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context15.n = 1;
                break;
              }
              return _context15.a(2);
            case 1:
              _iterator6 = _createForOfIteratorHelper(localIds);
              _context15.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context15.n = 6;
                break;
              }
              localId = _step6.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context15.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context15.n = 3;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t4 = _context15.v;
              _iterator6.e(_t4);
            case 8:
              _context15.p = 8;
              _iterator6.f();
              return _context15.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context15.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context15.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator7 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _localId2 = _step7.value;
                  this._mapMidTransceiver["delete"](_localId2);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            case 13:
              return _context15.a(2);
          }
        }, _callee12, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t5;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.p = _context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context16.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context16.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context16.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context16.n = 2;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t5 = _context16.v;
              _iterator8.e(_t5);
            case 7:
              _context16.p = 7;
              _iterator8.f();
              return _context16.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context16.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context16.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context16.a(2);
          }
        }, _callee13, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator9, _step9, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.p = _context17.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator9 = _createForOfIteratorHelper(localIds);
              _context17.p = 1;
              _iterator9.s();
            case 2:
              if ((_step9 = _iterator9.n()).done) {
                _context17.n = 5;
                break;
              }
              localId = _step9.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context17.n = 2;
              break;
            case 5:
              _context17.n = 7;
              break;
            case 6:
              _context17.p = 6;
              _t6 = _context17.v;
              _iterator9.e(_t6);
            case 7:
              _context17.p = 7;
              _iterator9.f();
              return _context17.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context17.a(2);
          }
        }, _callee14, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localId) {
        var transceiver;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context18.a(2, transceiver.receiver.getStats());
          }
        }, _callee15, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context19.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context19.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context19.v;
              if (this._transportReady) {
                _context19.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context19.n = 3;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context19.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context19.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee16, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(_ref5) {
        var _this3 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context20.n = 1;
              return new Promise(function (resolve, reject) {
                _this3.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context20.a(2);
          }
        }, _callee17, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return {
        name: NAME,
        factory: function factory(options) {
          return new Firefox120(options);
        },
        getNativeRtpCapabilities: function () {
          var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
            var pc, canvas, fakeStream, fakeVideoTrack, offer, sdpObject, nativeRtpCapabilities, _pc, _t7;
            return _regenerator().w(function (_context21) {
              while (1) switch (_context21.p = _context21.n) {
                case 0:
                  logger.debug('getNativeRtpCapabilities()');
                  pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                  }); // NOTE: We need to add a real video track to get the RID extension mapping,
                  // otherwiser Firefox doesn't include it in the SDP.
                  canvas = document.createElement('canvas'); // NOTE: Otherwise Firefox fails in next line.
                  canvas.getContext('2d');
                  fakeStream = canvas.captureStream();
                  fakeVideoTrack = fakeStream.getVideoTracks()[0];
                  _context21.p = 1;
                  pc.addTransceiver('audio', {
                    direction: 'sendrecv'
                  });
                  pc.addTransceiver(fakeVideoTrack, {
                    direction: 'sendrecv',
                    sendEncodings: [{
                      rid: 'r0',
                      maxBitrate: 100000
                    }, {
                      rid: 'r1',
                      maxBitrate: 500000
                    }]
                  });
                  _context21.n = 2;
                  return pc.createOffer();
                case 2:
                  offer = _context21.v;
                  try {
                    canvas.remove();
                  } catch (error) {}
                  try {
                    fakeVideoTrack.stop();
                  } catch (error) {}
                  try {
                    pc.close();
                  } catch (error) {}
                  pc = undefined;
                  sdpObject = sdpTransform.parse(offer.sdp);
                  nativeRtpCapabilities = Firefox120.getLocalRtpCapabilities(sdpObject);
                  return _context21.a(2, nativeRtpCapabilities);
                case 3:
                  _context21.p = 3;
                  _t7 = _context21.v;
                  try {
                    canvas.remove();
                  } catch (error2) {}
                  try {
                    fakeVideoTrack.stop();
                  } catch (error2) {}
                  try {
                    (_pc = pc) === null || _pc === void 0 || _pc.close();
                  } catch (error2) {}
                  pc = undefined;
                  throw _t7;
                case 4:
                  return _context21.a(2);
              }
            }, _callee18, null, [[1, 3]]);
          }));
          function getNativeRtpCapabilities() {
            return _getNativeRtpCapabilities.apply(this, arguments);
          }
          return getNativeRtpCapabilities;
        }(),
        getNativeSctpCapabilities: function () {
          var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
            return _regenerator().w(function (_context22) {
              while (1) switch (_context22.n) {
                case 0:
                  logger.debug('getNativeSctpCapabilities()');
                  return _context22.a(2, {
                    numStreams: SCTP_NUM_STREAMS
                  });
              }
            }, _callee19);
          }));
          function getNativeSctpCapabilities() {
            return _getNativeSctpCapabilities.apply(this, arguments);
          }
          return getNativeSctpCapabilities;
        }()
      };
    }
  }, {
    key: "getLocalRtpCapabilities",
    value: function getLocalRtpCapabilities(localSdpObject) {
      var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      // Need to validate and normalize native RTP capabilities.
      ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Firefox120 = Firefox120;

},{"../Logger":19,"../enhancedEvents":22,"../errors":23,"../ortc":37,"../scalabilityModes":38,"./sdp/RemoteSdp":33,"./sdp/commonUtils":34,"./sdp/unifiedPlanUtils":35,"sdp-transform":45}],28:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactNative106 = void 0;
var sdpTransform = require("sdp-transform");
var enhancedEvents_1 = require("../enhancedEvents");
var Logger_1 = require("../Logger");
var ortc = require("../ortc");
var errors_1 = require("../errors");
var scalabilityModes_1 = require("../scalabilityModes");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var ortcUtils = require("./ortc/utils");
var logger = new Logger_1.Logger('ReactNative106');
var NAME = 'ReactNative106';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var ReactNative106 = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function ReactNative106(_ref) {
    var _this;
    var direction = _ref.direction,
      iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      iceServers = _ref.iceServers,
      iceTransportPolicy = _ref.iceTransportPolicy,
      additionalSettings = _ref.additionalSettings,
      getSendExtendedRtpCapabilities = _ref.getSendExtendedRtpCapabilities;
    _classCallCheck(this, ReactNative106);
    _this = _callSuper(this, ReactNative106);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Callback to request sending extended RTP capabilities on demand.
    _defineProperty(_this, "_getSendExtendedRtpCapabilities", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    _defineProperty(_this, "onIceGatheringStateChange", function () {
      _this.emit('@icegatheringstatechange', _this._pc.iceGatheringState);
    });
    _defineProperty(_this, "onIceCandidateError", function (event) {
      _this.emit('@icecandidateerror', event);
    });
    _defineProperty(_this, "onConnectionStateChange", function () {
      _this.emit('@connectionstatechange', _this._pc.connectionState);
    });
    _defineProperty(_this, "onIceConnectionStateChange", function () {
      switch (_this._pc.iceConnectionState) {
        case 'checking':
          {
            _this.emit('@connectionstatechange', 'connecting');
            break;
          }
        case 'connected':
        case 'completed':
          {
            _this.emit('@connectionstatechange', 'connected');
            break;
          }
        case 'failed':
          {
            _this.emit('@connectionstatechange', 'failed');
            break;
          }
        case 'disconnected':
          {
            _this.emit('@connectionstatechange', 'disconnected');
            break;
          }
        case 'closed':
          {
            _this.emit('@connectionstatechange', 'closed');
            break;
          }
      }
    });
    logger.debug('constructor()');
    _this._direction = direction;
    _this._remoteSdp = new RemoteSdp_1.RemoteSdp({
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      sctpParameters: sctpParameters
    });
    _this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
    if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
      _this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
    }
    _this._pc = new RTCPeerConnection(_objectSpread({
      iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
      iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    }, additionalSettings));
    _this._pc.addEventListener('icegatheringstatechange', _this.onIceGatheringStateChange);
    _this._pc.addEventListener('icecandidateerror', _this.onIceCandidateError);
    if (_this._pc.connectionState) {
      _this._pc.addEventListener('connectionstatechange', _this.onConnectionStateChange);
    } else {
      logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
      _this._pc.addEventListener('iceconnectionstatechange', _this.onIceConnectionStateChange);
    }
    return _this;
  }
  _inherits(ReactNative106, _enhancedEvents_1$Enh);
  return _createClass(ReactNative106, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Free/dispose native MediaStream but DO NOT free/dispose native
      // MediaStreamTracks (that is parent's business).
      // @ts-expect-error --- Proprietary API in react-native-webrtc.
      this._sendStream.release(/* releaseTracks */false);
      // Close RTCPeerConnection.
      try {
        this._pc.close();
      } catch (error) {}
      this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
      this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
      this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
      this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
      this.emit('@close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(ReactNative106, "close", this, 3)([]);
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(iceServers) {
        var configuration;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context2.n = 5;
                break;
              }
              _context2.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context2.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context2.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context2.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context2.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context2.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context2.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              return _context3.a(2, this._pc.getStats());
          }
        }, _callee3, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref2) {
        var _transceiver$mid;
        var track, encodings, codecOptions, codec, onRtpSender, mediaSectionIdx, transceiver, offer, localSdpObject, nativeRtpCapabilities, sendExtendedRtpCapabilities, sendingRtpParameters, sendingRemoteRtpParameters, _this$_forcedLocalDtl, hackVp9Svc, layers, offerMediaObject, localId, newEncodings, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec, onRtpSender = _ref2.onRtpSender;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
              }
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              if (onRtpSender) {
                onRtpSender(transceiver.sender);
              }
              _context4.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context4.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              nativeRtpCapabilities = ReactNative106.getLocalRtpCapabilities(localSdpObject);
              sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities); // Generic sending RTP parameters.
              sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              // Generic sending RTP parameters suitable for the SDP remote answer.
              sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              if (this._transportReady) {
                _context4.n = 2;
                break;
              }
              _context4.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              // Special case for VP9 with SVC.
              hackVp9Svc = false;
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
                logger.debug('send() | enabling legacy simulcast for VP9 SVC');
                hackVp9Svc = true;
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: layers.spatialLayers
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              // NOTE: We cannot read generated MID on iOS react-native-webrtc 111.0.0
              // because transceiver.mid is not available until setRemoteDescription()
              // is called, so this is best effort.
              // Issue: https://github.com/react-native-webrtc/react-native-webrtc/issues/1404
              // NOTE: So let's fill MID in sendingRtpParameters later.
              // NOTE: This is fixed in react-native-webrtc 111.0.3.
              localId = (_transceiver$mid = transceiver.mid) !== null && _transceiver$mid !== void 0 ? _transceiver$mid : undefined;
              if (!localId) {
                logger.warn('send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround');
              }
              // Set MID.
              // NOTE: As per above, it could be unset yet.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                // Hack for VP9 SVC.
                if (hackVp9Svc) {
                  newEncodings = [newEncodings[0]];
                }
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Follow up of iOS react-native-webrtc 111.0.0 issue told above. Now yes,
              // we can read generated MID (if not done above) and fill sendingRtpParameters.
              // NOTE: This is fixed in react-native-webrtc 111.0.3 so this block isn't
              // needed starting from that version.
              if (!localId) {
                localId = transceiver.mid;
                sendingRtpParameters.mid = localId;
              }
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context4.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee4, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertSendDirection();
              if (!this._closed) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context5.n = 2;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context5.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context5.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context5.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context5.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context6.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context6.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context6.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              this._remoteSdp.resumeSendingMediaSection(localId);
              if (transceiver) {
                _context7.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context8.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context9.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context9.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context9.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context0.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context0.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context0.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context0.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context0.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId) {
        var transceiver;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context1.a(2, transceiver.sender.getStats());
          }
        }, _callee1, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context10.n = 5;
                break;
              }
              _context10.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context10.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context10.n = 2;
                break;
              }
              _context10.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context10.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee10, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(optionsList) {
        var _this2 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, _iterator3, _step3, _loop, answer, localSdpObject, _iterator4, _step4, _loop2, _this$_forcedLocalDtl3, _iterator5, _step5, _loop3, _t, _t2, _t3;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context14.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context14.p = 2;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, onRtpReceiver, _localId, transceiver;
                return _regenerator().w(function (_context11) {
                  while (1) switch (_context11.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, onRtpReceiver = options.onRtpReceiver;
                      if (!onRtpReceiver) {
                        _context11.n = 2;
                        break;
                      }
                      _localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === _localId;
                      });
                      if (transceiver) {
                        _context11.n = 1;
                        break;
                      }
                      throw new Error('transceiver not found');
                    case 1:
                      onRtpReceiver(transceiver.receiver);
                    case 2:
                      return _context11.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context14.n = 5;
                break;
              }
              return _context14.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context14.n = 3;
              break;
            case 5:
              _context14.n = 7;
              break;
            case 6:
              _context14.p = 6;
              _t = _context14.v;
              _iterator3.e(_t);
            case 7:
              _context14.p = 7;
              _iterator3.f();
              return _context14.f(7);
            case 8:
              _context14.n = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context14.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context14.p = 10;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context12) {
                  while (1) switch (_context12.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context12.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 11:
              if ((_step4 = _iterator4.n()).done) {
                _context14.n = 13;
                break;
              }
              return _context14.d(_regeneratorValues(_loop2()), 12);
            case 12:
              _context14.n = 11;
              break;
            case 13:
              _context14.n = 15;
              break;
            case 14:
              _context14.p = 14;
              _t2 = _context14.v;
              _iterator4.e(_t2);
            case 15:
              _context14.p = 15;
              _iterator4.f();
              return _context14.f(15);
            case 16:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context14.n = 17;
                break;
              }
              _context14.n = 17;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context14.n = 18;
              return this._pc.setLocalDescription(answer);
            case 18:
              _iterator5 = _createForOfIteratorHelper(optionsList);
              _context14.p = 19;
              _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step5.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context13.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this2._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context13.a(2);
                  }
                }, _loop3);
              });
              _iterator5.s();
            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context14.n = 22;
                break;
              }
              return _context14.d(_regeneratorValues(_loop3()), 21);
            case 21:
              _context14.n = 20;
              break;
            case 22:
              _context14.n = 24;
              break;
            case 23:
              _context14.p = 23;
              _t3 = _context14.v;
              _iterator5.e(_t3);
            case 24:
              _context14.p = 24;
              _iterator5.f();
              return _context14.f(24);
            case 25:
              return _context14.a(2, results);
          }
        }, _callee11, this, [[19, 23, 24, 25], [10, 14, 15, 16], [2, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(localIds) {
        var _iterator6, _step6, localId, transceiver, offer, answer, _iterator7, _step7, _localId2, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.p = _context15.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context15.n = 1;
                break;
              }
              return _context15.a(2);
            case 1:
              _iterator6 = _createForOfIteratorHelper(localIds);
              _context15.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context15.n = 6;
                break;
              }
              localId = _step6.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context15.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context15.n = 3;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t4 = _context15.v;
              _iterator6.e(_t4);
            case 8:
              _context15.p = 8;
              _iterator6.f();
              return _context15.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context15.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context15.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator7 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _localId2 = _step7.value;
                  this._mapMidTransceiver["delete"](_localId2);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            case 13:
              return _context15.a(2);
          }
        }, _callee12, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t5;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.p = _context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context16.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context16.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context16.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context16.n = 2;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t5 = _context16.v;
              _iterator8.e(_t5);
            case 7:
              _context16.p = 7;
              _iterator8.f();
              return _context16.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context16.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context16.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context16.a(2);
          }
        }, _callee13, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator9, _step9, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.p = _context17.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator9 = _createForOfIteratorHelper(localIds);
              _context17.p = 1;
              _iterator9.s();
            case 2:
              if ((_step9 = _iterator9.n()).done) {
                _context17.n = 5;
                break;
              }
              localId = _step9.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context17.n = 2;
              break;
            case 5:
              _context17.n = 7;
              break;
            case 6:
              _context17.p = 6;
              _t6 = _context17.v;
              _iterator9.e(_t6);
            case 7:
              _context17.p = 7;
              _iterator9.f();
              return _context17.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context17.a(2);
          }
        }, _callee14, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localId) {
        var transceiver;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context18.a(2, transceiver.receiver.getStats());
          }
        }, _callee15, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context19.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context19.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context19.v;
              if (this._transportReady) {
                _context19.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context19.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context19.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context19.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee16, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(_ref5) {
        var _this3 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context20.n = 1;
              return new Promise(function (resolve, reject) {
                _this3.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context20.a(2);
          }
        }, _callee17, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return {
        name: NAME,
        factory: function factory(options) {
          return new ReactNative106(options);
        },
        getNativeRtpCapabilities: function () {
          var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
            var pc, offer, sdpObject, nativeRtpCapabilities, _pc, _t7;
            return _regenerator().w(function (_context21) {
              while (1) switch (_context21.p = _context21.n) {
                case 0:
                  logger.debug('getNativeRtpCapabilities()');
                  pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                  });
                  _context21.p = 1;
                  pc.addTransceiver('audio');
                  pc.addTransceiver('video');
                  _context21.n = 2;
                  return pc.createOffer();
                case 2:
                  offer = _context21.v;
                  try {
                    pc.close();
                  } catch (error) {}
                  pc = undefined;
                  sdpObject = sdpTransform.parse(offer.sdp);
                  nativeRtpCapabilities = ReactNative106.getLocalRtpCapabilities(sdpObject);
                  return _context21.a(2, nativeRtpCapabilities);
                case 3:
                  _context21.p = 3;
                  _t7 = _context21.v;
                  try {
                    (_pc = pc) === null || _pc === void 0 || _pc.close();
                  } catch (error2) {}
                  pc = undefined;
                  throw _t7;
                case 4:
                  return _context21.a(2);
              }
            }, _callee18, null, [[1, 3]]);
          }));
          function getNativeRtpCapabilities() {
            return _getNativeRtpCapabilities.apply(this, arguments);
          }
          return getNativeRtpCapabilities;
        }(),
        getNativeSctpCapabilities: function () {
          var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
            return _regenerator().w(function (_context22) {
              while (1) switch (_context22.n) {
                case 0:
                  logger.debug('getNativeSctpCapabilities()');
                  return _context22.a(2, {
                    numStreams: SCTP_NUM_STREAMS
                  });
              }
            }, _callee19);
          }));
          function getNativeSctpCapabilities() {
            return _getNativeSctpCapabilities.apply(this, arguments);
          }
          return getNativeSctpCapabilities;
        }()
      };
    }
  }, {
    key: "getLocalRtpCapabilities",
    value: function getLocalRtpCapabilities(localSdpObject) {
      var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      // Need to validate and normalize native RTP capabilities.
      ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      // libwebrtc supports NACK for OPUS but doesn't announce it.
      ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.ReactNative106 = ReactNative106;

},{"../Logger":19,"../enhancedEvents":22,"../errors":23,"../ortc":37,"../scalabilityModes":38,"./ortc/utils":31,"./sdp/RemoteSdp":33,"./sdp/commonUtils":34,"./sdp/unifiedPlanUtils":35,"sdp-transform":45}],29:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Safari12 = void 0;
var sdpTransform = require("sdp-transform");
var enhancedEvents_1 = require("../enhancedEvents");
var Logger_1 = require("../Logger");
var ortc = require("../ortc");
var errors_1 = require("../errors");
var scalabilityModes_1 = require("../scalabilityModes");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var ortcUtils = require("./ortc/utils");
var logger = new Logger_1.Logger('Safari12');
var NAME = 'Safari12';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Safari12 = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Safari12(_ref) {
    var _this;
    var direction = _ref.direction,
      iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      iceServers = _ref.iceServers,
      iceTransportPolicy = _ref.iceTransportPolicy,
      additionalSettings = _ref.additionalSettings,
      getSendExtendedRtpCapabilities = _ref.getSendExtendedRtpCapabilities;
    _classCallCheck(this, Safari12);
    _this = _callSuper(this, Safari12);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Callback to request sending extended RTP capabilities on demand.
    _defineProperty(_this, "_getSendExtendedRtpCapabilities", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    _defineProperty(_this, "onIceGatheringStateChange", function () {
      _this.emit('@icegatheringstatechange', _this._pc.iceGatheringState);
    });
    _defineProperty(_this, "onIceCandidateError", function (event) {
      _this.emit('@icecandidateerror', event);
    });
    _defineProperty(_this, "onConnectionStateChange", function () {
      _this.emit('@connectionstatechange', _this._pc.connectionState);
    });
    _defineProperty(_this, "onIceConnectionStateChange", function () {
      switch (_this._pc.iceConnectionState) {
        case 'checking':
          {
            _this.emit('@connectionstatechange', 'connecting');
            break;
          }
        case 'connected':
        case 'completed':
          {
            _this.emit('@connectionstatechange', 'connected');
            break;
          }
        case 'failed':
          {
            _this.emit('@connectionstatechange', 'failed');
            break;
          }
        case 'disconnected':
          {
            _this.emit('@connectionstatechange', 'disconnected');
            break;
          }
        case 'closed':
          {
            _this.emit('@connectionstatechange', 'closed');
            break;
          }
      }
    });
    logger.debug('constructor()');
    _this._direction = direction;
    _this._remoteSdp = new RemoteSdp_1.RemoteSdp({
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      sctpParameters: sctpParameters
    });
    _this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
    if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
      _this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
    }
    _this._pc = new RTCPeerConnection(_objectSpread({
      iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
      iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    }, additionalSettings));
    _this._pc.addEventListener('icegatheringstatechange', function () {
      _this.emit('@icegatheringstatechange', _this._pc.iceGatheringState);
    });
    _this._pc.addEventListener('icecandidateerror', function (event) {
      _this.emit('@icecandidateerror', event);
    });
    _this._pc.addEventListener('icegatheringstatechange', _this.onIceGatheringStateChange);
    _this._pc.addEventListener('icecandidateerror', _this.onIceCandidateError);
    if (_this._pc.connectionState) {
      _this._pc.addEventListener('connectionstatechange', _this.onConnectionStateChange);
    } else {
      logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
      _this._pc.addEventListener('iceconnectionstatechange', _this.onIceConnectionStateChange);
    }
    return _this;
  }
  _inherits(Safari12, _enhancedEvents_1$Enh);
  return _createClass(Safari12, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      try {
        this._pc.close();
      } catch (error) {}
      this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
      this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
      this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
      this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
      this.emit('@close');
      // Invoke close() in EnhancedEventEmitter classes.
      _superPropGet(Safari12, "close", this, 3)([]);
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(iceServers) {
        var configuration;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context2.n = 5;
                break;
              }
              _context2.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context2.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context2.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context2.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context2.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context2.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context2.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context2.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              return _context3.a(2, this._pc.getStats());
          }
        }, _callee3, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref2) {
        var track, encodings, codecOptions, codec, onRtpSender, mediaSectionIdx, transceiver, offer, localSdpObject, nativeRtpCapabilities, sendExtendedRtpCapabilities, sendingRtpParameters, sendingRemoteRtpParameters, offerMediaObject, _this$_forcedLocalDtl, layers, localId, idx, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec, onRtpSender = _ref2.onRtpSender;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream]
              });
              if (onRtpSender) {
                onRtpSender(transceiver.sender);
              }
              _context4.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context4.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              nativeRtpCapabilities = Safari12.getLocalRtpCapabilities(localSdpObject);
              sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities); // Generic sending RTP parameters.
              sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              // Generic sending RTP parameters suitable for the SDP remote answer.
              sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              if (this._transportReady) {
                _context4.n = 2;
                break;
              }
              _context4.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              if (encodings && encodings.length > 1) {
                logger.debug('send() | enabling legacy simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                  }
                }
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context4.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee4, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertSendDirection();
              if (!this._closed) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context5.n = 2;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context5.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context5.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context5.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context5.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context6.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context6.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context6.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              this._remoteSdp.resumeSendingMediaSection(localId);
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context8.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context9.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context9.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context9.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context0.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context0.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context0.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context0.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context0.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId) {
        var transceiver;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context1.a(2, transceiver.sender.getStats());
          }
        }, _callee1, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context10.n = 5;
                break;
              }
              _context10.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context10.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context10.n = 2;
                break;
              }
              _context10.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context10.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee10, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(optionsList) {
        var _this2 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, _iterator3, _step3, _loop, answer, localSdpObject, _iterator4, _step4, _loop2, _this$_forcedLocalDtl3, _iterator5, _step5, _loop3, _t, _t2, _t3;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context14.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context14.p = 2;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, onRtpReceiver, _localId, transceiver;
                return _regenerator().w(function (_context11) {
                  while (1) switch (_context11.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, onRtpReceiver = options.onRtpReceiver;
                      if (!onRtpReceiver) {
                        _context11.n = 2;
                        break;
                      }
                      _localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === _localId;
                      });
                      if (transceiver) {
                        _context11.n = 1;
                        break;
                      }
                      throw new Error('transceiver not found');
                    case 1:
                      onRtpReceiver(transceiver.receiver);
                    case 2:
                      return _context11.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context14.n = 5;
                break;
              }
              return _context14.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context14.n = 3;
              break;
            case 5:
              _context14.n = 7;
              break;
            case 6:
              _context14.p = 6;
              _t = _context14.v;
              _iterator3.e(_t);
            case 7:
              _context14.p = 7;
              _iterator3.f();
              return _context14.f(7);
            case 8:
              _context14.n = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context14.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context14.p = 10;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context12) {
                  while (1) switch (_context12.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context12.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 11:
              if ((_step4 = _iterator4.n()).done) {
                _context14.n = 13;
                break;
              }
              return _context14.d(_regeneratorValues(_loop2()), 12);
            case 12:
              _context14.n = 11;
              break;
            case 13:
              _context14.n = 15;
              break;
            case 14:
              _context14.p = 14;
              _t2 = _context14.v;
              _iterator4.e(_t2);
            case 15:
              _context14.p = 15;
              _iterator4.f();
              return _context14.f(15);
            case 16:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context14.n = 17;
                break;
              }
              _context14.n = 17;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context14.n = 18;
              return this._pc.setLocalDescription(answer);
            case 18:
              _iterator5 = _createForOfIteratorHelper(optionsList);
              _context14.p = 19;
              _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step5.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this2._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context13.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this2._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context13.a(2);
                  }
                }, _loop3);
              });
              _iterator5.s();
            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context14.n = 22;
                break;
              }
              return _context14.d(_regeneratorValues(_loop3()), 21);
            case 21:
              _context14.n = 20;
              break;
            case 22:
              _context14.n = 24;
              break;
            case 23:
              _context14.p = 23;
              _t3 = _context14.v;
              _iterator5.e(_t3);
            case 24:
              _context14.p = 24;
              _iterator5.f();
              return _context14.f(24);
            case 25:
              return _context14.a(2, results);
          }
        }, _callee11, this, [[19, 23, 24, 25], [10, 14, 15, 16], [2, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(localIds) {
        var _iterator6, _step6, localId, transceiver, offer, answer, _iterator7, _step7, _localId2, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.p = _context15.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context15.n = 1;
                break;
              }
              return _context15.a(2);
            case 1:
              _iterator6 = _createForOfIteratorHelper(localIds);
              _context15.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context15.n = 6;
                break;
              }
              localId = _step6.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context15.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context15.n = 3;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t4 = _context15.v;
              _iterator6.e(_t4);
            case 8:
              _context15.p = 8;
              _iterator6.f();
              return _context15.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context15.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context15.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator7 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _localId2 = _step7.value;
                  this._mapMidTransceiver["delete"](_localId2);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            case 13:
              return _context15.a(2);
          }
        }, _callee12, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t5;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.p = _context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context16.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context16.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context16.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context16.n = 2;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t5 = _context16.v;
              _iterator8.e(_t5);
            case 7:
              _context16.p = 7;
              _iterator8.f();
              return _context16.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context16.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context16.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context16.a(2);
          }
        }, _callee13, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator9, _step9, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.p = _context17.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator9 = _createForOfIteratorHelper(localIds);
              _context17.p = 1;
              _iterator9.s();
            case 2:
              if ((_step9 = _iterator9.n()).done) {
                _context17.n = 5;
                break;
              }
              localId = _step9.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context17.n = 2;
              break;
            case 5:
              _context17.n = 7;
              break;
            case 6:
              _context17.p = 6;
              _t6 = _context17.v;
              _iterator9.e(_t6);
            case 7:
              _context17.p = 7;
              _iterator9.f();
              return _context17.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context17.a(2);
          }
        }, _callee14, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localId) {
        var transceiver;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context18.a(2, transceiver.receiver.getStats());
          }
        }, _callee15, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context19.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context19.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context19.v;
              if (this._transportReady) {
                _context19.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context19.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context19.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context19.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee16, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(_ref5) {
        var _this3 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context20.n = 1;
              return new Promise(function (resolve, reject) {
                _this3.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context20.a(2);
          }
        }, _callee17, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return {
        name: NAME,
        factory: function factory(options) {
          return new Safari12(options);
        },
        getNativeRtpCapabilities: function () {
          var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
            var pc, offer, sdpObject, nativeRtpCapabilities, _pc, _t7;
            return _regenerator().w(function (_context21) {
              while (1) switch (_context21.p = _context21.n) {
                case 0:
                  logger.debug('getNativeRtpCapabilities()');
                  pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                  });
                  _context21.p = 1;
                  pc.addTransceiver('audio');
                  pc.addTransceiver('video');
                  _context21.n = 2;
                  return pc.createOffer();
                case 2:
                  offer = _context21.v;
                  try {
                    pc.close();
                  } catch (error) {}
                  pc = undefined;
                  sdpObject = sdpTransform.parse(offer.sdp);
                  nativeRtpCapabilities = Safari12.getLocalRtpCapabilities(sdpObject);
                  return _context21.a(2, nativeRtpCapabilities);
                case 3:
                  _context21.p = 3;
                  _t7 = _context21.v;
                  try {
                    (_pc = pc) === null || _pc === void 0 || _pc.close();
                  } catch (error2) {}
                  pc = undefined;
                  throw _t7;
                case 4:
                  return _context21.a(2);
              }
            }, _callee18, null, [[1, 3]]);
          }));
          function getNativeRtpCapabilities() {
            return _getNativeRtpCapabilities.apply(this, arguments);
          }
          return getNativeRtpCapabilities;
        }(),
        getNativeSctpCapabilities: function () {
          var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
            return _regenerator().w(function (_context22) {
              while (1) switch (_context22.n) {
                case 0:
                  logger.debug('getNativeSctpCapabilities()');
                  return _context22.a(2, {
                    numStreams: SCTP_NUM_STREAMS
                  });
              }
            }, _callee19);
          }));
          function getNativeSctpCapabilities() {
            return _getNativeSctpCapabilities.apply(this, arguments);
          }
          return getNativeSctpCapabilities;
        }()
      };
    }
  }, {
    key: "getLocalRtpCapabilities",
    value: function getLocalRtpCapabilities(localSdpObject) {
      var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      // Need to validate and normalize native RTP capabilities.
      ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      // libwebrtc supports NACK for OPUS but doesn't announce it.
      ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Safari12 = Safari12;

},{"../Logger":19,"../enhancedEvents":22,"../errors":23,"../ortc":37,"../scalabilityModes":38,"./ortc/utils":31,"./sdp/RemoteSdp":33,"./sdp/commonUtils":34,"./sdp/unifiedPlanUtils":35,"sdp-transform":45}],30:[function(require,module,exports){
"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeEventTarget = void 0;
var FakeEventTarget = /*#__PURE__*/function () {
  function FakeEventTarget() {
    _classCallCheck(this, FakeEventTarget);
    _defineProperty(this, "listeners", {});
  }
  return _createClass(FakeEventTarget, [{
    key: "addEventListener",
    value: function addEventListener(type, callback, options) {
      var _this$listeners, _this$listeners$type;
      if (!callback) {
        return;
      }
      (_this$listeners$type = (_this$listeners = this.listeners)[type]) !== null && _this$listeners$type !== void 0 ? _this$listeners$type : _this$listeners[type] = [];
      this.listeners[type].push({
        callback: typeof callback === 'function' ? callback : callback.handleEvent,
        once: _typeof(options) === 'object' && options.once === true
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, callback,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
      if (!this.listeners[type]) {
        return;
      }
      if (!callback) {
        return;
      }
      this.listeners[type] = this.listeners[type].filter(function (listener) {
        return listener.callback !== (typeof callback === 'function' ? callback : callback.handleEvent);
      });
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      var _this = this;
      if (!event || typeof event.type !== 'string') {
        throw new Error('invalid event object');
      }
      var entries = this.listeners[event.type];
      if (!entries) {
        return true;
      }
      var _loop = function _loop() {
        var listener = _arr[_i];
        try {
          listener.callback.call(_this, event);
        } catch (error) {
          // Avoid that the error breaks the iteration.
          setTimeout(function () {
            throw error;
          }, 0);
        }
        if (listener.once) {
          _this.removeEventListener(event.type, listener.callback);
        }
      };
      for (var _i = 0, _arr = _toConsumableArray(entries); _i < _arr.length; _i++) {
        _loop();
      }
      return !event.defaultPrevented;
    }
  }]);
}();
exports.FakeEventTarget = FakeEventTarget;

},{}],31:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addNackSupportForOpus = addNackSupportForOpus;
/**
 * This function adds RTCP NACK support for OPUS codec in given capabilities.
 */
function addNackSupportForOpus(rtpCapabilities) {
  var _rtpCapabilities$code;
  var _iterator = _createForOfIteratorHelper((_rtpCapabilities$code = rtpCapabilities.codecs) !== null && _rtpCapabilities$code !== void 0 ? _rtpCapabilities$code : []),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _codec$rtcpFeedback;
      var codec = _step.value;
      if ((codec.mimeType.toLowerCase() === 'audio/opus' || codec.mimeType.toLowerCase() === 'audio/multiopus') && !((_codec$rtcpFeedback = codec.rtcpFeedback) !== null && _codec$rtcpFeedback !== void 0 && _codec$rtcpFeedback.some(function (fb) {
        return fb.type === 'nack' && !fb.parameter;
      }))) {
        if (!codec.rtcpFeedback) {
          codec.rtcpFeedback = [];
        }
        codec.rtcpFeedback.push({
          type: 'nack'
        });
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

},{}],32:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
var sdpTransform = require("sdp-transform");
var utils = require("../../utils");
var MediaSection = /*#__PURE__*/function () {
  function MediaSection(_ref) {
    var iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters;
    _classCallCheck(this, MediaSection);
    // SDP media object.
    _defineProperty(this, "_mediaObject", void 0);
    this._mediaObject = {
      type: '',
      port: 0,
      protocol: '',
      payloads: '',
      rtp: [],
      fmtp: []
    };
    if (iceParameters) {
      this.setIceParameters(iceParameters);
    }
    if (iceCandidates) {
      this._mediaObject.candidates = [];
      var _iterator = _createForOfIteratorHelper(iceCandidates),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _candidate$address;
          var candidate = _step.value;
          var candidateObject = {
            foundation: candidate.foundation,
            // mediasoup does mandates rtcp-mux so candidates component is always
            // RTP (1).
            component: 1,
            // Be ready for new candidate.address field in mediasoup server side
            // field and keep backward compatibility with deprecated candidate.ip.
            ip: (_candidate$address = candidate.address) !== null && _candidate$address !== void 0 ? _candidate$address : candidate.ip,
            port: candidate.port,
            priority: candidate.priority,
            transport: candidate.protocol,
            type: candidate.type
          };
          if (candidate.tcpType) {
            candidateObject.tcptype = candidate.tcpType;
          }
          this._mediaObject.candidates.push(candidateObject);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this._mediaObject.endOfCandidates = 'end-of-candidates';
      this._mediaObject.iceOptions = 'renomination';
    }
    if (dtlsParameters) {
      this.setDtlsRole(dtlsParameters.role);
    }
  }
  return _createClass(MediaSection, [{
    key: "mid",
    get: function get() {
      return String(this._mediaObject.mid);
    }
  }, {
    key: "closed",
    get: function get() {
      return this._mediaObject.port === 0;
    }
  }, {
    key: "getObject",
    value: function getObject() {
      return this._mediaObject;
    }
  }, {
    key: "setIceParameters",
    value: function setIceParameters(iceParameters) {
      this._mediaObject.iceUfrag = iceParameters.usernameFragment;
      this._mediaObject.icePwd = iceParameters.password;
    }
  }, {
    key: "pause",
    value: function pause() {
      this._mediaObject.direction = 'inactive';
    }
  }, {
    key: "disable",
    value: function disable() {
      this.pause();
      delete this._mediaObject.ext;
      delete this._mediaObject.ssrcs;
      delete this._mediaObject.ssrcGroups;
      delete this._mediaObject.simulcast;
      delete this._mediaObject.simulcast_03;
      delete this._mediaObject.rids;
      delete this._mediaObject.extmapAllowMixed;
    }
  }, {
    key: "close",
    value: function close() {
      this.disable();
      this._mediaObject.port = 0;
    }
  }]);
}();
exports.MediaSection = MediaSection;
var AnswerMediaSection = /*#__PURE__*/function (_MediaSection2) {
  function AnswerMediaSection(_ref2) {
    var _this;
    var iceParameters = _ref2.iceParameters,
      iceCandidates = _ref2.iceCandidates,
      dtlsParameters = _ref2.dtlsParameters,
      sctpParameters = _ref2.sctpParameters,
      plainRtpParameters = _ref2.plainRtpParameters,
      offerMediaObject = _ref2.offerMediaObject,
      offerRtpParameters = _ref2.offerRtpParameters,
      answerRtpParameters = _ref2.answerRtpParameters,
      codecOptions = _ref2.codecOptions;
    _classCallCheck(this, AnswerMediaSection);
    _this = _callSuper(this, AnswerMediaSection, [{
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters
    }]);
    _this._mediaObject.mid = String(offerMediaObject.mid);
    _this._mediaObject.type = offerMediaObject.type;
    _this._mediaObject.protocol = offerMediaObject.protocol;
    if (!plainRtpParameters) {
      _this._mediaObject.connection = {
        ip: '127.0.0.1',
        version: 4
      };
      _this._mediaObject.port = 7;
    } else {
      _this._mediaObject.connection = {
        ip: plainRtpParameters.ip,
        version: plainRtpParameters.ipVersion
      };
      _this._mediaObject.port = plainRtpParameters.port;
    }
    switch (offerMediaObject.type) {
      case 'audio':
      case 'video':
        {
          _this._mediaObject.direction = 'recvonly';
          _this._mediaObject.rtp = [];
          _this._mediaObject.rtcpFb = [];
          _this._mediaObject.fmtp = [];
          var _iterator2 = _createForOfIteratorHelper(answerRtpParameters.codecs),
            _step2;
          try {
            var _loop = function _loop() {
              var _utils$clone, _utils$clone2;
              var codec = _step2.value;
              var rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
              };
              if (codec.channels > 1) {
                rtp.encoding = codec.channels;
              }
              _this._mediaObject.rtp.push(rtp);
              var codecParameters = (_utils$clone = utils.clone(codec.parameters)) !== null && _utils$clone !== void 0 ? _utils$clone : {};
              var codecRtcpFeedback = (_utils$clone2 = utils.clone(codec.rtcpFeedback)) !== null && _utils$clone2 !== void 0 ? _utils$clone2 : [];
              if (codecOptions) {
                var opusStereo = codecOptions.opusStereo,
                  opusFec = codecOptions.opusFec,
                  opusDtx = codecOptions.opusDtx,
                  opusMaxPlaybackRate = codecOptions.opusMaxPlaybackRate,
                  opusMaxAverageBitrate = codecOptions.opusMaxAverageBitrate,
                  opusPtime = codecOptions.opusPtime,
                  opusNack = codecOptions.opusNack,
                  videoGoogleStartBitrate = codecOptions.videoGoogleStartBitrate,
                  videoGoogleMaxBitrate = codecOptions.videoGoogleMaxBitrate,
                  videoGoogleMinBitrate = codecOptions.videoGoogleMinBitrate;
                var offerCodec = offerRtpParameters.codecs.find(function (c) {
                  return c.payloadType === codec.payloadType;
                });
                switch (codec.mimeType.toLowerCase()) {
                  case 'audio/opus':
                  case 'audio/multiopus':
                    {
                      if (opusStereo !== undefined) {
                        offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
                        codecParameters['stereo'] = opusStereo ? 1 : 0;
                      }
                      if (opusFec !== undefined) {
                        offerCodec.parameters['useinbandfec'] = opusFec ? 1 : 0;
                        codecParameters['useinbandfec'] = opusFec ? 1 : 0;
                      }
                      if (opusDtx !== undefined) {
                        offerCodec.parameters['usedtx'] = opusDtx ? 1 : 0;
                        codecParameters['usedtx'] = opusDtx ? 1 : 0;
                      }
                      if (opusMaxPlaybackRate !== undefined) {
                        codecParameters['maxplaybackrate'] = opusMaxPlaybackRate;
                      }
                      if (opusMaxAverageBitrate !== undefined) {
                        codecParameters['maxaveragebitrate'] = opusMaxAverageBitrate;
                      }
                      if (opusPtime !== undefined) {
                        offerCodec.parameters['ptime'] = opusPtime;
                        codecParameters['ptime'] = opusPtime;
                      }
                      // If opusNack is not set, we must remove NACK support for OPUS.
                      // Otherwise it would be enabled for those handlers that artificially
                      // announce it in their RTP capabilities.
                      if (!opusNack) {
                        offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter(function (fb) {
                          return fb.type !== 'nack' || fb.parameter;
                        });
                        codecRtcpFeedback = codecRtcpFeedback.filter(function (fb) {
                          return fb.type !== 'nack' || fb.parameter;
                        });
                      }
                      break;
                    }
                  case 'video/vp8':
                  case 'video/vp9':
                  case 'video/h264':
                  case 'video/h265':
                  case 'video/av1':
                    {
                      if (videoGoogleStartBitrate !== undefined) {
                        codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;
                      }
                      if (videoGoogleMaxBitrate !== undefined) {
                        codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;
                      }
                      if (videoGoogleMinBitrate !== undefined) {
                        codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;
                      }
                      break;
                    }
                }
              }
              var fmtp = {
                payload: codec.payloadType,
                config: ''
              };
              for (var _i = 0, _Object$keys = Object.keys(codecParameters); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                if (fmtp.config) {
                  fmtp.config += ';';
                }
                fmtp.config += "".concat(key, "=").concat(codecParameters[key]);
              }
              if (fmtp.config) {
                _this._mediaObject.fmtp.push(fmtp);
              }
              var _iterator6 = _createForOfIteratorHelper(codecRtcpFeedback),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var fb = _step6.value;
                  _this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          _this._mediaObject.payloads = answerRtpParameters.codecs.map(function (codec) {
            return codec.payloadType;
          }).join(' ');
          _this._mediaObject.ext = [];
          var _iterator3 = _createForOfIteratorHelper(answerRtpParameters.headerExtensions),
            _step3;
          try {
            var _loop2 = function _loop2() {
              var _offerMediaObject$ext;
              var ext = _step3.value;
              // Don't add a header extension if not present in the offer.
              var found = ((_offerMediaObject$ext = offerMediaObject.ext) !== null && _offerMediaObject$ext !== void 0 ? _offerMediaObject$ext : []).some(function (localExt) {
                return localExt.uri === ext.uri;
              });
              if (!found) {
                return 1; // continue
              }
              _this._mediaObject.ext.push({
                uri: ext.uri,
                value: ext.id
              });
            };
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              if (_loop2()) continue;
            }
            // Allow both 1 byte and 2 bytes length header extensions since
            // mediasoup can receive both at any time.
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          if (offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {
            _this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
          }
          // Simulcast.
          if (offerMediaObject.simulcast) {
            var _offerMediaObject$rid;
            _this._mediaObject.simulcast = {
              dir1: 'recv',
              list1: offerMediaObject.simulcast.list1
            };
            _this._mediaObject.rids = [];
            var _iterator4 = _createForOfIteratorHelper((_offerMediaObject$rid = offerMediaObject.rids) !== null && _offerMediaObject$rid !== void 0 ? _offerMediaObject$rid : []),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var rid = _step4.value;
                if (rid.direction !== 'send') {
                  continue;
                }
                _this._mediaObject.rids.push({
                  id: rid.id,
                  direction: 'recv'
                });
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
          // Simulcast (draft version 03).
          else if (offerMediaObject.simulcast_03) {
            var _offerMediaObject$rid2;
            _this._mediaObject.simulcast_03 = {
              value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')
            };
            _this._mediaObject.rids = [];
            var _iterator5 = _createForOfIteratorHelper((_offerMediaObject$rid2 = offerMediaObject.rids) !== null && _offerMediaObject$rid2 !== void 0 ? _offerMediaObject$rid2 : []),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _rid = _step5.value;
                if (_rid.direction !== 'send') {
                  continue;
                }
                _this._mediaObject.rids.push({
                  id: _rid.id,
                  direction: 'recv'
                });
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
          _this._mediaObject.rtcpMux = 'rtcp-mux';
          _this._mediaObject.rtcpRsize = 'rtcp-rsize';
          break;
        }
      case 'application':
        {
          // New spec.
          if (typeof offerMediaObject.sctpPort === 'number') {
            _this._mediaObject.payloads = 'webrtc-datachannel';
            _this._mediaObject.sctpPort = sctpParameters.port;
            _this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
          }
          // Old spec.
          else if (offerMediaObject.sctpmap) {
            _this._mediaObject.payloads = String(sctpParameters.port);
            _this._mediaObject.sctpmap = {
              app: 'webrtc-datachannel',
              sctpmapNumber: sctpParameters.port,
              maxMessageSize: sctpParameters.maxMessageSize
            };
          }
          break;
        }
    }
    return _this;
  }
  _inherits(AnswerMediaSection, _MediaSection2);
  return _createClass(AnswerMediaSection, [{
    key: "setDtlsRole",
    value: function setDtlsRole(role) {
      switch (role) {
        case 'client':
          {
            this._mediaObject.setup = 'active';
            break;
          }
        case 'server':
          {
            this._mediaObject.setup = 'passive';
            break;
          }
        case 'auto':
          {
            this._mediaObject.setup = 'actpass';
            break;
          }
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      this._mediaObject.direction = 'recvonly';
    }
  }, {
    key: "muxSimulcastStreams",
    value: function muxSimulcastStreams(encodings) {
      var _this$_mediaObject$si;
      if (!((_this$_mediaObject$si = this._mediaObject.simulcast) !== null && _this$_mediaObject$si !== void 0 && _this$_mediaObject$si.list1)) {
        return;
      }
      var layers = {};
      var _iterator7 = _createForOfIteratorHelper(encodings),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var encoding = _step7.value;
          if (encoding.rid) {
            layers[encoding.rid] = encoding;
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      var raw = this._mediaObject.simulcast.list1;
      var simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
      var _iterator8 = _createForOfIteratorHelper(simulcastStreams),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var simulcastStream = _step8.value;
          var _iterator9 = _createForOfIteratorHelper(simulcastStream),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var _layers$simulcastForm;
              var simulcastFormat = _step9.value;
              simulcastFormat.paused = !((_layers$simulcastForm = layers[simulcastFormat.scid]) !== null && _layers$simulcastForm !== void 0 && _layers$simulcastForm.active);
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      this._mediaObject.simulcast.list1 = simulcastStreams.map(function (simulcastFormats) {
        return simulcastFormats.map(function (f) {
          return "".concat(f.paused ? '~' : '').concat(f.scid);
        }).join(',');
      }).join(';');
    }
  }]);
}(MediaSection);
exports.AnswerMediaSection = AnswerMediaSection;
var OfferMediaSection = /*#__PURE__*/function (_MediaSection3) {
  function OfferMediaSection(_ref3) {
    var _this2;
    var iceParameters = _ref3.iceParameters,
      iceCandidates = _ref3.iceCandidates,
      dtlsParameters = _ref3.dtlsParameters,
      sctpParameters = _ref3.sctpParameters,
      plainRtpParameters = _ref3.plainRtpParameters,
      mid = _ref3.mid,
      kind = _ref3.kind,
      offerRtpParameters = _ref3.offerRtpParameters,
      streamId = _ref3.streamId,
      trackId = _ref3.trackId;
    _classCallCheck(this, OfferMediaSection);
    _this2 = _callSuper(this, OfferMediaSection, [{
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters
    }]);
    _this2._mediaObject.mid = String(mid);
    _this2._mediaObject.type = kind;
    if (!plainRtpParameters) {
      _this2._mediaObject.connection = {
        ip: '127.0.0.1',
        version: 4
      };
      if (!sctpParameters) {
        _this2._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';
      } else {
        _this2._mediaObject.protocol = 'UDP/DTLS/SCTP';
      }
      _this2._mediaObject.port = 7;
    } else {
      _this2._mediaObject.connection = {
        ip: plainRtpParameters.ip,
        version: plainRtpParameters.ipVersion
      };
      _this2._mediaObject.protocol = 'RTP/AVP';
      _this2._mediaObject.port = plainRtpParameters.port;
    }
    // Allow both 1 byte and 2 bytes length header extensions since
    // mediasoup can send both at any time.
    _this2._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
    switch (kind) {
      case 'audio':
      case 'video':
        {
          var _encoding$rtx;
          _this2._mediaObject.direction = 'sendonly';
          _this2._mediaObject.rtp = [];
          _this2._mediaObject.rtcpFb = [];
          _this2._mediaObject.fmtp = [];
          _this2._mediaObject.msid = "".concat(streamId !== null && streamId !== void 0 ? streamId : '-', " ").concat(trackId);
          var _iterator0 = _createForOfIteratorHelper(offerRtpParameters.codecs),
            _step0;
          try {
            for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
              var codec = _step0.value;
              var rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
              };
              if (codec.channels > 1) {
                rtp.encoding = codec.channels;
              }
              _this2._mediaObject.rtp.push(rtp);
              var fmtp = {
                payload: codec.payloadType,
                config: ''
              };
              for (var _i2 = 0, _Object$keys2 = Object.keys((_codec$parameters = codec.parameters) !== null && _codec$parameters !== void 0 ? _codec$parameters : {}); _i2 < _Object$keys2.length; _i2++) {
                var _codec$parameters;
                var key = _Object$keys2[_i2];
                if (fmtp.config) {
                  fmtp.config += ';';
                }
                fmtp.config += "".concat(key, "=").concat(codec.parameters[key]);
              }
              if (fmtp.config) {
                _this2._mediaObject.fmtp.push(fmtp);
              }
              var _iterator10 = _createForOfIteratorHelper(codec.rtcpFeedback),
                _step10;
              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var fb = _step10.value;
                  _this2._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
            }
          } catch (err) {
            _iterator0.e(err);
          } finally {
            _iterator0.f();
          }
          _this2._mediaObject.payloads = offerRtpParameters.codecs.map(function (codec) {
            return codec.payloadType;
          }).join(' ');
          _this2._mediaObject.ext = [];
          var _iterator1 = _createForOfIteratorHelper(offerRtpParameters.headerExtensions),
            _step1;
          try {
            for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
              var ext = _step1.value;
              _this2._mediaObject.ext.push({
                uri: ext.uri,
                value: ext.id
              });
            }
          } catch (err) {
            _iterator1.e(err);
          } finally {
            _iterator1.f();
          }
          _this2._mediaObject.rtcpMux = 'rtcp-mux';
          _this2._mediaObject.rtcpRsize = 'rtcp-rsize';
          var encoding = offerRtpParameters.encodings[0];
          var ssrc = encoding.ssrc;
          var rtxSsrc = (_encoding$rtx = encoding.rtx) === null || _encoding$rtx === void 0 ? void 0 : _encoding$rtx.ssrc;
          _this2._mediaObject.ssrcs = [];
          _this2._mediaObject.ssrcGroups = [];
          if (ssrc && offerRtpParameters.rtcp.cname) {
            _this2._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'cname',
              value: offerRtpParameters.rtcp.cname
            });
          }
          if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
              _this2._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: 'cname',
                value: offerRtpParameters.rtcp.cname
              });
            }
            // Associate original and retransmission SSRCs.
            if (ssrc) {
              _this2._mediaObject.ssrcGroups.push({
                semantics: 'FID',
                ssrcs: "".concat(ssrc, " ").concat(rtxSsrc)
              });
            }
          }
          break;
        }
      case 'application':
        {
          _this2._mediaObject.payloads = 'webrtc-datachannel';
          _this2._mediaObject.sctpPort = sctpParameters.port;
          _this2._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
          break;
        }
    }
    return _this2;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _inherits(OfferMediaSection, _MediaSection3);
  return _createClass(OfferMediaSection, [{
    key: "setDtlsRole",
    value: function setDtlsRole(role) {
      // Always 'actpass'.
      this._mediaObject.setup = 'actpass';
    }
  }, {
    key: "resume",
    value: function resume() {
      this._mediaObject.direction = 'sendonly';
    }
  }]);
}(MediaSection);
exports.OfferMediaSection = OfferMediaSection;
function getCodecName(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) {
    throw new TypeError('invalid codec.mimeType');
  }
  return mimeTypeMatch[2];
}

},{"../../utils":41,"sdp-transform":45}],33:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoteSdp = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../../Logger");
var MediaSection_1 = require("./MediaSection");
var DD_CODECS = ['av1', 'h264'];
var logger = new Logger_1.Logger('RemoteSdp');
var RemoteSdp = /*#__PURE__*/function () {
  function RemoteSdp(_ref) {
    var iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      plainRtpParameters = _ref.plainRtpParameters;
    _classCallCheck(this, RemoteSdp);
    // Remote ICE parameters.
    _defineProperty(this, "_iceParameters", void 0);
    // Remote ICE candidates.
    _defineProperty(this, "_iceCandidates", void 0);
    // Remote DTLS parameters.
    _defineProperty(this, "_dtlsParameters", void 0);
    // Remote SCTP parameters.
    _defineProperty(this, "_sctpParameters", void 0);
    // Parameters for plain RTP (no SRTP nor DTLS no BUNDLE).
    _defineProperty(this, "_plainRtpParameters", void 0);
    // MediaSection instances with same order as in the SDP.
    _defineProperty(this, "_mediaSections", []);
    // MediaSection indices indexed by MID.
    _defineProperty(this, "_midToIndex", new Map());
    // First MID.
    _defineProperty(this, "_firstMid", void 0);
    // SDP object.
    _defineProperty(this, "_sdpObject", void 0);
    this._iceParameters = iceParameters;
    this._iceCandidates = iceCandidates;
    this._dtlsParameters = dtlsParameters;
    this._sctpParameters = sctpParameters;
    this._plainRtpParameters = plainRtpParameters;
    this._sdpObject = {
      version: 0,
      origin: {
        address: '0.0.0.0',
        ipVer: 4,
        netType: 'IN',
        sessionId: '10000',
        sessionVersion: 0,
        username: 'mediasoup-client'
      },
      name: '-',
      timing: {
        start: 0,
        stop: 0
      },
      media: []
    };
    // Indicate support of RFC 8445 (ICE bis / ice2).
    this._sdpObject.iceOptions = 'ice2';
    // If ICE parameters are given, add ICE-Lite indicator.
    if (iceParameters !== null && iceParameters !== void 0 && iceParameters.iceLite) {
      this._sdpObject.icelite = 'ice-lite';
    }
    // If DTLS parameters are given, assume WebRTC and BUNDLE.
    if (dtlsParameters) {
      this._sdpObject.msidSemantic = {
        semantic: 'WMS',
        token: '*'
      };
      // NOTE: We take the latest fingerprint.
      var numFingerprints = this._dtlsParameters.fingerprints.length;
      this._sdpObject.fingerprint = {
        type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
        hash: dtlsParameters.fingerprints[numFingerprints - 1].value
      };
      this._sdpObject.groups = [{
        type: 'BUNDLE',
        mids: ''
      }];
    }
    // If there are plain RPT parameters, override SDP origin.
    if (plainRtpParameters) {
      this._sdpObject.origin.address = plainRtpParameters.ip;
      this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
    }
  }
  return _createClass(RemoteSdp, [{
    key: "updateIceParameters",
    value: function updateIceParameters(iceParameters) {
      logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);
      this._iceParameters = iceParameters;
      this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;
      var _iterator = _createForOfIteratorHelper(this._mediaSections),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var mediaSection = _step.value;
          mediaSection.setIceParameters(iceParameters);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "updateDtlsRole",
    value: function updateDtlsRole(role) {
      logger.debug('updateDtlsRole() [role:%s]', role);
      this._dtlsParameters.role = role;
      var _iterator2 = _createForOfIteratorHelper(this._mediaSections),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var mediaSection = _step2.value;
          mediaSection.setDtlsRole(role);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Set session level a=extmap-allow-mixed attibute.
     */
  }, {
    key: "setSessionExtmapAllowMixed",
    value: function setSessionExtmapAllowMixed() {
      logger.debug('setSessionExtmapAllowMixed()');
      this._sdpObject.extmapAllowMixed = 'extmap-allow-mixed';
    }
  }, {
    key: "getNextMediaSectionIdx",
    value: function getNextMediaSectionIdx() {
      // If a closed media section is found, return its index.
      for (var idx = 0; idx < this._mediaSections.length; ++idx) {
        var mediaSection = this._mediaSections[idx];
        if (mediaSection.closed) {
          return {
            idx: idx,
            reuseMid: mediaSection.mid
          };
        }
      }
      // If no closed media section is found, return next one.
      return {
        idx: this._mediaSections.length
      };
    }
  }, {
    key: "send",
    value: function send(_ref2) {
      var offerMediaObject = _ref2.offerMediaObject,
        reuseMid = _ref2.reuseMid,
        offerRtpParameters = _ref2.offerRtpParameters,
        answerRtpParameters = _ref2.answerRtpParameters,
        codecOptions = _ref2.codecOptions;
      var mediaSection = new MediaSection_1.AnswerMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        plainRtpParameters: this._plainRtpParameters,
        offerMediaObject: offerMediaObject,
        offerRtpParameters: offerRtpParameters,
        answerRtpParameters: answerRtpParameters,
        codecOptions: codecOptions
      });
      var mediaObject = mediaSection.getObject();
      // Remove Dependency Descriptor extension unless there is support for
      // the codec in mediasoup.
      var ddCodec = mediaObject.rtp.find(function (rtp) {
        return DD_CODECS.includes(rtp.codec.toLowerCase());
      });
      if (!ddCodec) {
        var _mediaObject$ext;
        mediaObject.ext = (_mediaObject$ext = mediaObject.ext) === null || _mediaObject$ext === void 0 ? void 0 : _mediaObject$ext.filter(function (extmap) {
          return extmap.uri !== 'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';
        });
      }
      // Unified-Plan with closed media section replacement.
      if (reuseMid) {
        this._replaceMediaSection(mediaSection, reuseMid);
      }
      // Unified-Plan or Plan-B with different media kind.
      else if (!this._midToIndex.has(mediaSection.mid)) {
        this._addMediaSection(mediaSection);
      }
      // Plan-B with same media kind.
      else {
        this._replaceMediaSection(mediaSection);
      }
    }
  }, {
    key: "receive",
    value: function receive(_ref3) {
      var mid = _ref3.mid,
        kind = _ref3.kind,
        offerRtpParameters = _ref3.offerRtpParameters,
        streamId = _ref3.streamId,
        trackId = _ref3.trackId;
      // Allow both 1 byte and 2 bytes length header extensions since
      // mediasoup can send both at any time.
      this.setSessionExtmapAllowMixed();
      var mediaSection = new MediaSection_1.OfferMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        plainRtpParameters: this._plainRtpParameters,
        mid: mid,
        kind: kind,
        offerRtpParameters: offerRtpParameters,
        streamId: streamId,
        trackId: trackId
      });
      // Let's try to recycle a closed media section (if any).
      // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
      var oldMediaSection = this._mediaSections.find(function (m) {
        return m.closed;
      });
      if (oldMediaSection) {
        this._replaceMediaSection(mediaSection, oldMediaSection.mid);
      } else {
        this._addMediaSection(mediaSection);
      }
    }
  }, {
    key: "pauseMediaSection",
    value: function pauseMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.pause();
    }
  }, {
    key: "resumeSendingMediaSection",
    value: function resumeSendingMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.resume();
    }
  }, {
    key: "resumeReceivingMediaSection",
    value: function resumeReceivingMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.resume();
    }
  }, {
    key: "disableMediaSection",
    value: function disableMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.disable();
    }
    /**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */
  }, {
    key: "closeMediaSection",
    value: function closeMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      // NOTE: Closing the first m section is a pain since it invalidates the
      // bundled transport, so let's avoid it.
      if (mid === this._firstMid) {
        logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);
        this.disableMediaSection(mid);
        return false;
      }
      mediaSection.close();
      // Regenerate BUNDLE mids.
      this._regenerateBundleMids();
      return true;
    }
  }, {
    key: "muxMediaSectionSimulcast",
    value: function muxMediaSectionSimulcast(mid, encodings) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.muxSimulcastStreams(encodings);
      this._replaceMediaSection(mediaSection);
    }
  }, {
    key: "sendSctpAssociation",
    value: function sendSctpAssociation(_ref4) {
      var offerMediaObject = _ref4.offerMediaObject;
      var mediaSection = new MediaSection_1.AnswerMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        sctpParameters: this._sctpParameters,
        plainRtpParameters: this._plainRtpParameters,
        offerMediaObject: offerMediaObject
      });
      this._addMediaSection(mediaSection);
    }
  }, {
    key: "receiveSctpAssociation",
    value: function receiveSctpAssociation() {
      var mediaSection = new MediaSection_1.OfferMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        sctpParameters: this._sctpParameters,
        plainRtpParameters: this._plainRtpParameters,
        mid: 'datachannel',
        kind: 'application'
      });
      this._addMediaSection(mediaSection);
    }
  }, {
    key: "getSdp",
    value: function getSdp() {
      // Increase SDP version.
      this._sdpObject.origin.sessionVersion++;
      return sdpTransform.write(this._sdpObject);
    }
  }, {
    key: "_addMediaSection",
    value: function _addMediaSection(newMediaSection) {
      if (!this._firstMid) {
        this._firstMid = newMediaSection.mid;
      }
      // Add to the vector.
      this._mediaSections.push(newMediaSection);
      // Add to the map.
      this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
      // Add to the SDP object.
      this._sdpObject.media.push(newMediaSection.getObject());
      // Regenerate BUNDLE mids.
      this._regenerateBundleMids();
    }
  }, {
    key: "_replaceMediaSection",
    value: function _replaceMediaSection(newMediaSection, reuseMid) {
      // Store it in the map.
      if (typeof reuseMid === 'string') {
        var idx = this._midToIndex.get(reuseMid);
        if (idx === undefined) {
          throw new Error("no media section found for reuseMid '".concat(reuseMid, "'"));
        }
        var oldMediaSection = this._mediaSections[idx];
        // Replace the index in the vector with the new media section.
        this._mediaSections[idx] = newMediaSection;
        // Update the map.
        this._midToIndex["delete"](oldMediaSection.mid);
        this._midToIndex.set(newMediaSection.mid, idx);
        // Update the SDP object.
        this._sdpObject.media[idx] = newMediaSection.getObject();
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
      } else {
        var _idx = this._midToIndex.get(newMediaSection.mid);
        if (_idx === undefined) {
          throw new Error("no media section found with mid '".concat(newMediaSection.mid, "'"));
        }
        // Replace the index in the vector with the new media section.
        this._mediaSections[_idx] = newMediaSection;
        // Update the SDP object.
        this._sdpObject.media[_idx] = newMediaSection.getObject();
      }
    }
  }, {
    key: "_findMediaSection",
    value: function _findMediaSection(mid) {
      var idx = this._midToIndex.get(mid);
      if (idx === undefined) {
        throw new Error("no media section found with mid '".concat(mid, "'"));
      }
      return this._mediaSections[idx];
    }
  }, {
    key: "_regenerateBundleMids",
    value: function _regenerateBundleMids() {
      if (!this._dtlsParameters) {
        return;
      }
      this._sdpObject.groups[0].mids = this._mediaSections.filter(function (mediaSection) {
        return !mediaSection.closed;
      }).map(function (mediaSection) {
        return mediaSection.mid;
      }).join(' ');
    }
  }]);
}();
exports.RemoteSdp = RemoteSdp;

},{"../../Logger":19,"./MediaSection":32,"sdp-transform":45}],34:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractRtpCapabilities = extractRtpCapabilities;
exports.extractDtlsParameters = extractDtlsParameters;
exports.getCname = getCname;
exports.applyCodecParameters = applyCodecParameters;
var sdpTransform = require("sdp-transform");
/**
 * This function extracs RTP capabilities from the given SDP.
 *
 * BUNDLE is assumed so, as per spec, all media sections in the SDP must share
 * same ids for codecs and RTP extensions.
 */
function extractRtpCapabilities(_ref) {
  var sdpObject = _ref.sdpObject;
  // Map of RtpCodecParameters indexed by payload type.
  var codecsMap = new Map();
  // Map of RtpHeaderExtensions indexed by preferred id.
  var headerExtensionMap = new Map();
  var _iterator = _createForOfIteratorHelper(sdpObject.media),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _m$fmtp, _m$rtcpFb, _m$ext;
      var m = _step.value;
      var kind = m.type;
      switch (kind) {
        case 'audio':
        case 'video':
          {
            break;
          }
        default:
          {
            continue;
          }
      }
      // Get codecs.
      var _iterator2 = _createForOfIteratorHelper(m.rtp),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var rtp = _step2.value;
          var codec = {
            kind: kind,
            mimeType: "".concat(kind, "/").concat(rtp.codec),
            preferredPayloadType: rtp.payload,
            clockRate: rtp.rate,
            channels: rtp.encoding,
            parameters: {},
            rtcpFeedback: []
          };
          codecsMap.set(codec.preferredPayloadType, codec);
        }
        // Get codec parameters.
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper((_m$fmtp = m.fmtp) !== null && _m$fmtp !== void 0 ? _m$fmtp : []),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var fmtp = _step3.value;
          var parameters = sdpTransform.parseParams(fmtp.config);
          var _codec = codecsMap.get(fmtp.payload);
          if (!_codec) {
            continue;
          }
          // Specials cases to convert parameter value to string.
          if (parameters !== null && parameters !== void 0 && parameters.hasOwnProperty('profile-level-id')) {
            parameters['profile-level-id'] = String(parameters['profile-level-id']);
          }
          _codec.parameters = parameters;
        }
        // Get RTCP feedback for each codec.
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var _iterator4 = _createForOfIteratorHelper((_m$rtcpFb = m.rtcpFb) !== null && _m$rtcpFb !== void 0 ? _m$rtcpFb : []),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var fb = _step4.value;
          var feedback = {
            type: fb.type,
            parameter: fb.subtype
          };
          if (!feedback.parameter) {
            delete feedback.parameter;
          }
          // rtcp-fb payload is not '*', so just apply it to its corresponding
          // codec.
          if (fb.payload !== '*') {
            var _codec2 = codecsMap.get(Number(fb.payload));
            if (!_codec2) {
              continue;
            }
            _codec2.rtcpFeedback.push(feedback);
          }
          // If rtcp-fb payload is '*' it must be applied to all codecs with same
          // kind (with some exceptions such as RTX codec).
          else {
            var _iterator6 = _createForOfIteratorHelper(codecsMap.values()),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _codec3 = _step6.value;
                if (_codec3.kind === kind && !/.+\/rtx$/i.test(_codec3.mimeType)) {
                  _codec3.rtcpFeedback.push(feedback);
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
        }
        // Get RTP header extensions.
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      var _iterator5 = _createForOfIteratorHelper((_m$ext = m.ext) !== null && _m$ext !== void 0 ? _m$ext : []),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ext = _step5.value;
          // Ignore encrypted extensions (not yet supported in mediasoup).
          if (ext['encrypt-uri']) {
            continue;
          }
          var headerExtension = {
            kind: kind,
            uri: ext.uri,
            preferredId: ext.value
          };
          headerExtensionMap.set(headerExtension.preferredId, headerExtension);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var rtpCapabilities = {
    codecs: Array.from(codecsMap.values()),
    headerExtensions: Array.from(headerExtensionMap.values())
  };
  return rtpCapabilities;
}
function extractDtlsParameters(_ref2) {
  var sdpObject = _ref2.sdpObject;
  var setup = sdpObject.setup;
  var fingerprint = sdpObject.fingerprint;
  if (!setup || !fingerprint) {
    var _sdpObject$media;
    var mediaObject = ((_sdpObject$media = sdpObject.media) !== null && _sdpObject$media !== void 0 ? _sdpObject$media : []).find(function (m) {
      return m.port !== 0;
    });
    if (mediaObject) {
      setup !== null && setup !== void 0 ? setup : setup = mediaObject.setup;
      fingerprint !== null && fingerprint !== void 0 ? fingerprint : fingerprint = mediaObject.fingerprint;
    }
  }
  if (!setup) {
    throw new Error('no a=setup found at SDP session or media level');
  } else if (!fingerprint) {
    throw new Error('no a=fingerprint found at SDP session or media level');
  }
  var role;
  switch (setup) {
    case 'active':
      {
        role = 'client';
        break;
      }
    case 'passive':
      {
        role = 'server';
        break;
      }
    case 'actpass':
      {
        role = 'auto';
        break;
      }
  }
  var dtlsParameters = {
    role: role,
    fingerprints: [{
      algorithm: fingerprint.type,
      value: fingerprint.hash
    }]
  };
  return dtlsParameters;
}
function getCname(_ref3) {
  var _offerMediaObject$ssr;
  var offerMediaObject = _ref3.offerMediaObject;
  var ssrcCnameLine = ((_offerMediaObject$ssr = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr !== void 0 ? _offerMediaObject$ssr : []).find(function (line) {
    return line.attribute === 'cname';
  });
  if (!ssrcCnameLine) {
    return '';
  }
  return ssrcCnameLine.value;
}
/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */
function applyCodecParameters(_ref4) {
  var offerRtpParameters = _ref4.offerRtpParameters,
    answerMediaObject = _ref4.answerMediaObject;
  var _iterator7 = _createForOfIteratorHelper(offerRtpParameters.codecs),
    _step7;
  try {
    var _loop = function _loop() {
        var _answerMediaObject$rt, _answerMediaObject$fm;
        var codec = _step7.value;
        var mimeType = codec.mimeType.toLowerCase();
        // Avoid parsing codec parameters for unhandled codecs.
        if (mimeType !== 'audio/opus') {
          return 0; // continue
        }
        var rtp = ((_answerMediaObject$rt = answerMediaObject.rtp) !== null && _answerMediaObject$rt !== void 0 ? _answerMediaObject$rt : []).find(function (r) {
          return r.payload === codec.payloadType;
        });
        if (!rtp) {
          return 0; // continue
        }
        // Just in case.
        answerMediaObject.fmtp = (_answerMediaObject$fm = answerMediaObject.fmtp) !== null && _answerMediaObject$fm !== void 0 ? _answerMediaObject$fm : [];
        var fmtp = answerMediaObject.fmtp.find(function (f) {
          return f.payload === codec.payloadType;
        });
        if (!fmtp) {
          fmtp = {
            payload: codec.payloadType,
            config: ''
          };
          answerMediaObject.fmtp.push(fmtp);
        }
        var parameters = sdpTransform.parseParams(fmtp.config);
        switch (mimeType) {
          case 'audio/opus':
            {
              var _codec$parameters;
              var spropStereo = (_codec$parameters = codec.parameters) === null || _codec$parameters === void 0 ? void 0 : _codec$parameters['sprop-stereo'];
              if (spropStereo !== undefined) {
                parameters['stereo'] = Number(spropStereo) ? 1 : 0;
              }
              break;
            }
        }
        // Write the codec fmtp.config back.
        fmtp.config = '';
        for (var _i = 0, _Object$keys = Object.keys(parameters); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          if (fmtp.config) {
            fmtp.config += ';';
          }
          fmtp.config += "".concat(key, "=").concat(parameters[key]);
        }
      },
      _ret;
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      _ret = _loop();
      if (_ret === 0) continue;
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
}

},{"sdp-transform":45}],35:[function(require,module,exports){
"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRtpEncodings = getRtpEncodings;
exports.addLegacySimulcast = addLegacySimulcast;
function getRtpEncodings(_ref) {
  var _offerMediaObject$ssr, _offerMediaObject$ssr2;
  var offerMediaObject = _ref.offerMediaObject;
  var ssrcs = new Set();
  var _iterator = _createForOfIteratorHelper((_offerMediaObject$ssr = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr !== void 0 ? _offerMediaObject$ssr : []),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;
      var ssrc = line.id;
      if (ssrc) {
        ssrcs.add(ssrc);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (ssrcs.size === 0) {
    throw new Error('no a=ssrc lines found');
  }
  var ssrcToRtxSsrc = new Map();
  // First assume RTX is used.
  var _iterator2 = _createForOfIteratorHelper((_offerMediaObject$ssr2 = offerMediaObject.ssrcGroups) !== null && _offerMediaObject$ssr2 !== void 0 ? _offerMediaObject$ssr2 : []),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _line = _step2.value;
      if (_line.semantics !== 'FID') {
        continue;
      }
      var ssrcsStr = _line.ssrcs.split(/\s+/);
      var _ssrc = Number(ssrcsStr[0]);
      var rtxSsrc = Number(ssrcsStr[1]);
      if (ssrcs.has(_ssrc)) {
        // Remove both the SSRC and RTX SSRC from the set so later we know
        // that they are already handled.
        ssrcs["delete"](_ssrc);
        ssrcs["delete"](rtxSsrc);
        // Add to the map.
        ssrcToRtxSsrc.set(_ssrc, rtxSsrc);
      }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so
    // take media SSRCs from there.
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var _iterator3 = _createForOfIteratorHelper(ssrcs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _ssrc2 = _step3.value;
      // Add to the map.
      ssrcToRtxSsrc.set(_ssrc2, undefined);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var encodings = [];
  var _iterator4 = _createForOfIteratorHelper(ssrcToRtxSsrc),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 2),
        _ssrc3 = _step4$value[0],
        _rtxSsrc = _step4$value[1];
      var encoding = {
        ssrc: _ssrc3
      };
      if (_rtxSsrc) {
        encoding.rtx = {
          ssrc: _rtxSsrc
        };
      }
      encodings.push(encoding);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return encodings;
}
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast(_ref2) {
  var _offerMediaObject$ssr3, _offerMediaObject$ssr4, _offerMediaObject$ssr5;
  var offerMediaObject = _ref2.offerMediaObject,
    numStreams = _ref2.numStreams;
  if (numStreams <= 1) {
    throw new TypeError('numStreams must be greater than 1');
  }
  // Get the SSRC.
  var ssrcMsidLine = ((_offerMediaObject$ssr3 = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr3 !== void 0 ? _offerMediaObject$ssr3 : []).find(function (line) {
    return line.attribute === 'msid';
  });
  if (!ssrcMsidLine) {
    throw new Error('a=ssrc line with msid information not found');
  }
  var _ssrcMsidLine$value$s = ssrcMsidLine.value.split(' '),
    _ssrcMsidLine$value$s2 = _slicedToArray(_ssrcMsidLine$value$s, 2),
    streamId = _ssrcMsidLine$value$s2[0],
    trackId = _ssrcMsidLine$value$s2[1];
  var firstSsrc = Number(ssrcMsidLine.id);
  var firstRtxSsrc;
  // Get the SSRC for RTX.
  ((_offerMediaObject$ssr4 = offerMediaObject.ssrcGroups) !== null && _offerMediaObject$ssr4 !== void 0 ? _offerMediaObject$ssr4 : []).some(function (line) {
    if (line.semantics !== 'FID') {
      return false;
    }
    var ssrcs = line.ssrcs.split(/\s+/);
    if (Number(ssrcs[0]) === firstSsrc) {
      firstRtxSsrc = Number(ssrcs[1]);
      return true;
    } else {
      return false;
    }
  });
  var ssrcCnameLine = ((_offerMediaObject$ssr5 = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr5 !== void 0 ? _offerMediaObject$ssr5 : []).find(function (line) {
    return line.attribute === 'cname';
  });
  if (!ssrcCnameLine) {
    throw new Error('a=ssrc line with cname information not found');
  }
  var cname = ssrcCnameLine.value;
  var ssrcs = [];
  var rtxSsrcs = [];
  for (var i = 0; i < numStreams; ++i) {
    ssrcs.push(firstSsrc + i);
    if (firstRtxSsrc) {
      rtxSsrcs.push(firstRtxSsrc + i);
    }
  }
  offerMediaObject.ssrcGroups = [];
  offerMediaObject.ssrcs = [];
  offerMediaObject.ssrcGroups.push({
    semantics: 'SIM',
    ssrcs: ssrcs.join(' ')
  });
  for (var _i = 0, _ssrcs = ssrcs; _i < _ssrcs.length; _i++) {
    var ssrc = _ssrcs[_i];
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(trackId)
    });
  }
  for (var _i2 = 0; _i2 < rtxSsrcs.length; ++_i2) {
    var _ssrc4 = ssrcs[_i2];
    var rtxSsrc = rtxSsrcs[_i2];
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(trackId)
    });
    offerMediaObject.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(_ssrc4, " ").concat(rtxSsrc)
    });
  }
}

},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debug = exports.testFakeParameters = exports.FakeHandler = exports.enhancedEvents = exports.ortc = exports.parseScalabilityMode = exports.detectDeviceAsync = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
var debug_1 = require("debug");
exports.debug = debug_1["default"];
/**
 * Expose all types.
 */
exports.types = require("./types");
/**
 * Expose mediasoup-client version.
 */
exports.version = '3.16.4';
/**
 * Expose Device class and device detector helpers.
 */
var Device_1 = require("./Device");
Object.defineProperty(exports, "Device", {
  enumerable: true,
  get: function get() {
    return Device_1.Device;
  }
});
Object.defineProperty(exports, "detectDevice", {
  enumerable: true,
  get: function get() {
    return Device_1.detectDevice;
  }
});
Object.defineProperty(exports, "detectDeviceAsync", {
  enumerable: true,
  get: function get() {
    return Device_1.detectDeviceAsync;
  }
});
/**
 * Expose parseScalabilityMode() function.
 */
var scalabilityModes_1 = require("./scalabilityModes");
Object.defineProperty(exports, "parseScalabilityMode", {
  enumerable: true,
  get: function get() {
    return scalabilityModes_1.parse;
  }
});
/**
 * Expose all ORTC functions.
 */
exports.ortc = require("./ortc");
/**
 * Expose enhanced events.
 */
exports.enhancedEvents = require("./enhancedEvents");
/**
 * Expose FakeHandler.
 */
var FakeHandler_1 = require("./handlers/FakeHandler");
Object.defineProperty(exports, "FakeHandler", {
  enumerable: true,
  get: function get() {
    return FakeHandler_1.FakeHandler;
  }
});
/**
 * Expose test/fakeParameters utils.
 */
exports.testFakeParameters = require("./test/fakeParameters");

},{"./Device":18,"./enhancedEvents":22,"./handlers/FakeHandler":26,"./ortc":37,"./scalabilityModes":38,"./test/fakeParameters":39,"./types":40,"debug":6}],37:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateAndNormalizeRtpCapabilities = validateAndNormalizeRtpCapabilities;
exports.validateAndNormalizeRtpParameters = validateAndNormalizeRtpParameters;
exports.validateAndNormalizeSctpStreamParameters = validateAndNormalizeSctpStreamParameters;
exports.validateSctpCapabilities = validateSctpCapabilities;
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
exports.getSendingRtpParameters = getSendingRtpParameters;
exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
exports.reduceCodecs = reduceCodecs;
exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
exports.canSend = canSend;
exports.canReceive = canReceive;
var h264 = require("h264-profile-level-id");
var utils = require("./utils");
var RTP_PROBATOR_MID = 'probator';
var RTP_PROBATOR_SSRC = 1234;
var RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpCapabilities(caps) {
  if (_typeof(caps) !== 'object') {
    throw new TypeError('caps is not an object');
  }
  // codecs is optional. If unset, fill with an empty array.
  if (caps.codecs && !Array.isArray(caps.codecs)) {
    throw new TypeError('caps.codecs is not an array');
  } else if (!caps.codecs) {
    caps.codecs = [];
  }
  var _iterator = _createForOfIteratorHelper(caps.codecs),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var codec = _step.value;
      validateAndNormalizeRtpCodecCapability(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
    throw new TypeError('caps.headerExtensions is not an array');
  } else if (!caps.headerExtensions) {
    caps.headerExtensions = [];
  }
  var _iterator2 = _createForOfIteratorHelper(caps.headerExtensions),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var ext = _step2.value;
      validateAndNormalizeRtpHeaderExtension(ext);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpParameters(params) {
  if (_typeof(params) !== 'object') {
    throw new TypeError('params is not an object');
  }
  // mid is optional.
  if (params.mid && typeof params.mid !== 'string') {
    throw new TypeError('params.mid is not a string');
  }
  // codecs is mandatory.
  if (!Array.isArray(params.codecs)) {
    throw new TypeError('missing params.codecs');
  }
  var _iterator3 = _createForOfIteratorHelper(params.codecs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var codec = _step3.value;
      validateAndNormalizeRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
    throw new TypeError('params.headerExtensions is not an array');
  } else if (!params.headerExtensions) {
    params.headerExtensions = [];
  }
  var _iterator4 = _createForOfIteratorHelper(params.headerExtensions),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var ext = _step4.value;
      validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  if (params.encodings && !Array.isArray(params.encodings)) {
    throw new TypeError('params.encodings is not an array');
  } else if (!params.encodings) {
    params.encodings = [];
  }
  var _iterator5 = _createForOfIteratorHelper(params.encodings),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var encoding = _step5.value;
      validateAndNormalizeRtpEncodingParameters(encoding);
    }
    // rtcp is optional. If unset, fill with an empty object.
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (params.rtcp && _typeof(params.rtcp) !== 'object') {
    throw new TypeError('params.rtcp is not an object');
  } else if (!params.rtcp) {
    params.rtcp = {};
  }
  validateAndNormalizeRtcpParameters(params.rtcp);
}
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeSctpStreamParameters(params) {
  if (_typeof(params) !== 'object') {
    throw new TypeError('params is not an object');
  }
  // streamId is mandatory.
  if (typeof params.streamId !== 'number') {
    throw new TypeError('missing params.streamId');
  }
  // ordered is optional.
  var orderedGiven = false;
  if (typeof params.ordered === 'boolean') {
    orderedGiven = true;
  } else {
    params.ordered = true;
  }
  // maxPacketLifeTime is optional.
  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') {
    throw new TypeError('invalid params.maxPacketLifeTime');
  }
  // maxRetransmits is optional.
  if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {
    throw new TypeError('invalid params.maxRetransmits');
  }
  if (params.maxPacketLifeTime && params.maxRetransmits) {
    throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
  }
  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {
    throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
    params.ordered = false;
  }
  // label is optional.
  if (params.label && typeof params.label !== 'string') {
    throw new TypeError('invalid params.label');
  }
  // protocol is optional.
  if (params.protocol && typeof params.protocol !== 'string') {
    throw new TypeError('invalid params.protocol');
  }
}
/**
 * Validates SctpCapabilities.
 * It throws if invalid.
 */
function validateSctpCapabilities(caps) {
  if (_typeof(caps) !== 'object') {
    throw new TypeError('caps is not an object');
  }
  // numStreams is mandatory.
  if (!caps.numStreams || _typeof(caps.numStreams) !== 'object') {
    throw new TypeError('missing caps.numStreams');
  }
  validateNumSctpStreams(caps.numStreams);
}
/**
 * Generate extended RTP capabilities for sending and receiving.
 *
 * Resulting codecs keep order preferred by local or remote capabilities
 * depending on `preferLocalCodecsOrder`.
 */
function getExtendedRtpCapabilities(localCaps, remoteCaps, preferLocalCodecsOrder) {
  var extendedRtpCapabilities = {
    codecs: [],
    headerExtensions: []
  };
  // Match media codecs and keep the order preferred by local capabilities.
  if (preferLocalCodecsOrder) {
    var _localCaps$codecs;
    var _iterator6 = _createForOfIteratorHelper((_localCaps$codecs = localCaps.codecs) !== null && _localCaps$codecs !== void 0 ? _localCaps$codecs : []),
      _step6;
    try {
      var _loop = function _loop() {
          var _remoteCaps$codecs, _localCodec$parameter, _matchingRemoteCodec$;
          var localCodec = _step6.value;
          if (isRtxCodec(localCodec)) {
            return 0; // continue
          }
          var matchingRemoteCodec = ((_remoteCaps$codecs = remoteCaps.codecs) !== null && _remoteCaps$codecs !== void 0 ? _remoteCaps$codecs : []).find(function (remoteCodec) {
            return matchCodecs(remoteCodec, localCodec, {
              strict: true,
              modify: true
            });
          });
          if (!matchingRemoteCodec) {
            return 0; // continue
          }
          var extendedCodec = {
            kind: localCodec.kind,
            mimeType: localCodec.mimeType,
            clockRate: localCodec.clockRate,
            channels: localCodec.channels,
            localPayloadType: localCodec.preferredPayloadType,
            localRtxPayloadType: undefined,
            remotePayloadType: matchingRemoteCodec.preferredPayloadType,
            remoteRtxPayloadType: undefined,
            localParameters: (_localCodec$parameter = localCodec.parameters) !== null && _localCodec$parameter !== void 0 ? _localCodec$parameter : {},
            remoteParameters: (_matchingRemoteCodec$ = matchingRemoteCodec.parameters) !== null && _matchingRemoteCodec$ !== void 0 ? _matchingRemoteCodec$ : {},
            rtcpFeedback: reduceRtcpFeedback(localCodec, matchingRemoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        },
        _ret;
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        _ret = _loop();
        if (_ret === 0) continue;
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
  }
  // Match media codecs and keep the order preferred by remote capabilities.
  else {
    var _remoteCaps$codecs2;
    var _iterator7 = _createForOfIteratorHelper((_remoteCaps$codecs2 = remoteCaps.codecs) !== null && _remoteCaps$codecs2 !== void 0 ? _remoteCaps$codecs2 : []),
      _step7;
    try {
      var _loop2 = function _loop2() {
          var _localCaps$codecs2, _matchingLocalCodec$p, _remoteCodec$paramete;
          var remoteCodec = _step7.value;
          if (isRtxCodec(remoteCodec)) {
            return 0; // continue
          }
          var matchingLocalCodec = ((_localCaps$codecs2 = localCaps.codecs) !== null && _localCaps$codecs2 !== void 0 ? _localCaps$codecs2 : []).find(function (localCodec) {
            return matchCodecs(localCodec, remoteCodec, {
              strict: true,
              modify: true
            });
          });
          if (!matchingLocalCodec) {
            return 0; // continue
          }
          var extendedCodec = {
            kind: matchingLocalCodec.kind,
            mimeType: matchingLocalCodec.mimeType,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: undefined,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: undefined,
            localParameters: (_matchingLocalCodec$p = matchingLocalCodec.parameters) !== null && _matchingLocalCodec$p !== void 0 ? _matchingLocalCodec$p : {},
            remoteParameters: (_remoteCodec$paramete = remoteCodec.parameters) !== null && _remoteCodec$paramete !== void 0 ? _remoteCodec$paramete : {},
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        },
        _ret2;
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        _ret2 = _loop2();
        if (_ret2 === 0) continue;
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }
  // Match RTX codecs.
  var _iterator8 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step8;
  try {
    var _loop3 = function _loop3() {
      var extendedCodec = _step8.value;
      var matchingLocalRtxCodec = localCaps.codecs.find(function (localCodec) {
        var _localCodec$parameter2;
        return isRtxCodec(localCodec) && ((_localCodec$parameter2 = localCodec.parameters) === null || _localCodec$parameter2 === void 0 ? void 0 : _localCodec$parameter2['apt']) === extendedCodec.localPayloadType;
      });
      var matchingRemoteRtxCodec = remoteCaps.codecs.find(function (remoteCodec) {
        var _remoteCodec$paramete2;
        return isRtxCodec(remoteCodec) && ((_remoteCodec$paramete2 = remoteCodec.parameters) === null || _remoteCodec$paramete2 === void 0 ? void 0 : _remoteCodec$paramete2['apt']) === extendedCodec.remotePayloadType;
      });
      if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
        extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
        extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
      }
    };
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      _loop3();
    }
    // Match header extensions.
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  var _iterator9 = _createForOfIteratorHelper(remoteCaps.headerExtensions),
    _step9;
  try {
    var _loop4 = function _loop4() {
      var _matchingLocalExt$pre;
      var remoteExt = _step9.value;
      var matchingLocalExt = localCaps.headerExtensions.find(function (localExt) {
        return matchHeaderExtensions(localExt, remoteExt);
      });
      if (!matchingLocalExt) {
        return 1; // continue
      }
      var extendedExt = {
        kind: remoteExt.kind,
        uri: remoteExt.uri,
        sendId: matchingLocalExt.preferredId,
        recvId: remoteExt.preferredId,
        encrypt: (_matchingLocalExt$pre = matchingLocalExt.preferredEncrypt) !== null && _matchingLocalExt$pre !== void 0 ? _matchingLocalExt$pre : false,
        direction: 'sendrecv'
      };
      switch (remoteExt.direction) {
        case 'sendrecv':
          {
            extendedExt.direction = 'sendrecv';
            break;
          }
        case 'recvonly':
          {
            extendedExt.direction = 'sendonly';
            break;
          }
        case 'sendonly':
          {
            extendedExt.direction = 'recvonly';
            break;
          }
        case 'inactive':
          {
            extendedExt.direction = 'inactive';
            break;
          }
      }
      extendedRtpCapabilities.headerExtensions.push(extendedExt);
    };
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      if (_loop4()) continue;
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }
  return extendedRtpCapabilities;
}
/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */
function getRecvRtpCapabilities(extendedRtpCapabilities) {
  var rtpCapabilities = {
    codecs: [],
    headerExtensions: []
  };
  var _iterator0 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step0;
  try {
    for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
      var extendedCodec = _step0.value;
      var codec = {
        kind: extendedCodec.kind,
        mimeType: extendedCodec.mimeType,
        preferredPayloadType: extendedCodec.remotePayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.localParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpCapabilities.codecs.push(codec);
      // Add RTX codec.
      if (!extendedCodec.remoteRtxPayloadType) {
        continue;
      }
      var rtxCodec = {
        kind: extendedCodec.kind,
        mimeType: "".concat(extendedCodec.kind, "/rtx"),
        preferredPayloadType: extendedCodec.remoteRtxPayloadType,
        clockRate: extendedCodec.clockRate,
        parameters: {
          apt: extendedCodec.remotePayloadType
        },
        rtcpFeedback: []
      };
      rtpCapabilities.codecs.push(rtxCodec);
      // TODO: In the future, we need to add FEC, CN, etc, codecs.
    }
  } catch (err) {
    _iterator0.e(err);
  } finally {
    _iterator0.f();
  }
  var _iterator1 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step1;
  try {
    for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
      var _extendedExtension$en;
      var extendedExtension = _step1.value;
      // Ignore RTP extensions not valid for receiving.
      if (extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'recvonly') {
        continue;
      }
      var ext = {
        kind: extendedExtension.kind,
        uri: extendedExtension.uri,
        preferredId: extendedExtension.recvId,
        preferredEncrypt: (_extendedExtension$en = extendedExtension.encrypt) !== null && _extendedExtension$en !== void 0 ? _extendedExtension$en : false,
        direction: extendedExtension.direction
      };
      rtpCapabilities.headerExtensions.push(ext);
    }
  } catch (err) {
    _iterator1.e(err);
  } finally {
    _iterator1.f();
  }
  return rtpCapabilities;
}
/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */
function getSendingRtpParameters(kind, extendedRtpCapabilities) {
  var rtpParameters = {
    mid: undefined,
    codecs: [],
    headerExtensions: [],
    encodings: [],
    rtcp: {}
  };
  var _iterator10 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step10;
  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var extendedCodec = _step10.value;
      if (extendedCodec.kind !== kind) {
        continue;
      }
      var codec = {
        mimeType: extendedCodec.mimeType,
        payloadType: extendedCodec.localPayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.localParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpParameters.codecs.push(codec);
      // Add RTX codec.
      if (extendedCodec.localRtxPayloadType) {
        var rtxCodec = {
          mimeType: "".concat(extendedCodec.kind, "/rtx"),
          payloadType: extendedCodec.localRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.localPayloadType
          },
          rtcpFeedback: []
        };
        rtpParameters.codecs.push(rtxCodec);
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }
  var _iterator11 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step11;
  try {
    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var extendedExtension = _step11.value;
      // Ignore RTP extensions of a different kind and those not valid for sending.
      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {
        continue;
      }
      var ext = {
        uri: extendedExtension.uri,
        id: extendedExtension.sendId,
        encrypt: extendedExtension.encrypt,
        parameters: {}
      };
      rtpParameters.headerExtensions.push(ext);
    }
  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }
  return rtpParameters;
}
/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */
function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
  var rtpParameters = {
    mid: undefined,
    codecs: [],
    headerExtensions: [],
    encodings: [],
    rtcp: {}
  };
  var _iterator12 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step12;
  try {
    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
      var extendedCodec = _step12.value;
      if (extendedCodec.kind !== kind) {
        continue;
      }
      var _codec3 = {
        mimeType: extendedCodec.mimeType,
        payloadType: extendedCodec.localPayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.remoteParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpParameters.codecs.push(_codec3);
      // Add RTX codec.
      if (extendedCodec.localRtxPayloadType) {
        var rtxCodec = {
          mimeType: "".concat(extendedCodec.kind, "/rtx"),
          payloadType: extendedCodec.localRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.localPayloadType
          },
          rtcpFeedback: []
        };
        rtpParameters.codecs.push(rtxCodec);
      }
    }
  } catch (err) {
    _iterator12.e(err);
  } finally {
    _iterator12.f();
  }
  var _iterator13 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step13;
  try {
    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
      var extendedExtension = _step13.value;
      // Ignore RTP extensions of a different kind and those not valid for sending.
      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {
        continue;
      }
      var ext = {
        uri: extendedExtension.uri,
        id: extendedExtension.sendId,
        encrypt: extendedExtension.encrypt,
        parameters: {}
      };
      rtpParameters.headerExtensions.push(ext);
    }
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
  } catch (err) {
    _iterator13.e(err);
  } finally {
    _iterator13.f();
  }
  if (rtpParameters.headerExtensions.some(function (ext) {
    return ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01';
  })) {
    var _iterator14 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step14;
    try {
      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
        var _codec$rtcpFeedback;
        var codec = _step14.value;
        codec.rtcpFeedback = ((_codec$rtcpFeedback = codec.rtcpFeedback) !== null && _codec$rtcpFeedback !== void 0 ? _codec$rtcpFeedback : []).filter(function (fb) {
          return fb.type !== 'goog-remb';
        });
      }
    } catch (err) {
      _iterator14.e(err);
    } finally {
      _iterator14.f();
    }
  } else if (rtpParameters.headerExtensions.some(function (ext) {
    return ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time';
  })) {
    var _iterator15 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step15;
    try {
      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
        var _codec$rtcpFeedback2;
        var _codec = _step15.value;
        _codec.rtcpFeedback = ((_codec$rtcpFeedback2 = _codec.rtcpFeedback) !== null && _codec$rtcpFeedback2 !== void 0 ? _codec$rtcpFeedback2 : []).filter(function (fb) {
          return fb.type !== 'transport-cc';
        });
      }
    } catch (err) {
      _iterator15.e(err);
    } finally {
      _iterator15.f();
    }
  } else {
    var _iterator16 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step16;
    try {
      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
        var _codec2$rtcpFeedback;
        var _codec2 = _step16.value;
        _codec2.rtcpFeedback = ((_codec2$rtcpFeedback = _codec2.rtcpFeedback) !== null && _codec2$rtcpFeedback !== void 0 ? _codec2$rtcpFeedback : []).filter(function (fb) {
          return fb.type !== 'transport-cc' && fb.type !== 'goog-remb';
        });
      }
    } catch (err) {
      _iterator16.e(err);
    } finally {
      _iterator16.f();
    }
  }
  return rtpParameters;
}
/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */
function reduceCodecs(codecs, capCodec) {
  var filteredCodecs = [];
  // If no capability codec is given, take the first one (and RTX).
  if (!capCodec) {
    filteredCodecs.push(codecs[0]);
    if (isRtxCodec(codecs[1])) {
      filteredCodecs.push(codecs[1]);
    }
  }
  // Otherwise look for a compatible set of codecs.
  else {
    for (var idx = 0; idx < codecs.length; ++idx) {
      if (matchCodecs(codecs[idx], capCodec, {
        strict: true
      })) {
        filteredCodecs.push(codecs[idx]);
        if (isRtxCodec(codecs[idx + 1])) {
          filteredCodecs.push(codecs[idx + 1]);
        }
        break;
      }
    }
    if (filteredCodecs.length === 0) {
      throw new TypeError('no matching codec found');
    }
  }
  return filteredCodecs;
}
/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */
function generateProbatorRtpParameters(videoRtpParameters) {
  // Clone given reference video RTP parameters.
  videoRtpParameters = utils.clone(videoRtpParameters);
  // This may throw.
  validateAndNormalizeRtpParameters(videoRtpParameters);
  var rtpParameters = {
    mid: RTP_PROBATOR_MID,
    codecs: [],
    headerExtensions: [],
    encodings: [{
      ssrc: RTP_PROBATOR_SSRC
    }],
    rtcp: {
      cname: 'probator'
    }
  };
  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
  return rtpParameters;
}
/**
 * Whether media can be sent based on the given RTP capabilities.
 */
function canSend(kind, rtpCapabilities) {
  var _rtpCapabilities$code;
  return ((_rtpCapabilities$code = rtpCapabilities.codecs) !== null && _rtpCapabilities$code !== void 0 ? _rtpCapabilities$code : []).some(function (codec) {
    return codec.kind === kind;
  });
}
/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */
function canReceive(rtpParameters, rtpCapabilities) {
  var _rtpCapabilities$code2;
  // This may throw.
  validateAndNormalizeRtpParameters(rtpParameters);
  if (rtpParameters.codecs.length === 0) {
    return false;
  }
  var firstMediaCodec = rtpParameters.codecs[0];
  return ((_rtpCapabilities$code2 = rtpCapabilities.codecs) !== null && _rtpCapabilities$code2 !== void 0 ? _rtpCapabilities$code2 : []).some(function (codec) {
    return codec.preferredPayloadType === firstMediaCodec.payloadType;
  });
}
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpCodecCapability(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  if (_typeof(codec) !== 'object') {
    throw new TypeError('codec is not an object');
  }
  // mimeType is mandatory.
  if (!codec.mimeType || typeof codec.mimeType !== 'string') {
    throw new TypeError('missing codec.mimeType');
  }
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) {
    throw new TypeError('invalid codec.mimeType');
  }
  // Just override kind with media component of mimeType.
  codec.kind = mimeTypeMatch[1].toLowerCase();
  // preferredPayloadType is mandatory.
  if (typeof codec.preferredPayloadType !== 'number') {
    throw new TypeError('missing codec.preferredPayloadType');
  }
  // clockRate is mandatory.
  if (typeof codec.clockRate !== 'number') {
    throw new TypeError('missing codec.clockRate');
  }
  // channels is optional. If unset, set it to 1 (just if audio).
  if (codec.kind === 'audio') {
    if (typeof codec.channels !== 'number') {
      codec.channels = 1;
    }
  } else {
    delete codec.channels;
  }
  // parameters is optional. If unset, set it to an empty object.
  if (!codec.parameters || _typeof(codec.parameters) !== 'object') {
    codec.parameters = {};
  }
  for (var _i = 0, _Object$keys = Object.keys(codec.parameters); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var value = codec.parameters[key];
    if (value === undefined) {
      codec.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new TypeError("invalid codec parameter [key:".concat(key, "s, value:").concat(value, "]"));
    }
    // Specific parameters validation.
    if (key === 'apt') {
      if (typeof value !== 'number') {
        throw new TypeError('invalid codec apt parameter');
      }
    }
  }
  // rtcpFeedback is optional. If unset, set it to an empty array.
  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
    codec.rtcpFeedback = [];
  }
  var _iterator17 = _createForOfIteratorHelper(codec.rtcpFeedback),
    _step17;
  try {
    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
      var fb = _step17.value;
      validateAndNormalizeRtcpFeedback(fb);
    }
  } catch (err) {
    _iterator17.e(err);
  } finally {
    _iterator17.f();
  }
}
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtcpFeedback(fb) {
  if (_typeof(fb) !== 'object') {
    throw new TypeError('fb is not an object');
  }
  // type is mandatory.
  if (!fb.type || typeof fb.type !== 'string') {
    throw new TypeError('missing fb.type');
  }
  // parameter is optional. If unset set it to an empty string.
  if (!fb.parameter || typeof fb.parameter !== 'string') {
    fb.parameter = '';
  }
}
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpHeaderExtension(ext) {
  if (_typeof(ext) !== 'object') {
    throw new TypeError('ext is not an object');
  }
  // kind is mandatory.
  if (ext.kind !== 'audio' && ext.kind !== 'video') {
    throw new TypeError('invalid ext.kind');
  }
  // uri is mandatory.
  if (!ext.uri || typeof ext.uri !== 'string') {
    throw new TypeError('missing ext.uri');
  }
  // preferredId is mandatory.
  if (typeof ext.preferredId !== 'number') {
    throw new TypeError('missing ext.preferredId');
  }
  // preferredEncrypt is optional. If unset set it to false.
  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {
    throw new TypeError('invalid ext.preferredEncrypt');
  } else if (!ext.preferredEncrypt) {
    ext.preferredEncrypt = false;
  }
  // direction is optional. If unset set it to sendrecv.
  if (ext.direction && typeof ext.direction !== 'string') {
    throw new TypeError('invalid ext.direction');
  } else if (!ext.direction) {
    ext.direction = 'sendrecv';
  }
}
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpCodecParameters(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  if (_typeof(codec) !== 'object') {
    throw new TypeError('codec is not an object');
  }
  // mimeType is mandatory.
  if (!codec.mimeType || typeof codec.mimeType !== 'string') {
    throw new TypeError('missing codec.mimeType');
  }
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) {
    throw new TypeError('invalid codec.mimeType');
  }
  // payloadType is mandatory.
  if (typeof codec.payloadType !== 'number') {
    throw new TypeError('missing codec.payloadType');
  }
  // clockRate is mandatory.
  if (typeof codec.clockRate !== 'number') {
    throw new TypeError('missing codec.clockRate');
  }
  var kind = mimeTypeMatch[1].toLowerCase();
  // channels is optional. If unset, set it to 1 (just if audio).
  if (kind === 'audio') {
    if (typeof codec.channels !== 'number') {
      codec.channels = 1;
    }
  } else {
    delete codec.channels;
  }
  // parameters is optional. If unset, set it to an empty object.
  if (!codec.parameters || _typeof(codec.parameters) !== 'object') {
    codec.parameters = {};
  }
  for (var _i2 = 0, _Object$keys2 = Object.keys(codec.parameters); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];
    var value = codec.parameters[key];
    if (value === undefined) {
      codec.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new TypeError("invalid codec parameter [key:".concat(key, "s, value:").concat(value, "]"));
    }
    // Specific parameters validation.
    if (key === 'apt') {
      if (typeof value !== 'number') {
        throw new TypeError('invalid codec apt parameter');
      }
    }
  }
  // rtcpFeedback is optional. If unset, set it to an empty array.
  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
    codec.rtcpFeedback = [];
  }
  var _iterator18 = _createForOfIteratorHelper(codec.rtcpFeedback),
    _step18;
  try {
    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
      var fb = _step18.value;
      validateAndNormalizeRtcpFeedback(fb);
    }
  } catch (err) {
    _iterator18.e(err);
  } finally {
    _iterator18.f();
  }
}
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtensionParameters(ext) {
  if (_typeof(ext) !== 'object') {
    throw new TypeError('ext is not an object');
  }
  // uri is mandatory.
  if (!ext.uri || typeof ext.uri !== 'string') {
    throw new TypeError('missing ext.uri');
  }
  // id is mandatory.
  if (typeof ext.id !== 'number') {
    throw new TypeError('missing ext.id');
  }
  // encrypt is optional. If unset set it to false.
  if (ext.encrypt && typeof ext.encrypt !== 'boolean') {
    throw new TypeError('invalid ext.encrypt');
  } else if (!ext.encrypt) {
    ext.encrypt = false;
  }
  // parameters is optional. If unset, set it to an empty object.
  if (!ext.parameters || _typeof(ext.parameters) !== 'object') {
    ext.parameters = {};
  }
  for (var _i3 = 0, _Object$keys3 = Object.keys(ext.parameters); _i3 < _Object$keys3.length; _i3++) {
    var key = _Object$keys3[_i3];
    var value = ext.parameters[key];
    if (value === undefined) {
      ext.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new TypeError('invalid header extension parameter');
    }
  }
}
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpEncodingParameters(encoding) {
  if (_typeof(encoding) !== 'object') {
    throw new TypeError('encoding is not an object');
  }
  // ssrc is optional.
  if (encoding.ssrc && typeof encoding.ssrc !== 'number') {
    throw new TypeError('invalid encoding.ssrc');
  }
  // rid is optional.
  if (encoding.rid && typeof encoding.rid !== 'string') {
    throw new TypeError('invalid encoding.rid');
  }
  // rtx is optional.
  if (encoding.rtx && _typeof(encoding.rtx) !== 'object') {
    throw new TypeError('invalid encoding.rtx');
  } else if (encoding.rtx) {
    // RTX ssrc is mandatory if rtx is present.
    if (typeof encoding.rtx.ssrc !== 'number') {
      throw new TypeError('missing encoding.rtx.ssrc');
    }
  }
  // dtx is optional. If unset set it to false.
  if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {
    encoding.dtx = false;
  }
  // scalabilityMode is optional.
  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') {
    throw new TypeError('invalid encoding.scalabilityMode');
  }
}
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtcpParameters(rtcp) {
  if (_typeof(rtcp) !== 'object') {
    throw new TypeError('rtcp is not an object');
  }
  // cname is optional.
  if (rtcp.cname && typeof rtcp.cname !== 'string') {
    throw new TypeError('invalid rtcp.cname');
  }
  // reducedSize is optional. If unset set it to true.
  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {
    rtcp.reducedSize = true;
  }
}
/**
 * Validates NumSctpStreams.
 * It throws if invalid.
 */
function validateNumSctpStreams(numStreams) {
  if (_typeof(numStreams) !== 'object') {
    throw new TypeError('numStreams is not an object');
  }
  // OS is mandatory.
  if (typeof numStreams.OS !== 'number') {
    throw new TypeError('missing numStreams.OS');
  }
  // MIS is mandatory.
  if (typeof numStreams.MIS !== 'number') {
    throw new TypeError('missing numStreams.MIS');
  }
}
function isRtxCodec(codec) {
  if (!codec) {
    return false;
  }
  return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    _ref$strict = _ref.strict,
    strict = _ref$strict === void 0 ? false : _ref$strict,
    _ref$modify = _ref.modify,
    modify = _ref$modify === void 0 ? false : _ref$modify;
  var aMimeType = aCodec.mimeType.toLowerCase();
  var bMimeType = bCodec.mimeType.toLowerCase();
  if (aMimeType !== bMimeType) {
    return false;
  }
  if (aCodec.clockRate !== bCodec.clockRate) {
    return false;
  }
  if (aCodec.channels !== bCodec.channels) {
    return false;
  }
  // Per codec special checks.
  switch (aMimeType) {
    case 'video/h264':
      {
        if (strict) {
          var _aCodec$parameters$pa, _bCodec$parameters$pa;
          var aPacketizationMode = (_aCodec$parameters$pa = aCodec.parameters['packetization-mode']) !== null && _aCodec$parameters$pa !== void 0 ? _aCodec$parameters$pa : 0;
          var bPacketizationMode = (_bCodec$parameters$pa = bCodec.parameters['packetization-mode']) !== null && _bCodec$parameters$pa !== void 0 ? _bCodec$parameters$pa : 0;
          if (aPacketizationMode !== bPacketizationMode) {
            return false;
          }
          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
            return false;
          }
          var selectedProfileLevelId;
          try {
            selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
          } catch (error) {
            return false;
          }
          if (modify) {
            if (selectedProfileLevelId) {
              aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
              bCodec.parameters['profile-level-id'] = selectedProfileLevelId;
            } else {
              delete aCodec.parameters['profile-level-id'];
              delete bCodec.parameters['profile-level-id'];
            }
          }
        }
        break;
      }
    case 'video/vp9':
      {
        if (strict) {
          var _aCodec$parameters$pr, _bCodec$parameters$pr;
          var aProfileId = (_aCodec$parameters$pr = aCodec.parameters['profile-id']) !== null && _aCodec$parameters$pr !== void 0 ? _aCodec$parameters$pr : 0;
          var bProfileId = (_bCodec$parameters$pr = bCodec.parameters['profile-id']) !== null && _bCodec$parameters$pr !== void 0 ? _bCodec$parameters$pr : 0;
          if (aProfileId !== bProfileId) {
            return false;
          }
        }
        break;
      }
  }
  return true;
}
function matchHeaderExtensions(aExt, bExt) {
  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
    return false;
  }
  if (aExt.uri !== bExt.uri) {
    return false;
  }
  return true;
}
function reduceRtcpFeedback(codecA, codecB) {
  var _codecA$rtcpFeedback;
  var reducedRtcpFeedback = [];
  var _iterator19 = _createForOfIteratorHelper((_codecA$rtcpFeedback = codecA.rtcpFeedback) !== null && _codecA$rtcpFeedback !== void 0 ? _codecA$rtcpFeedback : []),
    _step19;
  try {
    var _loop5 = function _loop5() {
      var _codecB$rtcpFeedback;
      var aFb = _step19.value;
      var matchingBFb = ((_codecB$rtcpFeedback = codecB.rtcpFeedback) !== null && _codecB$rtcpFeedback !== void 0 ? _codecB$rtcpFeedback : []).find(function (bFb) {
        return bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter);
      });
      if (matchingBFb) {
        reducedRtcpFeedback.push(matchingBFb);
      }
    };
    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
      _loop5();
    }
  } catch (err) {
    _iterator19.e(err);
  } finally {
    _iterator19.f();
  }
  return reducedRtcpFeedback;
}

},{"./utils":41,"h264-profile-level-id":14}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
var ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');
function parse(scalabilityMode) {
  var match = ScalabilityModeRegex.exec(scalabilityMode !== null && scalabilityMode !== void 0 ? scalabilityMode : '');
  if (match) {
    return {
      spatialLayers: Number(match[1]),
      temporalLayers: Number(match[2])
    };
  } else {
    return {
      spatialLayers: 1,
      temporalLayers: 1
    };
  }
}

},{}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateRouterRtpCapabilities = generateRouterRtpCapabilities;
exports.generateNativeRtpCapabilities = generateNativeRtpCapabilities;
exports.generateNativeSctpCapabilities = generateNativeSctpCapabilities;
exports.generateLocalDtlsParameters = generateLocalDtlsParameters;
exports.generateTransportRemoteParameters = generateTransportRemoteParameters;
exports.generateProducerRemoteParameters = generateProducerRemoteParameters;
exports.generateConsumerRemoteParameters = generateConsumerRemoteParameters;
exports.generateDataProducerRemoteParameters = generateDataProducerRemoteParameters;
exports.generateDataConsumerRemoteParameters = generateDataConsumerRemoteParameters;
var utils = require("../utils");
function generateFakeUuid() {
  return String(utils.generateRandomNumber());
}
function generateRouterRtpCapabilities() {
  return utils.deepFreeze({
    codecs: [{
      mimeType: 'audio/opus',
      kind: 'audio',
      preferredPayloadType: 100,
      clockRate: 48000,
      channels: 2,
      rtcpFeedback: [{
        type: 'transport-cc'
      }],
      parameters: {
        useinbandfec: 1,
        foo: 'bar'
      }
    }, {
      mimeType: 'video/VP8',
      kind: 'video',
      preferredPayloadType: 101,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }],
      parameters: {
        'x-google-start-bitrate': 1500
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 102,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 101
      }
    }, {
      mimeType: 'video/H264',
      kind: 'video',
      preferredPayloadType: 103,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }],
      parameters: {
        'level-asymmetry-allowed': 1,
        'packetization-mode': 1,
        'profile-level-id': '42e01f'
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 104,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 103
      }
    }, {
      mimeType: 'video/VP9',
      kind: 'video',
      preferredPayloadType: 105,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }],
      parameters: {
        'profile-id': 0,
        'x-google-start-bitrate': 1500
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 106,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 105
      }
    }],
    headerExtensions: [{
      kind: 'audio',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
      preferredId: 1,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
      preferredId: 1,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id',
      preferredId: 2,
      preferredEncrypt: false,
      direction: 'recvonly'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id',
      preferredId: 3,
      preferredEncrypt: false,
      direction: 'recvonly'
    }, {
      kind: 'audio',
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
      preferredId: 4,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
      preferredId: 4,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'audio',
      uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
      preferredId: 5,
      preferredEncrypt: false,
      direction: 'recvonly'
    }, {
      kind: 'video',
      uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
      preferredId: 5,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'audio',
      uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
      preferredId: 10,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:3gpp:video-orientation',
      preferredId: 11,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:toffset',
      preferredId: 12,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }]
  });
}
// NOTE: We don't freeze these RTP capabilities because we do need to normalize
// them as we do in real browser handlers (this is an object supposed to be
// generated internally so it's ok).
function generateNativeRtpCapabilities() {
  return {
    codecs: [{
      mimeType: 'audio/opus',
      kind: 'audio',
      preferredPayloadType: 111,
      clockRate: 48000,
      channels: 2,
      rtcpFeedback: [{
        type: 'transport-cc'
      }],
      parameters: {
        minptime: 10,
        useinbandfec: 1
      }
    }, {
      mimeType: 'audio/ISAC',
      kind: 'audio',
      preferredPayloadType: 103,
      clockRate: 16000,
      channels: 1,
      rtcpFeedback: [{
        type: 'transport-cc'
      }],
      parameters: {}
    }, {
      mimeType: 'audio/CN',
      kind: 'audio',
      preferredPayloadType: 106,
      clockRate: 32000,
      channels: 1,
      rtcpFeedback: [{
        type: 'transport-cc'
      }],
      parameters: {}
    }, {
      mimeType: 'audio/foo',
      kind: 'audio',
      preferredPayloadType: 107,
      clockRate: 90000,
      channels: 4,
      rtcpFeedback: [{
        type: 'foo-qwe-qwe'
      }],
      parameters: {
        foo: 'lalala'
      }
    }, {
      mimeType: 'video/BAZCODEC',
      kind: 'video',
      preferredPayloadType: 100,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'foo'
      }, {
        type: 'transport-cc'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }],
      parameters: {
        baz: '1234abcd'
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 101,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 100
      }
    }, {
      mimeType: 'video/VP8',
      kind: 'video',
      preferredPayloadType: 96,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }],
      parameters: {
        baz: '1234abcd'
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 97,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 96
      }
    }, {
      mimeType: 'video/VP9',
      kind: 'video',
      preferredPayloadType: 98,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }],
      parameters: {
        'profile-id': 0
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 99,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 98
      }
    }],
    headerExtensions: [{
      kind: 'audio',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
      preferredId: 1
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
      preferredId: 1
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:toffset',
      preferredId: 2
    }, {
      kind: 'video',
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
      preferredId: 3
    }, {
      kind: 'video',
      uri: 'urn:3gpp:video-orientation',
      preferredId: 4
    }, {
      kind: 'video',
      uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
      preferredId: 5
    }, {
      kind: 'video',
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/playout-delay',
      preferredId: 6
    }, {
      kind: 'video',
      // @ts-expect-error --- ON purpose.
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/video-content-type',
      preferredId: 7
    }, {
      kind: 'video',
      // @ts-expect-error --- ON purpose.
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/video-timing',
      preferredId: 8
    }, {
      kind: 'audio',
      uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
      preferredId: 10
    }]
  };
}
function generateNativeSctpCapabilities() {
  return utils.deepFreeze({
    numStreams: {
      OS: 2048,
      MIS: 2048
    }
  });
}
function generateLocalDtlsParameters() {
  return utils.deepFreeze({
    fingerprints: [{
      algorithm: 'sha-256',
      value: '82:5A:68:3D:36:C3:0A:DE:AF:E7:32:43:D2:88:83:57:AC:2D:65:E5:80:C4:B6:FB:AF:1A:A0:21:9F:6D:0C:AD'
    }],
    role: 'auto'
  });
}
function generateTransportRemoteParameters() {
  return {
    id: generateFakeUuid(),
    iceParameters: utils.deepFreeze({
      iceLite: true,
      password: 'yku5ej8nvfaor28lvtrabcx0wkrpkztz',
      usernameFragment: 'h3hk1iz6qqlnqlne'
    }),
    iceCandidates: utils.deepFreeze([{
      foundation: 'udpcandidate',
      address: '9.9.9.9',
      ip: '9.9.9.9',
      port: 40533,
      priority: 1078862079,
      protocol: 'udp',
      type: 'host',
      tcpType: 'passive'
    }, {
      foundation: 'udpcandidate',
      address: '9.9.9.9',
      ip: '9:9:9:9:9:9',
      port: 41333,
      priority: 1078862089,
      protocol: 'udp',
      type: 'host',
      tcpType: 'passive'
    }]),
    dtlsParameters: utils.deepFreeze({
      fingerprints: [{
        algorithm: 'sha-256',
        value: 'A9:F4:E0:D2:74:D3:0F:D9:CA:A5:2F:9F:7F:47:FA:F0:C4:72:DD:73:49:D0:3B:14:90:20:51:30:1B:90:8E:71'
      }, {
        algorithm: 'sha-384',
        value: '03:D9:0B:87:13:98:F6:6D:BC:FC:92:2E:39:D4:E1:97:32:61:30:56:84:70:81:6E:D1:82:97:EA:D9:C1:21:0F:6B:C5:E7:7F:E1:97:0C:17:97:6E:CF:B3:EF:2E:74:B0'
      }, {
        algorithm: 'sha-512',
        value: '84:27:A4:28:A4:73:AF:43:02:2A:44:68:FF:2F:29:5C:3B:11:9A:60:F4:A8:F0:F5:AC:A0:E3:49:3E:B1:34:53:A9:85:CE:51:9B:ED:87:5E:B8:F4:8E:3D:FA:20:51:B8:96:EE:DA:56:DC:2F:5C:62:79:15:23:E0:21:82:2B:2C'
      }],
      role: 'auto'
    }),
    sctpParameters: utils.deepFreeze({
      port: 5000,
      OS: 2048,
      MIS: 2048,
      maxMessageSize: 2000000
    })
  };
}
function generateProducerRemoteParameters() {
  return utils.deepFreeze({
    id: generateFakeUuid()
  });
}
function generateConsumerRemoteParameters() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    id = _ref.id,
    codecMimeType = _ref.codecMimeType;
  switch (codecMimeType) {
    case 'audio/opus':
      {
        return {
          id: id !== null && id !== void 0 ? id : generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: 'audio',
          rtpParameters: utils.deepFreeze({
            codecs: [{
              mimeType: 'audio/opus',
              payloadType: 100,
              clockRate: 48000,
              channels: 2,
              rtcpFeedback: [{
                type: 'transport-cc'
              }],
              parameters: {
                useinbandfec: 1,
                foo: 'bar'
              }
            }],
            encodings: [{
              ssrc: 46687003
            }],
            headerExtensions: [{
              uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
              id: 1
            }, {
              uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
              id: 5
            }, {
              uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
              id: 10
            }],
            rtcp: {
              cname: 'wB4Ql4lrsxYLjzuN',
              reducedSize: true,
              mux: true
            }
          })
        };
      }
    case 'audio/ISAC':
      {
        return {
          id: id !== null && id !== void 0 ? id : generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: 'audio',
          rtpParameters: utils.deepFreeze({
            codecs: [{
              mimeType: 'audio/ISAC',
              payloadType: 111,
              clockRate: 16000,
              channels: 1,
              rtcpFeedback: [{
                type: 'transport-cc'
              }],
              parameters: {}
            }],
            encodings: [{
              ssrc: 46687004
            }],
            headerExtensions: [{
              uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
              id: 1
            }, {
              uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
              id: 5
            }],
            rtcp: {
              cname: 'wB4Ql4lrsxYLjzuN',
              reducedSize: true,
              mux: true
            }
          })
        };
      }
    case 'video/VP8':
      {
        return {
          id: id !== null && id !== void 0 ? id : generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: 'video',
          rtpParameters: utils.deepFreeze({
            codecs: [{
              mimeType: 'video/VP8',
              payloadType: 101,
              clockRate: 90000,
              rtcpFeedback: [{
                type: 'nack'
              }, {
                type: 'nack',
                parameter: 'pli'
              }, {
                type: 'ccm',
                parameter: 'fir'
              }, {
                type: 'goog-remb'
              }, {
                type: 'transport-cc'
              }],
              parameters: {
                'x-google-start-bitrate': 1500
              }
            }, {
              mimeType: 'video/rtx',
              payloadType: 102,
              clockRate: 90000,
              rtcpFeedback: [],
              parameters: {
                apt: 101
              }
            }],
            encodings: [{
              ssrc: 99991111,
              rtx: {
                ssrc: 99991112
              }
            }],
            headerExtensions: [{
              uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
              id: 1
            }, {
              uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
              id: 4
            }, {
              uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
              id: 5
            }, {
              uri: 'urn:3gpp:video-orientation',
              id: 11
            }, {
              uri: 'urn:ietf:params:rtp-hdrext:toffset',
              id: 12
            }],
            rtcp: {
              cname: 'wB4Ql4lrsxYLjzuN',
              reducedSize: true,
              mux: true
            }
          })
        };
      }
    case 'video/H264':
      {
        return {
          id: id !== null && id !== void 0 ? id : generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: 'video',
          rtpParameters: utils.deepFreeze({
            codecs: [{
              mimeType: 'video/H264',
              payloadType: 103,
              clockRate: 90000,
              rtcpFeedback: [{
                type: 'nack'
              }, {
                type: 'nack',
                parameter: 'pli'
              }, {
                type: 'ccm',
                parameter: 'fir'
              }, {
                type: 'goog-remb'
              }, {
                type: 'transport-cc'
              }],
              parameters: {
                'level-asymmetry-allowed': 1,
                'packetization-mode': 1,
                'profile-level-id': '42e01f'
              }
            }, {
              mimeType: 'video/rtx',
              payloadType: 104,
              clockRate: 90000,
              rtcpFeedback: [],
              parameters: {
                apt: 103
              }
            }],
            encodings: [{
              ssrc: 99991113,
              rtx: {
                ssrc: 99991114
              }
            }],
            headerExtensions: [{
              uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
              id: 1
            }, {
              uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
              id: 4
            }, {
              uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
              id: 5
            }, {
              uri: 'urn:3gpp:video-orientation',
              id: 11
            }, {
              uri: 'urn:ietf:params:rtp-hdrext:toffset',
              id: 12
            }],
            rtcp: {
              cname: 'wB4Ql4lrsxYLjzuN',
              reducedSize: true,
              mux: true
            }
          })
        };
      }
    default:
      {
        throw new TypeError("unknown codecMimeType '".concat(codecMimeType, "'"));
      }
  }
}
function generateDataProducerRemoteParameters() {
  return utils.deepFreeze({
    id: generateFakeUuid()
  });
}
function generateDataConsumerRemoteParameters() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    id = _ref2.id;
  return {
    id: id !== null && id !== void 0 ? id : generateFakeUuid(),
    dataProducerId: generateFakeUuid(),
    sctpStreamParameters: utils.deepFreeze({
      streamId: 666,
      maxPacketLifeTime: 5000,
      maxRetransmits: undefined
    })
  };
}

},{"../utils":41}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],41:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clone = clone;
exports.generateRandomNumber = generateRandomNumber;
exports.deepFreeze = deepFreeze;
/**
 * Clones the given value.
 */
function clone(value) {
  if (value === undefined) {
    return undefined;
  } else if (Number.isNaN(value)) {
    return NaN;
  } else if (typeof structuredClone === 'function') {
    // Available in Node >= 18.
    return structuredClone(value);
  } else {
    return JSON.parse(JSON.stringify(value));
  }
}
/**
 * Generates a random positive integer.
 */
function generateRandomNumber() {
  return Math.round(Math.random() * 10000000);
}
/**
 * Make an object or array recursively immutable.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze.
 */
function deepFreeze(data) {
  // Retrieve the property names defined on object.
  var propNames = Reflect.ownKeys(data);
  // Freeze properties before freezing self.
  var _iterator = _createForOfIteratorHelper(propNames),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var name = _step.value;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var value = data[name];
      if (value && _typeof(value) === 'object' || typeof value === 'function') {
        deepFreeze(value);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return Object.freeze(data);
}

},{}],42:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = _typeof(val);
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],43:[function(require,module,exports){
"use strict";

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};

},{}],44:[function(require,module,exports){
"use strict";

var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: 'name'
  }],
  i: [{
    name: 'description'
  }],
  u: [{
    name: 'uri'
  }],
  e: [{
    name: 'email'
  }],
  p: [{
    name: 'phone'
  }],
  z: [{
    name: 'timezones'
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: 'repeats'
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{
    // b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [{
    // a=rtpmap:110 opus/48000/2
    push: 'rtp',
    reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
    names: ['payload', 'codec', 'rate', 'encoding'],
    format: function format(o) {
      return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';
    }
  }, {
    // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
    // a=fmtp:111 minptime=10; useinbandfec=1
    push: 'fmtp',
    reg: /^fmtp:(\d*) ([\S| ]*)/,
    names: ['payload', 'config'],
    format: 'fmtp:%d %s'
  }, {
    // a=control:streamid=0
    name: 'control',
    reg: /^control:(.*)/,
    format: 'control:%s'
  }, {
    // a=rtcp:65179 IN IP4 193.84.77.194
    name: 'rtcp',
    reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
    names: ['port', 'netType', 'ipVer', 'address'],
    format: function format(o) {
      return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';
    }
  }, {
    // a=rtcp-fb:98 trr-int 100
    push: 'rtcpFbTrrInt',
    reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
    names: ['payload', 'value'],
    format: 'rtcp-fb:%s trr-int %d'
  }, {
    // a=rtcp-fb:98 nack rpsi
    push: 'rtcpFb',
    reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
    names: ['payload', 'type', 'subtype'],
    format: function format(o) {
      return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';
    }
  }, {
    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
    // a=extmap:1/recvonly URI-gps-string
    // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
    push: 'ext',
    reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
    names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
    format: function format(o) {
      return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');
    }
  }, {
    // a=extmap-allow-mixed
    name: 'extmapAllowMixed',
    reg: /^(extmap-allow-mixed)/
  }, {
    // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
    push: 'crypto',
    reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
    names: ['id', 'suite', 'config', 'sessionConfig'],
    format: function format(o) {
      return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';
    }
  }, {
    // a=setup:actpass
    name: 'setup',
    reg: /^setup:(\w*)/,
    format: 'setup:%s'
  }, {
    // a=connection:new
    name: 'connectionType',
    reg: /^connection:(new|existing)/,
    format: 'connection:%s'
  }, {
    // a=mid:1
    name: 'mid',
    reg: /^mid:([^\s]*)/,
    format: 'mid:%s'
  }, {
    // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
    name: 'msid',
    reg: /^msid:(.*)/,
    format: 'msid:%s'
  }, {
    // a=ptime:20
    name: 'ptime',
    reg: /^ptime:(\d*(?:\.\d*)*)/,
    format: 'ptime:%d'
  }, {
    // a=maxptime:60
    name: 'maxptime',
    reg: /^maxptime:(\d*(?:\.\d*)*)/,
    format: 'maxptime:%d'
  }, {
    // a=sendrecv
    name: 'direction',
    reg: /^(sendrecv|recvonly|sendonly|inactive)/
  }, {
    // a=ice-lite
    name: 'icelite',
    reg: /^(ice-lite)/
  }, {
    // a=ice-ufrag:F7gI
    name: 'iceUfrag',
    reg: /^ice-ufrag:(\S*)/,
    format: 'ice-ufrag:%s'
  }, {
    // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
    name: 'icePwd',
    reg: /^ice-pwd:(\S*)/,
    format: 'ice-pwd:%s'
  }, {
    // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
    name: 'fingerprint',
    reg: /^fingerprint:(\S*) (\S*)/,
    names: ['type', 'hash'],
    format: 'fingerprint:%s %s'
  }, {
    // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
    // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
    // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
    // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
    // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
    push: 'candidates',
    reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
    names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
    format: function format(o) {
      var str = 'candidate:%s %d %s %d %s %d typ %s';
      str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';

      // NB: candidate has three optional chunks, so %void middles one if it's missing
      str += o.tcptype != null ? ' tcptype %s' : '%v';
      if (o.generation != null) {
        str += ' generation %d';
      }
      str += o['network-id'] != null ? ' network-id %d' : '%v';
      str += o['network-cost'] != null ? ' network-cost %d' : '%v';
      return str;
    }
  }, {
    // a=end-of-candidates (keep after the candidates line for readability)
    name: 'endOfCandidates',
    reg: /^(end-of-candidates)/
  }, {
    // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
    name: 'remoteCandidates',
    reg: /^remote-candidates:(.*)/,
    format: 'remote-candidates:%s'
  }, {
    // a=ice-options:google-ice
    name: 'iceOptions',
    reg: /^ice-options:(\S*)/,
    format: 'ice-options:%s'
  }, {
    // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
    push: 'ssrcs',
    reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
    names: ['id', 'attribute', 'value'],
    format: function format(o) {
      var str = 'ssrc:%d';
      if (o.attribute != null) {
        str += ' %s';
        if (o.value != null) {
          str += ':%s';
        }
      }
      return str;
    }
  }, {
    // a=ssrc-group:FEC 1 2
    // a=ssrc-group:FEC-FR 3004364195 1080772241
    push: 'ssrcGroups',
    // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
    reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
    names: ['semantics', 'ssrcs'],
    format: 'ssrc-group:%s %s'
  }, {
    // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
    name: 'msidSemantic',
    reg: /^msid-semantic:\s?(\w*) (\S*)/,
    names: ['semantic', 'token'],
    format: 'msid-semantic: %s %s' // space after ':' is not accidental
  }, {
    // a=group:BUNDLE audio video
    push: 'groups',
    reg: /^group:(\w*) (.*)/,
    names: ['type', 'mids'],
    format: 'group:%s %s'
  }, {
    // a=rtcp-mux
    name: 'rtcpMux',
    reg: /^(rtcp-mux)/
  }, {
    // a=rtcp-rsize
    name: 'rtcpRsize',
    reg: /^(rtcp-rsize)/
  }, {
    // a=sctpmap:5000 webrtc-datachannel 1024
    name: 'sctpmap',
    reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
    names: ['sctpmapNumber', 'app', 'maxMessageSize'],
    format: function format(o) {
      return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';
    }
  }, {
    // a=x-google-flag:conference
    name: 'xGoogleFlag',
    reg: /^x-google-flag:([^\s]*)/,
    format: 'x-google-flag:%s'
  }, {
    // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
    push: 'rids',
    reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
    names: ['id', 'direction', 'params'],
    format: function format(o) {
      return o.params ? 'rid:%s %s %s' : 'rid:%s %s';
    }
  }, {
    // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
    // a=imageattr:* send [x=800,y=640] recv *
    // a=imageattr:100 recv [x=320,y=240]
    push: 'imageattrs',
    reg: new RegExp(
    // a=imageattr:97
    '^imageattr:(\\d+|\\*)' +
    // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
    '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
    // recv [x=330,y=250]
    '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'),
    names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
    format: function format(o) {
      return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
    }
  }, {
    // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
    // a=simulcast:recv 1;4,5 send 6;7
    name: 'simulcast',
    reg: new RegExp(
    // a=simulcast:
    '^simulcast:' +
    // send 1,2,3;~4,~5
    '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
    // space + recv 6;~7,~8
    '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
    // end
    '$'),
    names: ['dir1', 'list1', 'dir2', 'list2'],
    format: function format(o) {
      return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
    }
  }, {
    // old simulcast draft 03 (implemented by Firefox)
    //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
    // a=simulcast: recv pt=97;98 send pt=97
    // a=simulcast: send rid=5;6;7 paused=6,7
    name: 'simulcast_03',
    reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
    names: ['value'],
    format: 'simulcast: %s'
  }, {
    // a=framerate:25
    // a=framerate:29.97
    name: 'framerate',
    reg: /^framerate:(\d+(?:$|\.\d+))/,
    format: 'framerate:%s'
  }, {
    // RFC4570
    // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
    name: 'sourceFilter',
    reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
    names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
    format: 'source-filter: %s %s %s %s %s'
  }, {
    // a=bundle-only
    name: 'bundleOnly',
    reg: /^(bundle-only)/
  }, {
    // a=label:1
    name: 'label',
    reg: /^label:(.+)/,
    format: 'label:%s'
  }, {
    // RFC version 26 for SCTP over DTLS
    // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
    name: 'sctpPort',
    reg: /^sctp-port:(\d+)$/,
    format: 'sctp-port:%s'
  }, {
    // RFC version 26 for SCTP over DTLS
    // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
    name: 'maxMessageSize',
    reg: /^max-message-size:(\d+)$/,
    format: 'max-message-size:%s'
  }, {
    // RFC7273
    // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
    push: 'tsRefClocks',
    reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
    names: ['clksrc', 'clksrcExt'],
    format: function format(o) {
      return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
    }
  }, {
    // RFC7273
    // a=mediaclk:direct=963214424
    name: 'mediaClk',
    reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
    names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
    format: function format(o) {
      var str = 'mediaclk:';
      str += o.id != null ? 'id=%s %s' : '%v%s';
      str += o.mediaClockValue != null ? '=%s' : '';
      str += o.rateNumerator != null ? ' rate=%s' : '';
      str += o.rateDenominator != null ? '/%s' : '';
      return str;
    }
  }, {
    // a=keywds:keywords
    name: 'keywords',
    reg: /^keywds:(.+)$/,
    format: 'keywds:%s'
  }, {
    // a=content:main
    name: 'content',
    reg: /^content:(.+)/,
    format: 'content:%s'
  },
  // BFCP https://tools.ietf.org/html/rfc4583
  {
    // a=floorctrl:c-s
    name: 'bfcpFloorCtrl',
    reg: /^floorctrl:(c-only|s-only|c-s)/,
    format: 'floorctrl:%s'
  }, {
    // a=confid:1
    name: 'bfcpConfId',
    reg: /^confid:(\d+)/,
    format: 'confid:%s'
  }, {
    // a=userid:1
    name: 'bfcpUserId',
    reg: /^userid:(\d+)/,
    format: 'userid:%s'
  }, {
    // a=floorid:1
    name: 'bfcpFloorId',
    reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
    names: ['id', 'mStream'],
    format: 'floorid:%s mstrm:%s'
  }, {
    // any a= that we don't understand is kept verbatim on media.invalid
    push: 'invalid',
    names: ['value']
  }]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});

},{}],45:[function(require,module,exports){
"use strict";

var parser = require('./parser');
var writer = require('./writer');
var grammar = require('./grammar');
exports.grammar = grammar;
exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;

},{"./grammar":44,"./parser":46,"./writer":47}],46:[function(require,module,exports){
"use strict";

var toIntIfInt = function toIntIfInt(v) {
  return String(Number(v)) === v ? Number(v) : v;
};
var attachProperties = function attachProperties(match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  } else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i + 1] != null) {
        location[names[i]] = toIntIfInt(match[i + 1]);
      }
    }
  }
};
var parseReg = function parseReg(obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  } else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ? {} :
  // blank object that will be pushed
  needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};
var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
exports.parse = function (sdp) {
  var session = {},
    media = [],
    location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({
        rtp: [],
        fmtp: []
      });
      location = media[media.length - 1]; // point at latest media line
    }
    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });
  session.media = media; // link it up
  return session;
};
var paramReducer = function paramReducer(acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};
exports.parseParams = function (str) {
  return str.split(/;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;
exports.parsePayloads = function (str) {
  return str.toString().split(' ').map(Number);
};
exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};
exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});
  });
};
exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid,
        paused = false;
      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }
      return {
        scid: scid,
        paused: paused
      };
    });
  });
};

},{"./grammar":44}],47:[function(require,module,exports){
"use strict";

var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function format(formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
      case '%%':
        return '%';
      case '%s':
        return String(arg);
      case '%d':
        return Number(arg);
      case '%v':
        return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};
var makeLine = function makeLine(type, obj, location) {
  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      } else {
        // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  } else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];
module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });
  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      } else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));
    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        } else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });
  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":44}]},{},[36])(36)
});
